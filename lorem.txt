BASH(1)                     General Commands Manual                    BASH(1)



NAZWA
       bash - GNU Bourne-Again SHell

SKŁADNIA
       bash [opcje] [plik]

PRAWA AUTORSKIE
       Bash is Copyright (C) 1989-2011 by the Free Software Foundation, Inc.

OPIS
       Bash  jest  zgodnym  z  sh  interpreterem  języka  poleceń, wykonującym
       polecenia ze standardowego wejścia bądź z pliku.  Włączono doń  również
       przydatne cechy zaczerpnięte z powłoki Korna i powłoki C (ksh i csh).

       Bash  w  zamierzeniu jest implementacją zgodną z POSIX-ową specyfikacją
       powłok i narzędzi -- IEEE POSIX Shell and Utilities specification (IEEE
       Standard  1003.1).  Bash  może być skonfigurowany w ten sposób, aby był
       domyślnie zgodny z normą POSIX.

OPCJE
       Oprócz jednoznakowych opcji  powłoki  udokumentowanych  w  opisie  wbu‐
       dowanego  polecenia  set, polecenia wbudowane mogą być użyte jako opcje
       przy wywołaniu powłoki. Dodatkowo,  bash  przy  wywołaniu  interpretuje
       poniższe opcje:

       -c łańcuch
                 Jeśli  występuje  opcja  -c,  to  polecenia  odczytywane są z
                 łańcucha.  Jeżeli po łańcuchu istnieją argumenty, to  są  one
                 przypisywane do argumentów pozycyjnych, poczynając od $0.
       -i        Jeżeli występuje opcja -i, to powłoka jest interaktywna.
       -l        Program  bash  będzie  działał  jakby  został  wywołany  jako
                 powłoka zgłoszeniowa (patrz niżej WYWOŁANIE).
       -r        Jeżeli występuje opcja -r, to powłoka staje się powłoką okro‐
                 joną (restricted). Patrz poniżej POWŁOKA OKROJONA.
       -s        Jeśli  występuje  opcja  -s  lub  po  przetworzeniu opcji nie
                 pozostają żadne argumenty, to  polecenia  odczytywane  są  ze
                 standardowego  wejścia.  Opcja  ta  umożliwia  na  ustawienie
                 parametrów pozycyjnych podczas wywołania  powłoki  interakty‐
                 wnej.
       -D        Na  standardowym  wyjściu  wypisywana  jest  lista  łańcuchów
                 cytowanych  cudzysłowem  poprzedzonych  znakiem  $.   Są   to
                 łańcuchy  będące przedmiotem tłumaczenia języka, gdy bieżącym
                 ustawieniem regionalnym (locale) nie jest C ani POSIX.   Imp‐
                 likuje to opcję -n; nie zostaną wykonane żadne polecenia.
       [-+]O [opcja_shopt]
                 opcja_shopt  jest  jedną  z opcji powłoki akceptowanych przez
                 polecenie wbudowane shopt (zobacz WBUDOWANE POLECENIA POWŁOKI
                 poniżej).   Jeśli występuje opcja_shopt, to -O nadaje wartość
                 tej  opcji,  zaś  +O  unieważnia  ją.   Jeżeli   nie   podano
                 opcji_shopt, to na standardowym wyjściu wypisywane są nazwy i
                 wartości opcji  powłoki  akceptowanych  przez  shopt.   Jeśli
                 opcją  wywołania jest +O, tworzone wyjście jest formatowane w
                 taki sposób, by można było wykorzystać je jako wejście.
       --        Zapis --  sygnalizuje  koniec  opcji  i  wyłącza  dalsze  ich
                 przetwarzanie.   Argumenty  występujące  po  -- traktowane są
                 jako nazwy plików i argumenty. Argument - jest równoważnikiem
                 --.

       Bash  interpretuje także wiele opcji wieloznakowych.  Jeśli mają zostać
       rozpoznane, opcje te muszą pojawić się w wierszu poleceń przed  opcjami
       jednoznakowymi,

       --debugger
              Ustawia  profil  debuggera  do  wykonania,  przed  uruchomieniem
              powłoki. Włącza rozszerzony tryb debugowania (patrz  opis  opcji
              extdebug do wbudowanego polecenia shopt poniżej).
       --dump-po-strings
              Równoważne  -D, ale wyjście jest w formacie pliku GNU gettext po
              (portable object).
       --dump-strings
              Równoważnik -D.
       --help Wyświetla na standardowym  wyjściu  komunikat  o  użytkowaniu  i
              pomyślnie kończy pracę.
       --init-file plik
       --rcfile plik
              Wykonuje  polecenia  z  podanego  pliku zamiast ze standardowego
              systemowego pliku  inicjującego  /etc/bash.bashrc  i  osobistego
              pliku  inicjującego  ~/.bashrc, jeśli powłoka jest interaktywna.
              Zobacz WYWOŁANIE poniżej.

       --login
              Równoważne -l.

       --noediting
              Nie używa biblioteki GNU readline do odczytu wierszy  poleceń  w
              trybie interaktywnym.

       --noprofile
              Nie  odczytuje  ani ogólnosystemowego pliku startowego /etc/pro‐
              file ani żadnego z osobistych plików  inicjujących  ~/.bash_pro‐
              file,  ~/.bash_login  czy  ~/.profile.  Domyślnie, bash czyta te
              pliki  gdy  jest  wywołany  jako  powłoka  zgłoszeniowa  (zobacz
              WYWOŁANIE poniżej).

       --norc Nie  odczytuje  i  nie  wykonuje  systemowego pliku inicjującego
              /etc/bash.bashrc oraz osobistego  pliku  inicjującego  ~/.bashrc
              jeśli   powłoka  jest  interaktywna.  Opcja  ta  jest  domyślnie
              włączona, jeżeli powłokę wywołano jako sh.

       --posix
              Zmienia zachowanie bash tam, gdzie domyślne działanie różni  się
              od standardu POSIX, tak by spełniać standard (tryb posix).

       --restricted
              Powłoka staje się okrojona (zobacz POWŁOKA OKROJONA poniżej).

       --verbose
              Równoważnik opcji -v.

       --version
              Pokazuje na standardowym wyjściu informację o wersji tego egzem‐
              plarza bash i pomyślnie kończy pracę.

ARGUMENTY
       Jeśli po przetworzeniu opcji pozostają jakieś argumenty, a  nie  podano
       ani  opcji  -c  ani -s, to zakłada się, że pierwszy argument jest nazwą
       pliku zawierającego polecenia powłoki. Jeżeli bash  został  wywołany  w
       taki  sposób,  to  $0  przypisywana  jest  nazwa pliku z poleceniami, a
       parametrom pozycyjnym pozostałe argumenty. Bash  odczytuje  i  wykonuje
       polecenia z tego pliku, a następnie kończy pracę. Kod zakończenia basha
       jest wówczas kodem zakończenia ostatniego wykonanego polecenia skryptu.
       Jeśli  nie  wykonano  żadnego  polecenia,  to kod zakończenia wynosi 0.
       Najpierw wykonywana jest próba otworzenia pliku w bieżącym katalogu,  a
       następnie,  jeśli się ona nie powiedzie, powłoka przeszukuje katalogi w
       PATH szukając skryptu.

WYWOŁANIE
       Powłoka zgłoszeniowa (login shell) to taka, w której pierwszym  znakiem
       zerowego argumentu jest -, lub taka, którą uruchomiono z opcją --login.

       Powłoka  interaktywna  to taka, którą uruchomiono bez argumentów innych
       niż opcje i bez opcji -c; zarówno jej standardowe wejście jak i wyjście
       powiązane  jest z terminalami (tak jak określiła to funkcja isatty(3)),
       albo taka, którą uruchomiono z opcją -i.  Jeśli bash jest interaktywny,
       to  ustawiane  jest  PS1 zaś $- zawiera i; pozwala to skryptowi powłoki
       lub plikowi startowemu na sprawdzanie tego stanu.

       Poniższe akapity opisują,  jak  bash  wykonuje  swoje  pliki  startowe.
       Jeśli  któryś  z  tych  plików istnieje, ale nie może być odczytany, to
       bash zgłasza błąd.  Tyldy (~) w nazwach plików interpretowane są według
       reguł  opisanych  poniżej  w części Interpretacja tyld sekcji INTERPRE‐
       TACJA.

       Gdy bash wywoływany jest jako powłoka  zgłoszeniowa  lub  jako  powłoka
       nie-interaktywna  z  opcją  --login,  w  pierwszej  kolejności  czyta i
       wykonuje polecenia z pliku /etc/profile,  jeśli  takowy  istnieje.   Po
       odczytaniu  tego  pliku, szuka ~/.bash_profile, ~/.bash_login i ~/.pro‐
       file, w tej kolejności, po czym odczytuje i wykonuje polecenia z  pier‐
       wszego  istniejącego i dającego się odczytać.  Można posłużyć się opcją
       --noprofile podczas uruchamiania powłoki, by zakazać  takiego  zachowa‐
       nia.

       Podczas  kończenia  pracy  powłoki zgłoszeniowej, bash czyta i wykonuje
       polecenia z pliku ~/.bash_logout, jeśli taki istnieje.

       Jeżeli  uruchamiana  jest  powłoka  interaktywna  nie  będąca   powłoką
       zgłoszeniową,  bash  czyta  i  wykonuje  polecenia z /etc/bash.bashrc i
       ~/.bashrc, jeśli takie pliki istnieją.  Może to być zakazane za  pomocą
       opcji  --norc.  Opcja --rcfile plik wymusi odczyt i wykonanie poleceń z
       pliku zamiast z /etc/bash.bashrc i ~/.bashrc.

       Jeśli bash startuje w trybie nie-interaktywnym, na przykład w celu uru‐
       chomienia  skryptu  powłoki,  to  szuka w środowisku zmiennej BASH_ENV,
       interpretuje jej wartość, jeśli ją znalazł, i używa otrzymanej wartości
       jako  nazwy  pliku  do odczytania i wykonania.  Bash zachowuje się tak,
       jakby były wykonane następujące polecenia:
              if [ -n "$BASH_ENV" ]; then . "$BASH_ENV"; fi
       ale do szukania nazwy pliku nie jest używana wartość zmiennej PATH.

       Jeżeli bash wywołano pod nazwą sh, to próbuje on naśladować  zachowanie
       startowe  historycznych  wersji sh tak ściśle jak to jest możliwe, przy
       równoczesnym spełnianiu standardu POSIX.  Wywołany jako powłoka  inter‐
       aktywna  lub  powłoka  nie-interaktywna  z  opcją  --login,  usiłuje na
       początku odczytać i wykonać polecenia z /etc/profile  i  ~/.profile,  w
       tej  kolejności.   W  celu  zakazania  tego zachowania można użyć opcji
       --noprofile.  Wywołany jako powłoka interaktywna  pod  nazwą  sh,  bash
       poszukuje  zmiennej  ENV,  interpretuje jej wartość, jeśli jest zdefin‐
       iowana, i posługuje się otrzymaną wartością jako nazwą pliku, który  ma
       być  odczytany  i  wykonany.   Ponieważ  powłoka  wywołana  jako sh nie
       usiłuje czytać ani wykonywać  poleceń  z  jakichkolwiek  innych  plików
       startowych,  opcja --rcfile nie ma żadnych skutków.  Powłoka nie-inter‐
       aktywna wywołana pod nazwą sh nie próbuje czytać żadnych  plików  star‐
       towych.  Wywołany jako sh, bash wchodzi w tryb posix po odczycie plików
       startowych.

       Gdy bash uruchomiony jest w trybie posix, jak z opcją  --posix  wiersza
       poleceń,  kieruje się standardem POSIX dla plików startowych.  W trybie
       tym, powłoka interaktywna interpretuje zmienną ENV a polecenia odczyty‐
       wane  i  wykonywane  są  z  pliku,  którego  nazwą jest zinterpretowana
       wartość.  Nie są czytane inne pliki startowe.

       Bash  usiłuje  rozstrzygnąć,  czy  jest  uruchomiony  ze   standardowym
       wejściem podpiętym do połączenia sieciowego, przez demona powłoki zdal‐
       nej, zwykle rshd lub przez bezpiecznego demona  powłoki  sshd.   Jeżeli
       stwierdzi, że został uruchomiony w ten  sposób, to odczytuje i wykonuje
       polecenia z ~/.bashrc, jeśli plik ten istnieje i daje się  czytać.  Nie
       będzie  tego  robił wywołany jako sh.  Można posłużyć się opcją --norc,
       by zakazać tego zachowania oraz opcją  --rcfile,  by  wymusić  czytanie
       innego  pliku,  ale  rshd zazwyczaj nie wywołuje powłoki z tymi opcjami
       ani nie pozwala na ich podanie.

       Jeśli powłoka została uruchomiona z efektywnym id  użytkownika  (grupy)
       różnym  od  id rzeczywistego, a nie podano opcji -p, to nie są odczyty‐
       wane żadne pliki startowe,  funkcje  powłoki  nie  są  dziedziczone  ze
       środowiska,  zmienne  SHELLOPTSP, BASHOPTS, CDPATH, i GLOBIGNORE, jeśli
       jest takie występują w środowisku, są ignorowane  a  efektywny  identy‐
       fikator  użytkownika  jest ustawiany na jego identyfikator rzeczywisty.
       Jeśli przy wywołaniu podano opcję -p, to zachowanie startowe jest takie
       samo, ale nie jest resetowany efektywny id użytkownika.

DEFINICJE
       W pozostałej części tego dokumentu używane są poniższe definicje.
       odstęp Spacja lub znak tabulacji.
       słowo  Sekwencja  znaków uważana przez powłokę za pojedynczą jednostkę.
              Znana też jako token.
       nazwa  Jest  to  słowo  składające  się  wyłącznie  ze  znaków  alfanu‐
              merycznych  i  znaków podkreślenia, i rozpoczynające się znakiem
              alfabetycznym lub podkreśleniem. Wspominane również jako identy‐
              fikator.
       metaznak
              Znak,  który,  gdy  nie  jest  cytowany, oddziela słowa. Jeden z
              poniższych:
              |  & ; ( ) < > space tab
       operator sterujący
              token pełniący funkcję sterującą. Jest  to  jeden  z  poniższych
              symboli:
              || & && ; ;; ( ) | |& <newline>

SŁOWA ZASTRZEŻONE
       Słowa  zastrzeżone  (reserved  words)  to takie, które mają dla powłoki
       specjalne znaczenie.   Następujące  słowa  są  rozpoznawane  jako  zas‐
       trzeżone,  gdy  nie  są  cytowane  i występują albo jako pierwsze słowo
       polecenia prostego (zobacz  GRAMATYKA  POWŁOKI  poniżej)  albo  trzecie
       słowo poleceń case lub for;

       !  case  do done elif else esac fi for function if in select then until
       while { } time [[ ]]

GRAMATYKA POWŁOKI
   Polecenia proste
       Polecenie proste jest sekwencją opcjonalnych  przypisań  zmiennych,  po
       której  następują  rozdzielane  przez  odstęp słowa i przekierowania, a
       zakończoną operatorem sterującym.  Pierwsze  słowo  określa  polecenie,
       jakie  ma zostać wykonane i jest przekazywane jako argument numer zero.
       Pozostałe słowa są przekazywane jako argumenty wywoływanego polecenia.

       Wartością zwracaną polecenia prostego jest  jego  kod  zakończenia  lub
       128+n jeżeli polecenie przerwane jest sygnałem n.

   Potoki
       Potok  jest sekwencją jednego lub więcej poleceń rozdzielonych jednym z
       operatorów kontrolnych | lub |&. Formatem potoku jest:

              [time [-p]] [ ! ] polecenie [ [|⎪|&] polecenie2 ... ]

       Standardowe wyjście z polecenia połączone jest za pośrednictwem  potoku
       ze  standardowym  wejściem  polecenia2.   Połączenie to wykonywane jest
       przed możliwymi przekierowaniami podanymi dla polecenia (zobacz poniżej
       PRZEKIEROWANIE.  Jeśli  użyte  jest  |&,  to standardowe wyjście błędów
       polecenia jest połączone ze standardowym wejściem polecenia2 za  pomocą
       potoku;  jest  to skrócona forma 2>&1 |. To bezpośrednie przekierowanie
       standardowego  wyjścia  błędów  jest   przeprowadzane   po   wszystkich
       przekierowaniach określonych przez polecenie.

       Zwracanym  kodem  zakończenia  potoku  jest  kod zakończenia ostatniego
       polecenia, chyba że włączono opcję  pipefail.  W  takim  przypadku  kod
       zakończenia  potoku  jest  wartością  ostatniego (po prawej) polecenia,
       które zakończyło się kodem niezerowym lub zero, jeśli wszystkie polece‐
       nia  zakończyły  się  powodzeniem.  Jeżeli  potok poprzedza zastrzeżone
       słowo !, to kod zakończenia takiego  potoku  jest  negacją  (NOT)  kodu
       zakończenia  ostatniego  polecenia, zgodnie z powyższym opisem. Powłoka
       oczekuje na zakończenie (terminate) wszystkich poleceń w  potoku  przed
       zwróceniem wartości.

       Jeżeli  potok  jest  poprzedzony  słowem  zastrzeżonym time, to po jego
       zakończeniu podawany jest czas wykonywania, jak również czas  użytkown‐
       ika  i czas systemu zużyty na wykonanie.  Opcja -p zmienia format twor‐
       zonych wyników na określony przez POSIX. Jeśli powłoka znajduje  się  w
       trybie  posix,  to  nie rozpoznaje time jako słowa zastrzeżonego, jeśli
       kolejny token rozpoczyna się znakiem  "-".  Do  sformatowania  łańcucha
       określającego,  jak powinna być wyświetlana informacja o czasach, można
       ustawić zmienną TIMEFORMAT; zobacz opis TIMEFORMAT  w  Zmienne  powłoki
       poniżej.

       Jeśli  powłoka  znajduje  się  w trybie posix, to po time może wystąpić
       znak nowego wiersza. W takim  przypadku,  powłoka  wyświetla  całkowity
       czas  użytkownika i systemu, skonsumowany przez powłokę i jej potomków.
       Zmienną TIMEFORMAT można określić format informacji o czasie.

       Każde polecenie w potoku uruchamiane jest jako odrębny  proces  (tj.  w
       podpowłoce).

   Listy
       Lista  jest potokiem lub sekwencją kilku potoków rozdzielonych jednym z
       operatorów ;, &, && lub ⎪⎪, i opcjonalnie zakończoną jednym  ze  znaków
       ;, & lub <nowy-wiersz>.

       Spośród  tych  operatorów  listowych,  &&  i ⎪⎪ mają ten sam priorytet,
       następujące po nich ; i &, również mają równy między sobą priorytet.

       W zastępstwie średnika, w liście może pojawić się sekwencja jednego lub
       więcej znaków nowego wiersza.

       Jeśli  polecenie  zakończone  jest  operatorem sterującym &, to powłoka
       wykonuje je w tle (background) w podpowłoce.  Powłoka  macierzysta  nie
       oczekuje  na  zakończenie polecenia, a zwracany kod wynosi 0. Polecenia
       oddzielane znakiem  średnika  ;  wykonywane  są  sekwencyjnie;  powłoka
       oczekuje na zakończenie pracy przez każde z nich po kolei. Zwracany kod
       jest kodem zakończenia ostatniego wykonanego polecenia.

       Listy AND i OR są sekwencjami jednego lub więcej  potoków  oddzielonych
       odpowiednio  operatorami sterującymi && i ||. Listy AND i OR są wykony‐
       wane z pozostawioną łącznością. Lista AND ma postać

              polecenie1 && polecenie2

       polecenie2 wykonywane jest wtedy, i tylko wtedy, gdy polecenie1  zwraca
       zerowy kod zakończenia.

       Lista OR ma postać

              polecenie1 ⎪⎪ polecenie2

       polecenie2  jest wykonywane wtedy, i tylko wtedy, gdy polecenie1 zwraca
       niezerowy kod zakończenia. Kod zwracany przez listy AND i OR jest kodem
       zakończenia ostatniego wykonanego polecenia listy.

   Polecenia złożone
       Polecenie złożone (compound command) jest jednym z poniższych:

       (lista)
              Lista wykonywana jest w podpowłoce (patrz ŚRODOWISKO WYKONYWANIA
              POLECEŃ poniżej). Przypisania zmiennych  i  polecenia  wbudowane
              wpływające na środowisko powłoki nie zachowują swoich skutków po
              zakończeniu polecenia.  Zwracanym  kodem  jest  kod  zakończenia
              listy.

       { lista; }
              Lista  jest  po prostu wykonywana w bieżącym środowisku powłoki.
              Lista musi być zakończona  znakiem  nowej  linii  lub  średnika.
              Nazywane jest to poleceniem grupowania. Zwracanym kodem jest kod
              zakończenia listy.  Należy pamiętać,  że  w  przeciwieństwie  do
              metaznaków  (  i ), { i } są słowami zastrzeżonymi i aby zostały
              rozpoznane muszą się pojawić tam, gdzie  dozwolone  jest  użycie
              słów  zastrzeżonych.   Ponieważ  nie powodują podziału na słowa,
              muszą być oddzielone od listy za pomocą białego znaku lub innego
              metaznaku powłoki.

       ((wyrażenie))
              Wyrażenie  interpretowane  jest  zgodnie  z  zasadami  opisanymi
              poniżej  w  sekcji  OBLICZANIE  WYRAŻEŃ  ARYTMETYCZNYCH.   Jeśli
              wartość  wyrażenia  jest niezerowa, to kodem zwracanym jest 0; w
              przeciwnym  razie  kodem  zwracanym  jest  1.  Jest  to   ściśle
              równoważne konstrukcji let "wyrażenie".

       [[ wyrażenie ]]
              Zwraca  kod  0  lub  1  w  zależności od interpretacji wyrażenia
              warunkowego wyrażenie. Wyrażenia złożone są ze składowych  (pri‐
              maries)   opisanych  poniżej  w  opcji  WYRAŻENIA WARUNKOWE.  Na
              słowach pomiędzy [[ a ]]  nie  są  wykonywane  rozwinięcia  nazw
              plików  ani podział na słowa; są natomiast wykonywane: interpre‐
              tacja tyld, parametrów i zmiennych, interpretacja wyrażeń  aryt‐
              metycznych,  podstawianie  wyników poleceń, podstawianie wyników
              procesów i usunięcia cytowań. Operatory warunkowe, takie jak -f,
              nie  mogą  być  cytowane,  jeśli  mają  zostać  rozpoznane  jako
              składowe.

              Operatory < i  >,  gdy  są  używane  z  [[,  sortują  zgodnie  z
              porządkiem   leksykograficznym,  używając  bieżącego  ustawienia
              locale.

       Proszę zapoznać się z wbudowanym poleceniem  test  (rozdział  WBUDOWANE
       POLECENIA  POWŁOKI  poniżej),  aby  dowiedzieć  się  jak obsługiwane są
       parametry (np. sytuacja gdy ich nie podano).

       Jeśli używane są operatory == i !=, to łańcuch po prawej stronie opera‐
       tora  jest  wzorcem  i  jest  dopasowany  zgodnie  z  opisanymi poniżej
       regułami Dopasowania wzorca. Jeśli włączono opcję powłoki  nocasematch,
       to  przy dopasowaniu ignorowana jest wielkość liter. Zwracaną wartością
       jest 0 gdy łańcuch pasuje (==) lub nie pasuje (!=)  i  1  w  przeciwnym
       wypadku.  Każda  część  wzorca może być cytowana, aby wymusić jej dopa‐
       sowanie jako łańcuch.

       Dostępny jest dodatkowy operator dwuargumentowy =~, który  ma  ten  sam
       priorytet  co  ==  i  !=. Gdy zostanie użyty, łańcuch po prawej stronie
       operatora jest rozszerzonym wyrażeniem regularnym  i  jest  odpowiednio
       dopasowywany  (jak  przez  regex(3)).  Zwracaną  wartością  jest  0 gdy
       łańcuch pasuje do wzorca i 1 w przeciwnym wypadku. Jeśli wyrażenie reg‐
       ularne ma nieprawidłową składnię, zwracane jest 2. Jeśli włączono opcję
       powłoki nocasematch,  to  przy  dopasowaniu  ignorowana  jest  wielkość
       liter.  Każda  część  wzorca  może  być cytowana, aby wymusić jej dopa‐
       sowanie jako łańcuch. Podłańcuch dopasowany przez podwyrażenie ujęte  w
       nawiasy  wewnątrz  wyrażenia  regularnego,  jest  zapisywany w zmiennej
       tablicowej BASH_REMATCH. Element BASH_REMATCH z indeksem 0 jest częścią
       łańcucha pasującą do całego wyrażenia regularnego. Element tej zmiennej
       z indeksem n jest częścią  łańcucha  pasującą  do  n-tego  podwyrażenia
       ujętego w nawiasy.

       Wyrażenia   można   łączyć   przy   pomocy   następujących  operatorów,
       wymienionych w kolejności malejącego priorytetu:

              ( wyrażenie )
                     Zwraca wartość wyrażenia. Może  służyć  do  unieważnienia
                     zwykłej kolejności operatorów.
              ! wyrażenie
                     Prawda jeżeli wyrażenie jest fałszywe.
              wyrażenie1 && wyrażenie2
                     Prawda  jeśli  zarówno  wyrażenie1  jak  i  wyrażenie2 są
                     prawdziwe.
              wyrażenie1 || wyrażenie2
                     Prawda jeśli choć jedno spośród wyrażenie1 lub wyrażenie2
                     jest prawdziwe.

              Operatory  &&  i  ||  nie  wykonują  wyrażenia2  jeżeli  wartość
              wyrażenia1  wystarcza  do  określenia  wartości,  jaka  zostanie
              zwrócona przez całe wyrażenie warunkowe.

       for nazwa [ [ in [ słowo ... ] ] ; ] do lista ; done
              Interpretowane  są  słowa  następujące po in, tworząc listę ele‐
              mentów.  Zmiennej nazwa nadawana jest  kolejno  wartość  każdego
              elementu  tej listy i każdorazowo wykonywana jest lista poleceń.
              Jeżeli pominięto in słowo, to polecenie for  wykonuje  listę  po
              jednym  razie  dla  każdego  ustawionego  parametru  pozycyjnego
              (zobacz  PARAMETRY   poniżej).    Zwracanym   kodem   jest   kod
              zakończenia  ostatniego  wykonanego  polecenia.  Jeśli interpre‐
              tacja elementów następujących po in daje w wyniku  pustą  listę,
              to nie są wykonywane żadne polecenia i zwracany jest kod 0.

       for (( wyr1 ; wyr2 ; wyr3 )) ; do lista ; done
              Na  początku obliczane jest wyrażenie arytmetyczne wyr1, zgodnie
              z zasadami opisanymi  poniżej  w  OBLICZANIE  WYRAŻEŃ  ARYTMETY‐
              CZNYCH.   Następnie  wielokrotnie  obliczane  jest  wyr2,  aż do
              osiągnięcia przez nie wartości zero.  Każdorazowo gdy  obliczone
              wyr2  jest  niezerowe,  wykonywana  jest  lista i obliczane jest
              wyrażenie arytmetyczne wyr3.  Jeśli pominięto któreś z  wyrażeń,
              to   zachowuje   się  ono  tak,  jakby  przyjmowało  wartość  1.
              Zwracanym  kodem  jest  kod  zakończenia  ostatniego  wykonanego
              polecenia   listy,   lub  fałsz  jeśli  któreś  z  wyrażeń  jest
              niepoprawne.

       select nazwa [ in słowo ] ; do lista ; done
              Interpretowana jest lista  słów  następujących  po  in,  tworząc
              listę  elementów.  Zestaw zinterpretowanych słów wypisywany jest
              na standardowym wyjściu, każde poprzedzone liczbą kolejną. Jeśli
              pominięto in słowo, to wypisywane są parametry pozycyjne (zobacz
              PARAMETRY poniżej).  Następnie wyświetlany jest znak zachęty PS3
              i  czytany  jest  wiersz ze standardowego wejścia. Jeżeli wiersz
              składa się z liczby odpowiadającej jednemu z wyświetlonych słów,
              to  zmiennej  nazwa przypisywana jest wartość tego słowa.  Jeśli
              wiersz jest pusty, słowa  i  zachęta  wyświetlane  są  ponownie.
              Jeżeli  odczytano  EOF,  to  polecenie  kończy pracę. Każda inna
              wartość powoduje, że nazwie zostanie przypisany  łańcuch  pusty.
              Odczytany  wiersz  zachowywany  jest  w  zmiennej  REPLY.  lista
              wykonywana jest po każdym wyborze, dopóki nie zostanie  wykonane
              polecenie  break.  Kodem zakończenia select jest kod zakończenia
              ostatniego wykonanego polecenia listy lub zero jeśli  nie  wyko‐
              nano żadnych poleceń.

       case słowo in [ [(] wzorzec [ | wzorzec ] ... ) lista ;; ] ... esac
              Polecenie  case  najpierw interpretuje słowo i próbuje dopasować
              uzyskany wynik każdego z wzorców po kolei, posługując  się  tymi
              samymi   regułami   dopasowywania,   co   dla   rozwijania  nazw
              ścieżkowych (zobacz Rozwijanie nazw ścieżkowych poniżej).  Słowo
              jest interpretowane zgodnie z interpretacją tyldy, podstawianiem
              parametrów i zmiennych,  podstawianiem  wyrażeń  arytmetycznych,
              wyników  poleceń  i  wyników  procesów  oraz usunięciem cytowań.
              Każdy sprawdzany wzorzec podlega interpretacji tyldy, podstawia‐
              niu parametrów i zmiennych, podstawianiu wyrażeń arytmetycznych,
              wyników poleceń i wyników procesów. Jeśli włączono opcję powłoki
              nocasematch,  to dopasowanie jest przeprowadzane bez uwzględnia‐
              nia  wielkości  liter.  Gdy  znalezione  zostanie   dopasowanie,
              wykonywana  jest  odpowiadająca  mu lista. Jeśli użyto operatora
              ;;,  nie  przeprowadza  się  próby  kolejnego   dopasowania   po
              znalezieniu pierwszego pasującego wzorca. Użycie ;& w miejsce ;;
              powoduje  kontynuowanie  wykonywania  z   powiązaną   listą,   z
              następnym  zestawem  wzorców.  Jeśli  użyje się w zamian ;;&, to
              powłoka sprawdza następną listę wzorców twierdzenia (jeśli  ist‐
              nieje)  i  wykonuje każdą powiązaną listę w przypadku pomyślnego
              dopasowania. Jeżeli  żaden  ze  wzorców  nie  pasuje,  to  kodem
              zakończenia  jest  zero. W przeciwnym razie jest on równy kodowi
              zakończenia ostatniego z wykonanych poleceń listy.

       if lista; then lista; [ elif lista; then lista; ] ... [ else  lista;  ]
       fi
              Wykonywana  jest  lista  występująca  po  if.   Jeżeli  jej  kod
              zakończenia jest zerowy, to wykonywana jest lista klauzuli then.
              W  przeciwnym  wypadku,  wykonywana  jest  lista każdego elif po
              kolei; jeśli kod zakończenia którejś  wynosi  0,  to  wykonywana
              jest  lista  then i polecenie jest kończone. Jeżeli nie wystąpił
              żaden  z  powyższych  przypadków,  to  wykonywana   jest   lista
              występująca  po  klauzuli  else,  jeśli  takowa  istnieje. Kodem
              zakończenia jest kod ostatniego wykonanego polecenia  listy  lub
              zero jeśli żaden z warunków nie okazał się prawdziwy.

       while lista-1; do lista-2; done
       until lista-1; do lista-2; done
              Polecenie  while  wykonuje listę lista-2 w sposób ciągły dopóty,
              dopóki  ostatnie  polecenie  listy  lista-1  nie   zwróci   kodu
              zakończenia  równego  zero.  Polecenie  until działa podobnie do
              polecenia while, a jedyną różnicą jest to, że  test  jest  zane‐
              gowany  - lista-2 jest wykonywana tak długo, aż ostatnie polece‐
              nie listy-1 nie zwróci kodu zakończenia  różnego  od  zera.  Kod
              wyjścia  poleceń while i until jest kodem zakończenia ostatniego
              polecenia wykonanego z listy-2 lub zerem, jeśli żadne z nich nie
              zostało wykonane.

   Współprocesy (koprocesy)
       Współproces  jest  poleceniem  powłoki poprzedzonym słowem zastrzeżonym
       coproc. Współproces jest wykonywany w podpowłoce  w  sposób  asynchron‐
       iczny,  jeśli  polecenie  zostało zakończone operatorem kontrolnym &, z
       ustawionym  dwustronnym  potokiem  pomiędzy  wykonującą  go  powłoką  a
       współprocesem.

       Format współprocesu jest następujący:

              coproc [NAZWA] polecenie [przekierowania]

       W  ten  sposób tworzy jest współproces o nazwie NAZWA. Jeśli nie podano
       NAZWY, domyślną jest  COPROC.  NAZWA  nie  może  zostać  podana,  jeśli
       polecenie jest poleceniem prostym (patrz powyżej), w przeciwnym wypadku
       jest  interpretowane  jako  pierwsze  słowo  polecenia  prostego.   Gdy
       współproces  jest  wykonywany,  powłoka tworzy zmienną tablicową (patrz
       Tablice poniżej) o nazwie NAZWA w kontekście wykonywanej powłoki. Stan‐
       dardowe  wyjście polecenia jest połączone potokiem z deskryptorem pliku
       wykonywanej powłoki, a ten jest  przypisany  do  NAZWA[0].  Standardowe
       wejście  polecenia jest połączone potokiem z deskryptorem pliku wykony‐
       wanej powłoki, a ten jest przypisany do NAZWA[1]. Ten potok jest ustaw‐
       iany  przed  wszystkimi  przekierowaniami  podanymi z poleceniem (patrz
       PRZEKIEROWANIE poniżej). Deskryptory pliku mogą zostać użyte jako argu‐
       menty  do  poleceń powłoki i przekierowań, korzystając ze standardowych
       interpretacji słów. Identyfikator procesu powłoki utworzonej do wykona‐
       nia  współprocesu  jest  dostępny  jako  wartość zmiennej NAZWA_PID. Do
       czekania na zakończenie współprocesu można użyć  wbudowanego  polecenia
       wait.

       Kodem zakończenia współprocesu jest kod wyjścia polecenia.

   Definiowanie funkcji powłoki
       Funkcja  powłoki  jest  obiektem  wywoływanym  podobnie  jako polecenie
       proste i wykonującym polecenie  złożone  z  nowym  zestawem  parametrów
       pozycyjnych. Funkcje powłoki deklaruje się w następujący sposób:

       nazwa () polecenie-złożone [przekierowanie]
       function nazwa [()] polecenie-złożone [przekierowanie]
              W ten sposób definiowana jest funkcja o nazwie nazwa. Słowo zas‐
              trzeżone function jest opcjonalne. Jeśli je podano,  to  nawiasy
              są  opcjonalne.  Ciałem  funkcji  jest polecenie złożone polece‐
              nie-złożone (patrz Polecenia złożone  powyżej).  Polecenie  jest
              zwykle  listą  poleceń  objętych nawiasami klamrowymi { i }, ale
              może to być dowolne z poleceń  wypisanych  powyżej  w  rozdziale
              Polecenia  złożone.  Polecenie-złożone  jest  wykonywane ilekroć
              podano  nazwę   jako   nazwę   polecenia   prostego.   Wszystkie
              przekierowania  (patrz  PRZEKIEROWANIE  poniżej)  podane podczas
              definiowania funkcji są wykonywane gdy funkcja jest  wykonywana.
              Kod zakończenia definicji funkcji wynosi zero, chyba że wystąpił
              błąd składni, lub istnieje już funkcja tylko do  odczytu  o  tej
              samej  nazwie.  Podczas  wykonywania, kodem wyjścia funkcji jest
              kod zakończenia ostatniego polecenia  wykonanego  w  jej  ciele.
              Patrz również FUNKCJE poniżej.

KOMENTARZE
       W  powłoce  nie-interaktywnej  lub  w  powłoce  interaktywnej, w której
       włączono opcję interactive_comments do opcji wbudowanych shopt  (zobacz
       WBUDOWANE  POLECENIA POWŁOKI poniżej) słowo rozpoczynające się od znaku
       # powoduje, że słowo to i wszystkie pozostałe znaki w tym wierszu  będą
       ignorowane.  Powłoka  interaktywna bez włączonej opcji interactive_com‐
       ments  nie  pozwala  na  komentarze.  Opcja  interactive_comments  jest
       domyślnie włączona w powłokach interaktywnych.

CYTOWANIE
       Cytowanie  służy  do usuwania specjalnego znaczenia dla powłoki pewnych
       znaków lub słów. Cytowanie można  stosować  do  wyłączania  specjalnego
       traktowania  znaków  specjalnych,  zapobiegania rozpoznawaniu słów zas‐
       trzeżonych jako takich oraz do zapobiegania podstawianiu parametrów.

       Każdy z metaznaków podanych powyżej w DEFINICJACH posiada  dla  powłoki
       specjalne  znaczenie  i  musi  być  cytowany,  jeśli ma oznaczać samego
       siebie.

       Gdy używane są funkcje interpretacji historii poleceń (patrz  INTERPRE‐
       TACJA  HISTORII),  znak  interpretacji  historii,  zwykle  !,  musi być
       cytowany, jeśli chce się uniknąć interpretacji historii.

       Istnieją trzy mechanizmy cytowania: znak specjalny (escape  character),
       apostrofy (pojedyncze cudzysłowy) i cudzysłowy zwykłe (podwójne).

       Niecytowany  odwrotny  ukośnik  (\) jest znakiem specjalnym.  Chroni on
       przed interpretacją dosłowną wartość  następującego  po  nim  znaku,  z
       wyjątkiem  <nowejlinii>.  Jeśli  pojawi  się  para  \<nowalinia>  a sam
       odwrotny ukośnik nie jest cytowany, to traktowana jest ona jak kontynu‐
       acja  wiersza  (to  znaczy,  usuwana jest ze strumienia wejściowego i w
       efekcie ignorowana).

       Ujęcie znaków w apostrofy chroni  dosłowne  wartości  każdego  z  nich.
       Apostrof  nie może pojawić się pomiędzy innymi apostrofami, nawet jeśli
       jest poprzedzony odwrotnym ukośnikiem.

       Ujęcie znaków w cudzysłowy chroni dosłowne wartości każdego z nich,  za
       wyjątkiem  $,  ` i \ oraz, gdy włączone jest dopełnianie z historii, !.
       Znaki $ i ` zachowują swe  specjalne  znaczenie  wewnątrz  cudzysłowów.
       Odwrotny  ukośnik zachowuje specjalne znaczenie tylko, gdy występuje po
       nim jeden z poniższych znaków: $, `, ", \ lub  <nowalinia>.   Cudzysłów
       może  być cytowany wewnątrz cudzysłowów przez poprzedzenie go odwrotnym
       ukośnikiem. Jeśli dopełnianie z historii jest włączone, to będzie wyko‐
       nane,  chyba  że  znak ! jest ujęty w cudzysłowy lub cytowany odwrotnym
       ukośnikiem. Odwrotny ukośnik poprzedzający ! nie jest usuwany.

       Parametry specjalne * i @ posiadają specjalne znaczenie  wewnątrz  cud‐
       zysłowów (zobacz PARAMETRY poniżej).

       Słowa  postaci  $'łańcuch' traktowane są specjalnie. Słowo takie inter‐
       pretowane jako łańcuch, w którym znaki poprzedzone odwrotnym ukośnikiem
       zastępowane są według standardu ANSI C. Sekwencje specjalne z odwrotnym
       ukośnikiem, jeśli występują, dekodowane są następująco:
              \a     alarm (dzwonek)
              \b     backspace
              \e
              \E     znak escape
              \f     znak wysuwu strony (form feed)
              \n     znak nowego wiersza (new line)
              \r     powrót karetki (carriage return)
              \t     tabulacja pozioma (horizontal tab)
              \v     tabulacja pionowa (vertical tab)
              \\     odwrotny ukośnik (backslash)
              \'     apostrof
              \"     cudzysłów
              \nnn   ośmiobitowy znak, którego wartością jest ósemkowa  liczba
                     nnn (jedna do trzech cyfr)
              \xHH   ośmiobitowy  znak,  którego  wartością  jest szesnastkowa
                     liczba nnn (jedna lub dwie cyfry szesnastkowe)
              \uHHHH znak Unicode (ISO/IEC  10646)  o  wartości  szesnastkowej
                     HHHH (jedna do czterech cyfr szesnastkowych)
              \UHHHHHHHH
                     znak  Unicode  (ISO/IEC  10646)  o wartości szesnastkowej
                     HHHHHHHH (jedna do ośmiu cyfr szesnastkowych)
              \cx    znak kontrolny x

       Przetłumaczony wynik jest pojedynczo cytowany, tak jakby nie było znaku
       dolara.

       Ujęty  w  cudzysłowy  łańcuch  poprzedzony  znakiem dolara ($"łańcuch")
       spowoduje, że łańcuch  zostanie  zinterpretowany  zgodnie  z  bieżącymi
       ustawieniami  regionalnymi  (locale).  Jeśli  ustawione są one na C lub
       POSIX, to znak dolara jest ignorowany. Jeżeli łańcuch jest tłumaczony i
       zamieniany, to zastąpienie jest podwójnie cytowane.

PARAMETRY
       Parametr  jest  elementem  przechowującym  wartości. Może on być nazwą,
       liczbą lub jednym ze  znaków  specjalnych  podanych  poniżej  w  sekcji
       Parametry   specjalne.   Dla  celów  powłoki  zmienna  jest  parametrem
       oznaczanym przez nazwę.  Zmienna posiada  wartość  i  zero  lub  więcej
       atrybutów.   Wartość  atrybutom przypisuje się za pomocą polecenia wbu‐
       dowanego declare (zobacz opis tego polecenia  poniżej,  w  sekcji  WBU‐
       DOWANE POLECENIA POWŁOKI).

       Parametr jest ustawiony jeśli przypisano mu wartość. Łańcuch pusty jest
       poprawną wartością. Po ustawieniu zmiennej, może być  ona  unieważniona
       wyłącznie przez użycie wbudowanego polecenia unset (zobacz poniżej WBU‐
       DOWANE POLECENIA POWŁOKI ).

       Do zmiennej można wykonać przypisanie przy pomocy instrukcji postaci

              nazwa=[wartość]

       Jeżeli nie podano  wartości,  to  zmiennej  przypisywany  jest  łańcuch
       pusty. Wszystkie wartości przechodzą przez interpretację tyld, podstaw‐
       ianie  parametrów,  interpretację   zmiennych,   podstawianie   wyników
       poleceń,   interpretację  wyrażeń  arytmetycznych  i  usuwanie  cytowań
       (zobacz poniżej INTERPRETACJA). Jeżeli  zmienna  ma  ustawiony  atrybut
       integer  (całkowita),  to  wartość podlega interpretacjom wyrażeń aryt‐
       metycznych,  nawet  jeśli  nie  użyto  interpretacji  $((...)).  Zobacz
       poniżej Interpretacja wyrażeń arytmetycznych. Nie jest wykonywane dzie‐
       lenie na słowa, z wyjątkiem "$@", jak wyjaśniono to  poniżej  w  sekcji
       Parametry  specjalne.   Nie  jest  wykonywane  rozwijanie  nazw plików.
       Instrukcje przypisania mogą się też  pojawiać  jako  argumenty  poleceń
       wbudowanych alias, declare, typeset, export, readonly i local.

       W  kontekście,  w  którym  instrukcja przypisania przypisuje wartość do
       zmiennej powłoki lub do tablicy indeksowanej, operator += może posłużyć
       do dołączenia lub dodania do poprzedniej wartości zmiennej. Gdy += jest
       stosowane do zmiennej z  ustawionym  atrybutem  liczby  całkowitej,  to
       wartość  jest  obliczana  jako  wyrażenie  arytmetyczne  i  dodawana do
       bieżącej wartości zmiennej, która również jest obliczana. Gdy  +=  jest
       stosowane  do zmiennej tablicowej używając przypisania złożonego (patrz
       Tablice poniżej), wartość  zmiennej  nie  jest  niszczona  (jak  to  ma
       miejsce  przy użyciu =), a nowe wartości są dołączane do tablicy poczy‐
       nając od indeksu większego o jeden on maksymalnego indeksu  tablicy  (w
       przypadku  tablic  indeksowanych) lub jest dodawana jako dodatkowa para
       klucz-wartość (w przypadku tablic asocjacyjnych). Gdy += jest stosowane
       do zmiennej łańcuch-wartość, to wartość jest interpretowana i dołączana
       do wartości zmiennej.

   Parametry pozycyjne
       Parametr pozycyjny to parametr określany cyfrą lub cyframi, innymi  niż
       pojedyncza  cyfra  0.  Parametrom pozycyjnym nadawane są wartości argu‐
       mentów powłoki (w czasie jej wywołania). Wartości te mogą być  ponownie
       nadawane  przy  pomocy  wbudowanego polecenia set.  Do parametrów pozy‐
       cyjnych nie można wykonać przypisania przy pomocy instrukcji  przypisa‐
       nia.  Parametry pozycyjne są tymczasowo zastępowane podczas wykonywania
       funkcji powłoki (zobacz poniżej FUNKCJE).

       Jeżeli interpretowany jest  parametr  pozycyjny  określany  więcej  niż
       jedną  cyfrą,  to  musi  być  ujęty w nawiasy (zobacz poniżej INTERPRE‐
       TACJA).

   Parametry specjalne
       Powłoka kilka parametrów traktuje specjalnie. Do parametrów tych  można
       się wyłącznie odwoływać; nie jest dozwolone przypisywanie im wartości.
       *      Interpretowane jest jako parametry pozycyjne, począwszy od pier‐
              wszego. Gdy interpretacja pojawia się wewnątrz  cudzysłowów,  to
              parametr   ten  interpretowany  jest  jako  pojedyncze  słowo  z
              wartościami każdego z parametrów rozdzielonymi pierwszym znakiem
              zmiennej  specjalnej  IFS.   To  znaczy,  "$*"  jest  równoważne
              "$1c$2c...", gdzie c jest pierwszym  znakiem  wartości  zmiennej
              IFS.   Jeżeli IFS nie jest ustawione, to parametry oddzielane są
              spacjami.  Jeśli IFS jest łańcuchem pustym, to parametry  są  ze
              sobą połączone bez rozdzielających je separatorów.
       @      Interpretowane  jako  parametry  pozycyjne,  począwszy  od pier‐
              wszego. Gdy interpretacja pojawia się wewnątrz  cudzysłowów,  to
              każdy  parametr  interpretowany  jest  jako  odrębne  słowo.  To
              znaczy, "$@" jest równoważne "$1" "$2" ... Jeśli wewnątrz  słowa
              zachodzi interpretacja (ujęta w cudzysłowy), to pierwszy zinter‐
              pretowany parametr jest łączony z początkiem oryginalnego słowa,
              a  interpretacja ostatniego parametru jest łączona z końcem ory‐
              ginalnego słowa. Jeśli nie ma  żadnych  parametrów  pozycyjnych,
              "$@" i $@ interpretowane są jako nic (tj. są usuwane).
       #      Interpretowane   jako   liczba  parametrów  pozycyjnych,  podana
              dziesiętnie.
       ?      Interpretowane jako kod zakończenia ostatnio  wykonanego  potoku
              pierwszoplanowego.
       -      Interpretowane  jako  bieżące  flagi  opcji, takie jakie zostały
              podane podczas  wywołania,  ustawione  przy  pomocy  wbudowanego
              polecenia  set  lub  ustawione przez samą powłokę (tak jak opcja
              -i).
       $      Interpretowany jest jako identyfikator procesu powłoki.  W  pod‐
              powłoce   (),  interpretowany  jest  jako  ID  procesu  bieżącej
              powłoki, nie zaś podpowłoki.
       !      Interpretowany jako ID procesu ostatnio  wykonywanego  polecenia
              tła (polecenia asynchronicznego).
       0      Interpretowany jako nazwa powłoki lub skryptu powłoki. Ustawiane
              jest to na etapie inicjowania powłoki.  Jeżeli  bash  wywoływany
              został  z  plikiem  poleceń,  to $0 ustawiane jest na nazwę tego
              pliku. Jeśli bash został uruchomiony z  opcją  -c,  to  $0  jest
              ustawiane  na  pierwszy  argument  po  łańcuchu,  jaki ma zostać
              wywołany, jeśli taki występuje. W przeciwnym wypadku,  ustawiany
              jest  na  nazwę pliku użytą do wywołania bash, jaką podaje argu‐
              ment zerowy.
       _      Podczas uruchamiania powłoki,  ustawiany  na  bezwzględną  nazwę
              powłoki  lub  wykonywanego skryptu powłoki przekazanego w liście
              argumentów.  Następnie, interpretowany jest jako  ostatni  argu‐
              ment   poprzedniego   polecenia,  po  interpretacji.   Ustawiany
              również na pełną nazwę  pliku  każdego  polecenia  wykonanego  i
              umieszczonego  w  środowisku  eksportowanym  do  tego polecenia.
              Podczas sprawdzania poczty parametr ten przechowuje nazwę  aktu‐
              alnie sprawdzanego pliku poczty.

   Zmienne powłoki
       Powłoka ustawia następujące zmienne:

       BASH   Interpretowane  jako  pełna  nazwa pliku użyta do wywołania tego
              przebiegu bash.
       BASHOPTS
              Oddzielana dwukropkiem lista  włączonych  opcji  powłoki.  Każde
              słowo  na  liście  jest  poprawnym  argumentem  do opcji -s wbu‐
              dowanego  polecenia  shopt  (patrz   WBUDOWANE POLECENIA POWŁOKI
              poniżej).  Opcje  pojawiające  się  w BASHOPTS są tymi, które są
              raportowane jako włączone (on) przez  shopt.  Jeśli  ta  zmienna
              występuje w środowisku podczas uruchamiania bash, to każda opcja
              powłoki z listy będzie włączona przed odczytaniem  plików  star‐
              towych. Ta zmienna jest tylko do odczytu.
       BASHPID
              Zmienna  przechowuje  identyfikator  bieżącego  procesu  bash. W
              określonych przypadkach, takich jak sytuacja, gdy podpowłoki nie
              wymagają ponownej inicjalizacji bash, różni się od $$.
       BASH_ALIASES
              Zmienna   tablicy   asocjacyjnej,   której   wpisy   odpowiadają
              wewnętrznej liście aliasów zarządzanych przez wbudowane  polece‐
              nie  alias. Elementy dodawane do tablicy pojawiają się na liście
              aliasów, usunięcie elementów tablicy powoduje usunięcie  aliasów
              z listy aliasów.
       BASH_ARGC
              Zmienna  tablicowa,  której  wartościami  są  liczby  parametrów
              każdej ramki w bieżącym stosie wywołania bash. Liczba parametrów
              bieżącego  podprogramu (funkcji powłoki lub skryptu wykonywanego
              przez . lub source) znajduje się na górze stosu. Gdy  podprogram
              jest  wykonywany,  liczba przekazanych parametrów jest przypisy‐
              wana do BASH_ARGC. Powłoka ustawia BASH_ARGC wyłącznie w  rozsz‐
              erzonym  trybie  debugowania  (patrz  opis  opcji  extdebug wbu‐
              dowanego polecenie shopt poniżej).
       BASH_ARGV
              Zmienna  tablicowa  zawierająca  wszystkie  parametry  bieżącego
              stosu wywołania bash. Ostatni parametr ostatniego wywołania pod‐
              programu jest umieszczony na wierzchołku stosu, natomiast  pier‐
              wszy  parametr  pierwszego  wywołania na spodzie. Gdy podprogram
              jest wykonywany, liczba przekazanych parametrów  jest  przypisy‐
              wana  do BASH_ARGV. Powłoka ustawia BASH_ARGV wyłącznie w rozsz‐
              erzonym trybie  debugowania  (patrz  opis  opcji  extdebug  wbu‐
              dowanego polecenie shopt poniżej).
       BASH_CMDS
              Zmienna   tablicy   asocjacyjnej,   której   wpisy   odpowiadają
              wewnętrznej liście skrótów poleceń, zarządzanej przez  wbudowane
              polecenie  hash.  Elementy  dodawane do tablicy pojawiają się na
              liście skrótów, usunięcie elementów tablicy  powoduje  usunięcie
              ich z tablicy skrótów.
       BASH_COMMAND
              Aktualnie  wykonywane  polecenie  lub  polecenie przeznaczone do
              wykonania, chyba że powłoka wykonuje aktualnie polecenie  będące
              wynikiem zadziałania pułapki - wówczas jest to polecenie wykony‐
              wane w czasie zadziałania pułapki.
       BASH_EXECUTION_STRING
              Argument polecenia do opcji wywołania -c.
       BASH_LINENO
              Zmienna tablicowa, której wartościami są numery  wierszy  plików
              źródłowych,  w  których przywołano każdy odpowiednik ze zmiennej
              FUNCNAME.  ${BASH_LINENO[$i]}  jest  numerem  wiersza  w   pliku
              źródłowym   (${BASH_SOURCE[$i+1]}),   gdzie  przywołano  ${FUNC‐
              NAME[$i]} (lub ${BASH_LINENO[$i-1]}, jeśli odnosi się  do  innej
              funkcji  powłoki).  Proszę użyć LINENO, aby pobrać bieżący numer
              wiersza.
       BASH_REMATCH
              Zmienna tablicowa, której wartości  są  przypisywane  operatorem
              dwuargumentowym =~ do polecenia warunkowego [[. Element o indek‐
              sie 0 jest częścią łańcucha pasującego do całego wyrażenia regu‐
              larnego.  Element  o indeksie n jest częścią łańcucha pasującego
              do n-tego podwyrażenia ujętego w nawiasy. Zmienna jest tylko  do
              odczytu.
       BASH_SOURCE
              Zmienna   tablicowa,   której   wartościami   są   nazwy  plików
              źródłowych, w których zdefiniowano odpowiadające  nazwy  funkcji
              powłoki  w zmiennej tablicowej FUNCNAME. Funkcja powłoki ${FUNC‐
              NAME[$i]}  jest  zdefiniowana  w  pliku   ${BASH_SOURCE[$i]}   i
              wywoływana z ${BASH_SOURCE[$i+1]}..
       BASH_SUBSHELL
              Zwiększana  o  jeden,  przy  każdym  utworzeniu  podpowłoki  lub
              środowiska podpowłoki. Wartością początkową jest 0.
       BASH_VERSINFO
              Zmienna tablicowa tylko do odczytu,  której  elementy  zawierają
              informacje  o  wersji  uruchomionego  bash.  Wartości przypisane
              elementom tablicy są następujące:
              BASH_VERSINFO[0]        Główny numer wersji, wydanie (release).
              BASH_VERSINFO[1]        Poboczny numer wersji (version).
              BASH_VERSINFO[2]        Poziom łat (patch level).
              BASH_VERSINFO[3]        Wersja kompilatu (build version).
              BASH_VERSINFO[4]        Status wydania (np. beta1).
              BASH_VERSINFO[5]        Wartość MACHTYPE.
       BASH_VERSION
              Interpretowane jako łańcuch opisujący wersję uruchomionego bash.
       COMP_CWORD
              Indeks w ${COMP_WORDS} słowa zawierającego bieżącą pozycję  kur‐
              sora.   Zmienna  ta  jest dostępna wyłącznie w funkcjach powłoki
              wywołanych przez  usługi  programowalnego  uzupełniania  (zobacz
              poniżej Programowalne uzupełnianie).
       COMP_KEY
              Klawisz  (lub  ostatni  klawisz  w  sekwencji klawiszy) użyty do
              wywołania bieżącej funkcji uzupełniania.
       COMP_LINE
              Bieżący wiersz poleceń. Ta zmienna jest dostępna tylko w  funkc‐
              jach  powłoki  i  poleceniach  zewnętrznych  wywoływanych  przez
              usługi  programowalnego  uzupełniania   (zobacz   poniżej   Pro‐
              gramowalne uzupełnianie).
       COMP_POINT
              Indeks  bieżącej  pozycji  kursora  względem  początku bieżącego
              polecenia.  Jeżeli kursor jest na końcu bieżącego polecenia,  to
              wartość  tej zmiennej jest równa ${#COMP_LINE}.  Ta zmienna jest
              dostępna tylko w funkcjach powłoki  i  poleceniach  zewnętrznych
              wywoływanych  przez  usługi programowalnego uzupełniania (zobacz
              poniżej Programowalne uzupełnianie).
       COMP_TYPE
              Ustawiana   na   wartość    całkowitą    odpowiadającą    typowi
              uzupełnienia,  którego  próbę  przeprowadzono, które spowodowało
              wywołanie funkcji uzupełnienia: TAB, do normalnego uzupełnienia,
              ?,  do wypisywania uzupełnień po udanej tabulacji, !, do wypisy‐
              wania alternatyw częściowego uzupełnienia słowa, @, do wypisania
              uzupełnień,  jeśli  słowo  nie  zostało  zmodyfikowane lub %, do
              uzupełnienia menu. Zmienna ta jest dostępna  tylko  w  funkcjach
              powłoki  i  zewnętrznych  poleceniach wywołanych przez narzędzia
              programowalnego  uzupełnienia  powłoki   (patrz   poniżej   Pro‐
              gramowalne uzupełnienie).
       COMP_WORDBREAKS
              Zestaw  znaków traktowanych przez bibliotekę readline jako sepa‐
              ratory słów,  podczas  przeprowadzania  uzupełnień  słów.  Jeśli
              unieważniono    COMP_WORDBREAKS,    to   traci   swe   specjalne
              właściwości, nawet jeżeli jest następnie ponownie ustawiona.
       COMP_WORDS
              Zmienna tablicowa (patrz Tablice poniżej) składająca się z poje‐
              dynczych słów z aktualnego wiersza poleceń. Wiersz jest dzielony
              na słowa tak, jak podzieliłby go readline,  używając  COMP_WORD‐
              BREAKS,  zgodnie  z  opisem  powyżej.  Zmienna  ta jest dostępna
              wyłącznie w  funkcjach  powłoki  wywołanych  przez  usługi  pro‐
              gramowalnego    uzupełniania   (zobacz   poniżej   Programowalne
              uzupełnianie).
       COPROC Zmienna tablicowa (patrz poniżej Tablice) tworzona do  zatrzyma‐
              nia  deskryptorów  plików  z  wyjścia  lub  wejścia nienazwanych
              współprocesów (zobacz Współprocesy (koprocesy) powyżej).
       DIRSTACK
              Zmienna tablicowa (zobacz Tablice poniżej)  zawierająca  bieżącą
              zawartość  stosu  katalogów.  Katalogi pojawiają się na stosie w
              kolejności,  w  jakiej  są  wyświetlane  przez  wbudowane  dirs.
              Przypisanie  do  elementów tej zmiennej tablicowej może posłużyć
              do zmiany katalogów już występujących na stosie, ale do  dodania
              i  usunięcia  katalogów  muszą być użyte wbudowane pushd i popd.
              Przypisanie wartości tej zmiennej nie zmieni bieżącego katalogu.
              Jeśli   DIRSTACK  jest  unieważnione,  to  traci  swe  specjalne
              właściwości, nawet jeżeli jest następnie ponownie ustawione.
       EUID   Interpretowane jako efektywny identyfikator bieżącego  użytkown‐
              ika, inicjowane przy uruchamianiu powłoki. Zmienna ta jest tylko
              do odczytu.
       FUNCNAME
              Zmienna tablicowa zawierająca nazwy wszystkich  funkcji  powłoki
              obecnych w stosie wywołań. Element z indeksem 0 jest nazwą aktu‐
              alnie wykonywanej funkcji powłoki.  Najniższy  element  (tzn.  z
              najwyższym  numerem  indeksu) to "main".  Zmienna istnieje tylko
              gdy wykonywana jest funkcja powłoki. Przypisania do FUNCNAME nie
              odnoszą  skutku  i  zwracają  kod  błędu.  Jeśli  FUNCNAME  jest
              unieważniona, to traci swe specjalne  właściwości,  nawet  jeśli
              jest następnie ponownie ustawiona.

              Zmienna  ta może zostać użyta razem z BASH_LINENO i BASH_SOURCE.
              Każdy element FUNCNAME  ma  swój  odpowiednik  w  BASH_LINENO  i
              BASH_SOURCE  opisujący  stos  wywołania.  Na  przykład,  ${FUNC‐
              NAME[$i]} została wywołana z pliku ${BASH_SOURCE[$i+1]} w  wier‐
              szu  o  numerze  ${BASH_LINENO[$i]}.  Wbudowane polecenie caller
              wyświetla bieżący stos wywołania używając tej informacji.
       GROUPS Zmienna tablicowa zawierająca listę grup, których członkiem jest
              bieżący  użytkownik.  Próby przypisywania wartości do GROUPS nie
              odnoszą  efektu  i  zwracają  kod  błędu.   Jeżeli  GROUPS  jest
              unieważnione,  to  traci swe specjalne właściwości, nawet jeżeli
              jest następnie ponownie ustawione.
       HISTCMD
              Licznik historii (indeks na liście historii  poleceń)  bieżącego
              polecenia.  Jeżeli HISTCMD jest unieważnione, to traci swe spec‐
              jalne właściwości, nawet jeżeli jest następnie  ponownie  ustaw‐
              ione.
       HOSTNAME
              Automatycznie ustawiane na nazwę aktualnego hosta.
       HOSTTYPE
              Automatycznie  ustawiane  na  łańcuch  unikalnie  opisujący  typ
              maszyny, na  której  jest  wykonywany  bash.   Wartość  domyślna
              zależy od systemu.
       LINENO Przy  każdym  odwołaniu do tego parametru powłoka zastępuje jego
              wartość liczbą dziesiętną reprezentującą aktualny kolejny  numer
              wiersza (poczynając od 1) skryptu lub funkcji. Nie zapewnia się,
              by wartość ta miała znaczenie poza skryptem bądź funkcją.  Jeśli
              LINENO  jest  unieważnione,  to traci swe specjalne właściwości,
              nawet jeżeli jest następnie ponownie ustawione.
       MACHTYPE
              Automatycznie ustawiane na łańcuch w pełni  opisujący  typ  sys‐
              temu,  na  którym  jest wykonywany bash, w standardowym formacie
              GNU cpu-firma-system.  Wartość domyślna zależy od systemu.
       MAPFILE
              Zmienna tablicowa (patrz Tablice poniżej) tworzona do  zatrzyma‐
              nia  tekstu odczytywanego przez wbudowane polecenie mapfile, gdy
              nie podano nazwy zmiennej.
       OLDPWD Poprzedni katalog roboczy ustawiony poleceniem cd.
       OPTARG Wartość ostatniego,  będącego  opcją,  argumentu  przetworzonego
              przez  wbudowane  polecenie  getopts  (zobacz  poniżej WBUDOWANE
              POLECENIA POWŁOKI).
       OPTIND Numer (indeks) następnego argumentu, jaki ma zostać przetworzony
              przez  wbudowane  polecenie  getopts  (zobacz  poniżej WBUDOWANE
              POLECENIA POWŁOKI).
       OSTYPE Automatycznie ustawiane na łańcuch opisujący system  operacyjny,
              w  którym jest wykonywany bash.  Wartość domyślna zależy od sys‐
              temu.
       PIPESTATUS
              Zmienna tablicowa  (zobacz  Tablice  poniżej)  zwierająca  listę
              kodów zakończenia z procesów w ostatnio wykonywanym potoku pier‐
              wszoplanowym (który może zawierać pojedyncze polecenie).
       PPID   Identyfikator procesu macierzystego  powłoki.  Zmienna  ta  jest
              tylko do odczytu.
       PWD    Bieżący katalog roboczy, ustawiony poleceniem cd.
       RANDOM Za każdym razem, gdy następuje odwołanie do tego parametru, gen‐
              erowana jest całkowita liczba losowa z zakresu od  0  do  32767.
              Sekwencję  liczb  losowych można zainicjować przypisując wartość
              do RANDOM.  Jeżeli RANDOM jest unieważniona, to traci swe  spec‐
              jalne  właściwości,  nawet jeżeli jest następnie ponownie ustaw‐
              iona.
       READLINE_LINE
              Zawartość bufora wiersza realine, do użycia z "bind  -x"  (patrz
              WBUDOWANE POLECENIA POWŁOKI poniżej).
       READLINE_POINT
              Pozycja  punktu  wprowadzania  w  buforze  wiersza  readline, do
              użycia z "bind -x" (patrz WBUDOWANE POLECENIA POWŁOKI poniżej).
       REPLY  Ustawiona na wiersz wejścia odczytany wbudowanym poleceniem read
              jeśli nie podano żadnych jego argumentów.
       SECONDS
              Każdorazowo, gdy występuje odwołanie do tego parametru, zwracana
              jest liczba sekund, jakie upłynęły od wywołania powłoki.  Jeżeli
              do  SECONDS  zostanie  przypisana  wartość,  to wartość zwracana
              przez kolejne odwołania  jest  równa  liczbie  sekund  od  czasu
              przypisania   plus  przypisana  wartość.   Jeżeli  SECONDS  jest
              unieważnione, to traci swe specjalne właściwości,  nawet  jeżeli
              jest następnie ponownie ustawione.
       SHELLOPTS
              Lista,  rozdzielonych  dwukropkami,  włączonych  opcji  powłoki.
              Każde słowo listy jest poprawnym argumentem opcji -o wbudowanego
              polecenia  set  (zobacz  WBUDOWANE  POLECENIA  POWŁOKI poniżej).
              Opcje pojawiające się w SHELLOPTS to te, które są zgłaszane jako
              włączone  (on)  przez  set  -o.   Jeśli  zmienna  ta  istnieje w
              środowisku podczas uruchamiania bash, to każda z  opcji  powłoki
              występująca  na  tej  liście  zostanie  włączona  przed odczytem
              jakichkolwiek plików  startowych.   Jest  to  zmienna  tylko  do
              odczytu.
       SHLVL  Inkrementowana   każdorazowo,   gdy   uruchamiane  jest  kolejne
              wystąpienie bash.
       UID    Interpretowane   jako   identyfikator   bieżącego   użytkownika,
              inicjowane  przy  uruchamianiu powłoki. Zmienna ta jest tylko do
              odczytu.

       Poniższe zmienne są używane przez  powłokę.  W  niektórych  przypadkach
       bash przypisuje im domyślne wartości; przypadki te są odnotowane niżej.

       BASH_ENV
              Jeżeli  parametr  ten  jest  ustawiony podczas wykonywania przez
              bash skryptu, to jego wartość  interpretowana  jest  jako  nazwa
              pliku  zawierającego  polecenia  do zainicjowania powłoki, jak w
              ~/.bashrc.  Wartość BASH_ENV podlega  interpretacji  parametrów,
              podstawianiu  wyników poleceń i interpretacjom wyrażeń arytmety‐
              cznych przed interpretacją jej jako nazwy pliku.   Zmienna  PATH
              nie  jest  używana do znalezienia pliku o powstałej w ten sposób
              nazwie.
       BASH_XTRACEFD
              Jeśli  ustawiono  liczbę  całkowitą   odpowiadającą   poprawnemu
              deskryptorowi  pliku, to bash zapisze wyjście stosu wygenerowane
              gdy set -x jest włączone do tego deskryptora  pliku.  Deskryptor
              pliku  jest  zamykany  gdy  BASH_XTRACEFD  jest usuwana lub przy
              przypisaniu nowej wartości. Usunięcie BASH_XTRACEFD  lub  przyp‐
              isanie jej łańcucha pustego powoduje wysłanie stosu na standard‐
              owe wyjście błędów. Proszę zauważyć, że ustawienie BASH_XTRACEFD
              na  2  (deskryptor  pliku wyjścia błędów), a następnie usunięcie
              jej spowoduje zamknięcie standardowego wyjścia błędów.
       CDPATH Ścieżka  wyszukiwania  dla  polecenia   cd.    Jest   to   lista
              rozdzielonych  dwukropkami  katalogów,  w  których powłoka szuka
              katalogów docelowych podanych przez polecenie  cd.   Przykładową
              wartością jest ".:~:/usr".
       COLUMNS
              Używana  przez  polecenie  wbudowane  select do wyznaczenia sze‐
              rokości  terminala  przy  wypisywaniu  list  wyboru.   Ustawiana
              automatycznie po otrzymaniu SIGWINCH.
       COMPREPLY
              Zmienna  tablicowa,  z  której  bash  czyta możliwe uzupełnienia
              tworzone  przez  funkcję  powłoki  wywołaną  przez  usługę  pro‐
              gramowalnego    uzupełniania   (zobacz   poniżej   Programowalne
              uzupełnianie).
       EMACS  Gdy  bash  znajdzie  opisywaną  zmienną  w  środowisku   podczas
              uruchamiania  powłoki,  z  wartością ustawioną na "t", to przyj‐
              muje, że powłoka działa  w  buforze  powłoki  Emacsa  i  wyłącza
              edycję wiersza.
       ENV    Podobnie  jak BASH_ENV; używana gdy powłoka jest wywołana w try‐
              bie POSIX.
       FCEDIT Domyślny edytor dla wbudowanego polecenia fc.
       FIGNORE
              Lista rozdzielonych  dwukropkami  przyrostków,  jakie  mają  być
              ignorowane  podczas  uzupełniania  nazw  plików (zobacz READLINE
              poniżej).  Nazwa pliku o przyrostku pasującym do jednej z  pozy‐
              cji  FIGNORE  wyłączana  jest  z listy dopasowanych nazw plików.
              Przykładową wartością jest ".o:~" (cytowanie jest niezbędne przy
              przypisywaniu do tej zmiennej wartości zawierającej tyldy).
       FUNCNEST
              Gdy  jest  ustawiona  na  wartość  numeryczną  większą  od zera,
              definiuje maksymalny  poziom  zagnieżdżenia  funkcji.  Wywołania
              funkcji  przekraczające  określony poziom będą powodowały przer‐
              wanie bieżącego polecenia.
       GLOBIGNORE
              Lista rozdzielonych  dwukropkami  wzorców  definiujących  zestaw
              nazw  plików,  jakie mają być ignorowane podczas rozwijania nazw
              plików.  Jeżeli plik  pasujący  do  wzorca  rozwijającego  nazwę
              ścieżkową  pasuje również do któregoś z wzorców w GLOBIGNORE, to
              jest on usuwany z listy dopasowanych.
       HISTCONTROL
              Lista rozdzielonych dwukropkami wartości,  określającymi  sposób
              zapisywania  w  liście historii. Jeżeli posiada wartość ignores‐
              pace, to wiersze rozpoczynające  się  od  znaku  spacji  nie  są
              wprowadzane do listy historii. Jeśli posiada wartość ignoredups,
              to wiersze  pasujące  do  ostatniego  wiersza  historii  nie  są
              wprowadzane.   Wartość  ignoreboth  łączy  obie  te  możliwości.
              Wartość  erasedups  powoduje  usunięcie  z  historii  wszystkich
              wcześniejszych   wierszy,   pasujących   do   bieżącego,   przed
              zapisaniem listy. Wszystkie wartości poza  wymienionymi  powyżej
              są  ignorowane.  Jeśli  zmienna  ta nie jest zdefiniowana lub ma
              wartość inną od powyższych,  to  wszystkie  wiersze  przeczytane
              przez  analizator  składni  zachowywane  są  w  liście historii,
              stosownie  do  wartości  HISTIGNORE.  Drugi  i  kolejne  wiersze
              złożonego  polecenia  wielowierszowego  nie  są  sprawdzane i są
              dodawane do historii bez względu na wartość HISTCONTROL.
       HISTFILE
              Nazwa pliku, w którym zachowywana jest historia poleceń  (zobacz
              HISTORIA  poniżej).   Wartością  domyślną  jest ~/.bash_history.
              Jeśli ustawienie tej zmiennej zostanie  skasowane,  to  historia
              poleceń nie będzie zachowana po zakończeniu pracy powłoki inter‐
              aktywnej.
       HISTFILESIZE
              Maksymalna liczba wierszy zawartych w  pliku  historii.  Podczas
              przypisywania  wartości  tej zmiennej, jeżeli jest to niezbędne,
              plik historii jest obcinany tak, by nie zawierał więcej wierszy.
              Domyślną  wartością jest 500.  Plik historii jest także obcinany
              do tego rozmiaru po zapisaniu go w czasie kończenia pracy  przez
              powłokę interaktywną.
       HISTIGNORE
              Lista  rozdzielonych  dwukropkami wzorców służących do decydowa‐
              nia, jakie wiersze poleceń powinny być zachowane w  liście  his‐
              torii.  Każdy  z wzorców zakotwiczony jest na początku wiersza i
              musi pasować do całego wiersza (nie jest dodawane żadne niejawne
              `*').  Każdy  z  wzorców  sprawdzany jest z bieżącym wierszem po
              wykonaniu  kontroli  określonych  przez   HISTCONTROL.    Oprócz
              zwykłych  znaków  dopasowywania wzorców używanych przez powłokę,
              `&' dopasowuje poprzedni  wiersz  historii.  Literał  `&'  można
              uzyskać  poprzedzając  go odwrotnym ukośnikiem; odwrotny ukośnik
              jest usuwany przed próbą dopasowania. Druga  i  kolejne  wiersze
              złożonego  polecenia  wielowierszowego  nie  są  sprawdzane i są
              dodawane do historii bez względu na wartość HISTIGNORE.
       HISTSIZE
              Liczba poleceń do zapamiętania w historii poleceń (zobacz HISTO‐
              RIA poniżej).  Wartością domyślną jest 500.
       HISTTIMEFORMAT
              Gdy ta zmienna jest ustawiona i nie jest pusta, jej wartość jest
              użyta jak format łańcucha do strftime(3),  w  celu  wyświetlenia
              pieczątki  czasowej związanej z każdym wpisem historii, wyświet‐
              lanym przez wbudowane polecenie history. Gdy zmienna jest ustaw‐
              iona,  pieczątki czasowe są zapisywane do pliku historii, dzięki
              czemu mogą być zachowywane między sesjami powłoki. Używany  jest
              wówczas znak komentarza historii, aby odróżnić pieczątki czasowe
              od pozostałych wierszy historii.
       HOME   Katalog domowy bieżącego  użytkownika;  domyślny  argument  wbu‐
              dowanego  polecenia cd. Wartość tej zmiennej wykorzystywana jest
              też przy wykonywaniu interpretacji tyld.
       HOSTFILE
              Zawiera nazwę pliku o tym samym  formacie  co  /etc/hosts  który
              powinien  być  czytany,  gdy  powłoka potrzebuje uzupełnić nazwę
              hosta.  Listę możliwych uzupełnień można zmieniać podczas  pracy
              powłoki. Następnym razem, gdy wykonywana jest próba uzupełnienia
              nazwy hosta bash dodaje  zawartość  nowego  pliku  do  już  ist‐
              niejącej listy.  Jeżeli HOSTFILE jest ustawione, ale nie posiada
              wartości, bash usiłuje uzyskać listę możliwych  uzupełnień  nazw
              hostów czytając /etc/hosts Gdy HOSTFILE jest unieważniane, lista
              hostów jest czyszczona.
       IFS    Wewnętrzny Separator Pól (Internal Field Separator)  używany  do
              podziału  na  słowa  po  interpretacjach  i dzieleniu wierszy na
              słowa we wbudowanym poleceniu  read.   Jego  domyślną  wartością
              jest ,,<spacja><tabulacja><nowalinia>”.
       IGNOREEOF
              Steruje  działaniem  powłoki interaktywnej przy otrzymaniu przez
              nią znaku EOF jako jedynego znaku wejścia.  Jeżeli  jest  ustaw‐
              iona,  to  jej  wartość  jest  liczbą kolejnych znaków EOF jakie
              muszą być wpisane jako pierwsze znaki wiersza wprowadzania przed
              zakończeniem  pracy  przez bash.  Jeśli zmienna ta istnieje, ale
              nie  zawiera  wartości  numerycznej  lub  nie  ma  wartości,  to
              wartością domyślną jest 10. Jeżeli nie istnieje, to EOF wskazuje
              powłoce koniec wprowadzanych danych.
       INPUTRC
              Nazwa pliku startowego  dla  readline,  unieważniająca  domyślny
              plik ~/.inputrc (zobacz READLINE poniżej).
       LANG   Służy  do  wyznaczania kategorii locale dla wszystkich kategorii
              nie wyszczególnionych przez zmienne rozpoczynające się od znaków
              LC_.
       LC_ALL Zmienna  ta unieważnia wartość LANG i wszelkich innych zmiennych
              LC_ określających kategorie locale.
       LC_COLLATE
              Ta zmienna wyznacza kolejność  (collation  order)  używaną  przy
              sortowaniu  wyników  rozwijania  nazw  plików,  decyduje  też  o
              zachowaniu wielu wyrażeń, klas równoważnych i sekwencje sortowa‐
              nia (collating sequences) w rozwijaniu nazw plików i dopasowywa‐
              niu wzorców.
       LC_CTYPE
              Ta zmienna decyduje o interpretacji znaków i zachowaniu się klas
              znaków wewnątrz rozwijania nazw plików i dopasowywania wzorców.
       LC_MESSAGES
              Ta  zmienna decyduje o ustawieniu locale używanym do tłumaczenia
              ujętych w cudzysłowy łańcuchów poprzedzonych znakiem $.
       LC_NUMERIC
              Ta zmienna określa  kategorię  locale  używaną  do  formatowania
              liczb.
       LINES  Używana przez polecenie wbudowane select do wyznaczenia długości
              kolumn przy wypisywaniu list wyboru.  Ustawiana automatycznie po
              otrzymaniu SIGWINCH.
       MAIL   Jeżeli  parametrowi temu jest przypisana nazwa pliku, a nie jest
              ustawiona zmienna MAILPATH,  to  bash  informuje  użytkownika  o
              nadejściu  poczty  do  podanego  pliku  lub  katalogu w formacie
              Maildir.
       MAILCHECK
              Określa jak często (w sekundach) bash sprawdza pocztę. Domyślnie
              jest  to  60  sekund.  Gdy  nadchodzi  pora  sprawdzenia poczty,
              powłoka wykonuje to przed wyświetleniem głównej zachęty.   Jeśli
              zmienna  ta nie jest ustawiona lub jest ustawiona na wartość nie
              większą od zera lub zero, to powłoka wyłącza sprawdzanie poczty.
       MAILPATH
              Lista rozdzielonych dwukropkami nazw plików,  w  jakich  ma  być
              sprawdzana   poczta.  Można  podać  komunikat,  jaki  ma  zostać
              wyświetlony, gdy do danego pliku przybędzie wiadomość  pocztowa,
              przez  oddzielenie nazwy pliku od komunikatu znakiem '?'.  Użyte
              w  tekście  komunikatu,  $_  interpretowane  jest   jako   nazwa
              bieżącego pliku pocztowego.  Przykład:
              MAILPATH='/var/mail/bfox?"You  have  mail":~/shell-mail?"$_  has
              mail!"'
              Bash zapewnia  tej  zmiennej  wartość  domyślną,  ale  położenie
              plików  pocztowych  użytkownika,  jakim  się posługuje zależy od
              systemu (np. /var/mail/$USER).
       OPTERR Jeżeli ustawiono na  wartość  1,  bash  wyświetla  komunikaty  o
              błędach  generowanych  przez wbudowane polecenie getopts (zobacz
              WBUDOWANE POLECENIA POWŁOKI poniżej).  OPTERR inicjowane jest na
              1  każdorazowo,  gdy wywoływana jest powłoka lub wykonywany jest
              skrypt powłoki.
       PATH   Ścieżka  wyszukiwania  poleceń.  Jest  to  lista   rozdzielanych
              dwukropkami  katalogów,  w których powłoka szuka poleceń (zobacz
              WYKONYWANIE POLECEŃ poniżej). Nazwa  katalogu  zerowej  długości
              (pusta)  oznacza katalog bieżący. Pusty katalog można podać jako
              dwa złączone dwukropki lub początkowy  albo  końcowy  dwukropek.
              Domyślna ścieżka zależy od systemu i ustawiana jest przez admin‐
              istratora  instalującego  bash.    Powszechną   wartością   jest
              ``/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin''.
       POSIXLY_CORRECT
              Jeśli  podczas  uruchamiania  bash w środowisku istnieje ta zmi‐
              enna, to powłoka przed odczytem plików startowych wchodzi w tryb
              posix, tak jakby przy jej wywołaniu podano opcję --posix.  Jeśli
              zmienna ta zostanie ustawiona podczas  pracy  powłoki,  to  bash
              włącza  tryb  posix, tak jakby zostało wykonane polecenie set -o
              posix

       PROMPT_COMMAND
              Jeżeli jest ustawiona,  to  jej  wartość  jest  wykonywana  jako
              polecenie przed każdym wysłaniem zachęty głównej.
       PROMPT_DIRTRIM
              Gdy  jest  ustawiona na liczbę większa od zera, jej wartość jest
              używana  jako  liczba  początkowych  składowych   katalogów   do
              usunięcia podczas interpretowania sekwencji specjalnych łańcucha
              zachęty \w i \W (patrz poniżej ZACHĘTA POWŁOKI).  Usuwane  znaki
              są zastępowane wielokropkiem.
       PS1    Wartość  tego  parametru  jest  interpretowana  (zobacz  poniżej
              ZACHĘTA)  i używana jako główny łańcuch zachęty. Jego  wartością
              domyślną jest "\s-\v\$ ".
       PS2    Wartość  tego  parametru  jest  interpretowana jak PS1 i używana
              jako wtórny (secondary) łańcuch zachęty. Domyślnie jest to "> ".
       PS3    Wartość tego parametru służy jako  zachęta  w  poleceniu  select
              (zobacz powyżej GRAMATYKA POWŁOKI).
       PS4    Wartość  tego parametru interpretowana jest jak PS1 i wypisywana
              przed  każdym  poleceniem  wyświetlanym   przez   bash   podczas
              śledzenia  wykonywania.   Pierwszy  znak  PS4, w razie potrzeby,
              powtarzany jest wielokrotnie, by  wskazać  wiele  poziomów  zag‐
              nieżdżenia.  Domyślnie jest to "+ ".
       SHELL  Pełna   ścieżka   powłoki  jest  przechowywana  w  tej  zmiennej
              środowiskowej. Jeśli nie  jest  ustawiona  podczas  uruchamiania
              powłoki,  bash  przypisuje  jej  wartość  pełnej ścieżki powłoki
              zgłoszeniowej bieżącego użytkownika.
       TIMEFORMAT
              Wartość tego parametru służy jako łańcuch formatu określającego,
              jak  powinna  być  wyświetlana  informacja o czasach dla potoków
              poprzedzonych słowem zastrzeżonym time. Znak %  rozpoczyna  sek‐
              wencję  specjalną,  która jest interpretowana jako wartość czasu
              lub inna informacja. Sekwencje  specjalne  i  ich  znaczenie  są
              następujące; nawiasy kwadratowe opisują części opcjonalne.
              %%        Dosłowny znak %.
              %[p][l]R  Czas, jaki upłynął, w sekundach.
              %[p][l]U  Liczba sekund, jakie CPU zużył w trybie użytkownika.
              %[p][l]S  Liczba sekund, jakie CPU zużył w trybie systemowym.
              %P        Procent  wykorzystania  CPU,  liczony jako (%U + %S) /
                        %R.

              Opcjonalne p  jest  cyfrą  określającą  dokładność  (precision),
              liczbę  cyfr  ułamkowych  po  kropce  dziesiętnej.  Wartość zero
              powoduje, że nie będzie wyświetlana ani  kropka  dziesiętna  ani
              część  ułamkowa.   Mogą  być  podane co najwyżej trzy miejsca po
              kropce dziesiętnej; wartości p większe od 3 zmieniane są  na  3.
              Jeżeli nie podano p, to używana jest wartość 3.

              Opcjonalne  l  określa  dłuższy  (longer)  format  wyników, zaw‐
              ierający minuty, w postaci  MMmSS.FFs.   O  tym,  czy  występuje
              ułamkowa część sekund decyduje wartość p.

              Jeżeli  zmienna ta nie jest ustawiona, to bash działa tak, jakby
              miała ona wartość  $'\nreal\t%3lR\nuser\t%3lU\nsys%3lS'.  Jeżeli
              jej  wartością jest pusty łańcuch, to nie jest wyświetlana żadna
              informacja o czasach (timing).   Podczas  wyświetlania  łańcucha
              formatu dodawany jest kończący znak nowej linii.
       TMOUT  Jeśli ustawione na wartość większą od zera, to TMOUT jest inter‐
              pretowane  jako  domyślny  czas  oczekiwania  wbudowanego  read.
              Polecenie  select kończy się, jeśli dane nie zostaną wprowadzone
              po liczbie TMOUT sekund, jeżeli wejście pochodzi z terminala.  W
              przypadku  powłok  interaktywnych,  wartość  jest interpretowana
              jako liczba sekund  określającą  czas,  przez  jaki  powłoka  ma
              czekać  na  wprowadzenie danych po wyświetleniu głównej zachęty.
              Bash kończy pracę  po  odczekaniu  tego  czasu  jeśli  dane  nie
              pojawiły się.
       TMPDIR Jeśli  jest  ustawiona, bash używa jej wartości jako nazwy kata‐
              logu w którym tworzy pliki tymczasowe do użytku powłoki.
       auto_resume
              Zmienna ta steruje sposobem interakcji powłoki z użytkownikiem i
              sposobem kontroli zadań. Jeżeli jest ustawiona, to jednowyrazowe
              polecenia proste bez przekierowań traktowane są jako  aspirujące
              do wznowienia istniejącego zatrzymanego zadania. Nie pozwala się
              na żadną dwuznaczność;  jeśli  jest  więcej  niż  jedno  zadanie
              rozpoczynające   się   od  wpisanego  łańcucha,  wybierane  jest
              zadanie, do którego ostatnio sięgano.  Nazwa zatrzymanego  zada‐
              nia, w tym kontekście, jest wierszem poleceń użytym do jego uru‐
              chomienia.  Jeśli posiada wartość exact, to podany łańcuch  musi
              pasować  dokładnie  do  nazwy  zatrzymanego  zadania; Jeśli jest
              ustawione na substring, to podany łańcuch  powinien  pasować  do
              podłańcucha   nazwy  zatrzymanego  zadania.   Wartość  substring
              zapewnia funkcjonalność analogiczną do identyfikatora zadania %?
              (zobacz  STEROWANIE  ZADANIAMI  poniżej).   Jeśli ustawiono inną
              wartość, to podany łańcuch musi być przedrostkiem nazwy  zatrzy‐
              manego  zadania; zapewnia to funkcjonalność analogiczną do iden‐
              tyfikatora zadania %.
       histchars
              Dwa lub trzy znaki sterujące interpretacją historii i  podziałem
              na  leksemy  (zobacz  poniżej INTERPRETACJA HISTORII).  Pierwszy
              znak  jest  znakiem   interpretacji   historii,   sygnalizującym
              początek  interpretacji  historii,  zwykle `!'.  Drugi znak jest
              znakiem szybkiego podstawiania, ("quick substitution"), służącym
              jako  skrót  do powtórnego uruchamiania poprzednio wprowadzonego
              polecenia, podstawiającym w poleceniu  jeden  łańcuch  za  inny.
              Domyślnym  znakiem szybkiego podstawiania jest `^'.  Opcjonalny,
              trzeci znak jest znakiem wskazującym, że pozostała  część  wier‐
              sza, w którym występuje on jako pierwszy znak słowa, jest komen‐
              tarzem.  Zwykle znakiem tym jest `#'. Znak  komentarza  historii
              powoduje,  że dla pozostałych słów wiersza podstawianie historii
              jest pomijane.  Niekoniecznie  powoduje  to  traktowanie  reszty
              wiersza jako komentarza przez analizator składni powłoki.

   Tablice
       Bash  udostępnia indeksowane i asocjacyjne zmienne tablicowe jednowymi‐
       arowe. Jako  tablica  może  zostać  użyta  dowolna  zmienna;  wbudowane
       declare  jawnie  zadeklaruje  tablicę.  Nie  ma  maksymalnego  rozmiaru
       tablic, ani wymagania, by wszystkie jej elementy były  indeksowane  czy
       przypisywane w sposób ciągły. Do tablic indeksowanych można się odwołać
       przy pomocy liczb całkowitych (w tym wyrażeń arytmetycznych), począwszy
       od zera; natomiast tablice asocjacyjne używają konkretnych łańcuchów.

       Tablica  indeksowana  tworzona jest automatycznie jeśli wykonywane jest
       przypisanie    do    jakiejś    zmiennej    przy     pomocy     składni
       nazwa[wskaźnik]=wartość.    Wskaźnik   tablicy   traktowany  jest  jako
       wyrażenie arytmetyczne, które musi po interpretacji dać  liczbę.  Jeśli
       wskaźnik  da  po interpretacji liczbę mniejszą od zera, to jest używany
       jako przesunięcie od maksymalnego indeksu tablicy plus jeden  (wskaźnik
       -1  odnosi  się  więc  do  ostatniego  elementu  tablicy). Chcąc jawnie
       zadeklarować tablicę indeksowaną, użyj declare -a  nazwa  (zobacz  WBU‐
       DOWANE  POLECENIA  POWŁOKI  poniżej).   declare -a nazwa[wskaźnik] jest
       również akceptowane; wskaźnik jest wówczas ignorowany.

       Tablice asocjacyjne są tworzone za pomocą konstrukcji declare -A nazwa.

       Atrybuty mogą być podane do zmiennej  tablicy  przy  użyciu  declare  i
       readonly.  Każdy  z  atrybutów  stosowany  jest do wszystkich elementów
       tablicy.

       Przypisania do tablic wykonywane są  przy  pomocy  przypisań  złożonych
       postaci  nazwa=(wartość1  ...  wartośćn), gdzie każda wartość ma postać
       [wskaźnik]=łańcuch. Przypisania tablic indeksowanych nie wymagają  naw‐
       iasu  kwadratowego  i  wskaźnika.  Jeżeli  podano  opcjonalne nawiasy i
       wskaźnik, to wartość jest przypisywana  wskazanemu  elementowi  tablicy
       indeksowanej; w przeciwnym wypadku wartość przypisywana jest elementowi
       o indeksie  o  jeden  większym  od  ostatniego  elementu  z  przypisaną
       wartością. Indeks jest liczony od zera.

       Przy  przypisywaniu  do  tablicy  asocjacyjnej  konieczne  jest podanie
       wskaźnika.

       Składnia ta jest akceptowana także przez wbudowane declare. Przypisania
       do  pojedynczych  elementów tablicy można wykonywać przy pomocy składni
       nazwa[wskaźnik]=wartość wprowadzonej powyżej.

       Do elementu tablicy można odwoływać  się  używając  ${nazwa[wskaźnik]}.
       Nawiasy  są  wymagane, by uniknąć konfliktów z rozwijaniem nazw plików.
       Jeśli wskaźnikiem jest @ lub *, to powyższe słowo  interpretowane  jest
       jako  wszystkie  elementy  nazwy.  Wskaźniki te różnią się tylko wtedy,
       gdy słowo pojawia się w cudzysłowach.  Jeśli słowo ujęto w  cudzysłowy,
       to  ${nazwa[*]}  interpretowane  jest  jako pojedyncze słowo o wartości
       wszystkich elementów tablicy rozdzielonych pierwszym  znakiem  zmiennej
       specjalnej  IFS,  zaś  ${nazwa[@]} interpretuje każdy z elementów nazwa
       jako odrębne słowo. Jeśli brak jest elementów tablicy,  to  ${nazwa[@]}
       interpretowane  jest  jako nic. Jeśli wewnątrz słowa zachodzi interpre‐
       tacja (ujęta w cudzysłowy), to pierwszy zinterpretowany  parametr  jest
       łączony  z  początkiem  oryginalnego  słowa, a interpretacja ostatniego
       parametru jest łączona z końcem oryginalnego słowa. Jest to  zachowanie
       analogiczne  do  interpretacji  parametrów  specjalnych  *  i @ (zobacz
       powyżej Parametry specjalne).  ${#nazwa[wskaźnik]} interpretowane  jest
       jako  długość  ${nazwa[wskaźnik]}.  Jeśli  wskaźnikiem jest * lub @, to
       interpretacją jest liczba elementów w tablicy. Odwoływania się do  zmi‐
       ennej  tablicowej  bez  podania  wskaźnika jest równoważne odwołaniu do
       elementu numer zero.

       Zmienna  tablicowa  jest  ustawiona,  jeśli  do  wskaźnika   przypisano
       wartość. Łańcuch pusty jest poprawną wartością.

       Do   niszczenia   tablic   służy   wbudowane  polecenie  unset.   unset
       nazwa[wskaźnik] niszczy element tablicy o indeksie wskaźnik.  Konieczne
       jest  zachowanie  wzmożonej  uwagi,  aby  zapobiec  niechcianym skutkom
       rozwijania  nazw  plików.  Polecenie  unset  nazwa,  gdzie  nazwa  jest
       tablicą,  lub  unset  nazwa[wskaźnik],  gdzie wskaźnikiem jest * lub @,
       usuwa całą tablicę.

       Każde z wbudowanych declare, local i readonly  akceptuje  opcję  -a  do
       określania tablic indeksowanych i opcję -A do określania tablic asocja‐
       cyjnych. Jeśli podano obie opcje, to  pierwszeństwo  ma  -A.  Polecenie
       read  akceptuje  opcję  -a do przypisywania tablicy listy słów przeczy‐
       tanych ze standardowego wejścia.  set i  declare  wyświetlają  wartości
       tablicowe w sposób umożliwiający ponowne ich użycie w przypisaniach.

INTERPRETACJA
       Interpretacja  wykonywana  jest  na wierszu poleceń po jego podziale na
       słowa.  Istnieje siedem rodzajów wykonywanych interpretacji:  interpre‐
       tacja nawiasów (brace expansion), interpretacja tyld (tilde expansion),
       podstawianie parametrów i interpretacja zmiennych (parameter and  vari‐
       able  expansion),  podstawienie wyników poleceń (command substitution),
       interpretacja wyrażeń arytmetycznych (arithmetic expansion), podział na
       słowa (word splitting)  i rozwinięcie nazw plików (pathname expansion).

       Kolejność  interpretacji:  interpretacja  nawiasów, interpretacja tyld,
       podstawianie parametrów, interpretacja zmiennych  i  wyrażeń  arytmety‐
       cznych  i podstawianie wyników poleceń (wykonywane od lewej do prawej),
       podział na słowa i rozwijanie nazw ścieżek.

       Na systemach potrafiących  to  obsłużyć,  istnieje  dodatkowa  dostępna
       interpretacja: podstawienie wyników procesów (process substitution).

       Tylko  interpretacja  nawiasów,  dzielenie  na słowa i rozwinięcie nazw
       plików mogą zmienić liczbę słów interpretowanego  wyrażenia;  pozostałe
       interpretacje  rozwijają pojedyncze słowo w pojedyncze słowo.  Jedynymi
       wyjątkami są interpretacje  "$@"  i  "${nazwa[@]}"  wyjaśnione  powyżej
       (zobacz PARAMETRY).

   Interpretacja nawiasów
       Interpretacja  nawiasów  jest  mechanizmem,  przez  który mogą być gen‐
       erowane dowolne łańcuchy.  Mechanizm ten  przypomina  rozwinięcia  nazw
       plików,  ale  generowane  nazwy  plików  nie muszą określać plików ist‐
       niejących. Wzorce, mające podlegać interpretacji nawiasów  mają  postać
       opcjonalnej   preambuły,   po   której   występują  serie  separowanych
       przecinkami łańcuchów pomiędzy parą  nawiasów  klamrowych,  po  których
       następuje  opcjonalny  dopisek  (postscript).   Preambuła stanowi prze‐
       drostek dla każdego  z  łańcuchów  zawartych  w  nawiasach,  a  dopisek
       dodawany  jest  do  każdego  łańcucha wynikowego, przy interpretacji od
       lewej do prawej.

       Interpretacja nawiasów może być zagnieżdżana. Wyniki każdego zinterpre‐
       towanego łańcucha nie są sortowane; zachowywana jest kolejność od lewej
       do prawej. Na przykład, a{d,c,b}e interpretowane  jest  jako  "ade  ace
       abe".

       Sekwencja  wyrażeń przyjmuje postać {x..y[..krok]}, gdzie x i y są albo
       liczbami całkowitymi, albo pojedynczymi znakami, a opcjonalny krok jest
       liczbą  całkowitą.  Gdy  podane  są liczby całkowite, to wyrażenie jest
       rozwijane do wszystkich liczb pomiędzy x i y (włącznie). Podane  liczby
       mogą  być  poprzedzone  0,  które wymusza identyczną szerokość każdej z
       wynikowych liczb. Gdy x lub y zaczynają się zerem, to  powłoka  próbuje
       wymusić   utworzenie   liczb   zawierających   tę   samą  liczbę  cyfr,
       uzupełniając je zerami tam, gdzie zachodzi taka  potrzeba.  Gdy  podano
       znaki,  wyrażenie jest rozwijane do wszystkich znaków, znajdujących się
       leksykalnie pomiędzy x a y (włącznie). Proszę odnotować, że x i y muszą
       być  tego samego typu. Gdy podano krok, to jest on używany jako różnica
       pomiędzy poszczególnymi wynikami. W zależności  od  podanych  wartości,
       domyślnym krokiem jest 1 lub -1.

       Interpretacja nawiasów wykonywana jest przed innymi rodzajami interpre‐
       tacji, a znaki o  specjalnym  znaczeniu  dla  innych  interpretacji  są
       zachowywane  w  wyniku.  Jest  ściśle tekstowa. Bash nie stosuje żadnej
       interpretacji  składniowej  do  kontekstu  interpretacji   czy   tekstu
       pomiędzy nawiasami.

       Poprawnie  zbudowana  interpretacja  nawiasów musi zawierać niecytowany
       nawias  otwierający  i  zamykający  i  co  najmniej  jeden  niecytowany
       przecinek.   Wszelkie niepoprawnie skonstruowane interpretacje nawiasów
       są pozostawiane bez zmian.  { lub , można cytować przy  pomocy  odwrot‐
       nego ukośnika, co chroni je przed przyjmowaniem za część wyrażenia naw‐
       iasowego.  Dla uniknięcia konfliktu z interpretacją parametrów, łańcuch
       ${ nie jest traktowany jako spełniający warunki interpretacji nawiasów.

       Typowym  zastosowaniem  tej  konstrukcji  jest skrót, wtedy gdy wspólny
       przedrostek łańcuchów do utworzenia jest dłuższy niż w powyżej  podanym
       przykładzie, np.:

              mkdir /usr/local/src/bash/{old,new,dist,bugs}
       lub
              chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}

       Interpretacja  nawiasów wprowadza niewielką niezgodność z historycznymi
       wersjami sh.  sh nie traktuje nawiasów otwierających i  zamykających  w
       specjalny sposób gdy pojawiają się one jako część słowa, i zachowuje je
       w wyniku.  W bash konsekwencją  interpretacji  nawiasów  jest  usuwanie
       nawiasów  ze słów.  Na przykład, słowo wprowadzone do sh jako plik{1,2}
       pojawi się w identycznej postaci na wyjściu. To samo słowo po interpre‐
       tacji  przez  bash  daje  plik1  plik2.   Jeżeli  pożądana  jest ścisła
       zgodność z sh, uruchom bash z opcją +B lub  wyłącz  interpretację  naw‐
       iasów  przy  pomocy  opcji +B polecenia set (zobacz WBUDOWANE POLECENIA
       POWŁOKI poniżej).

   Interpretacja tyldy
       Jeżeli słowo rozpoczyna się niecytowanym znakiem tyldy (`~'), to wszys‐
       tkie  znaki  poprzedzające  pierwszy niecytowany ukośnik (lub wszystkie
       znaki, gdy nie ma ukośnika) uważane są za przedrostek tyldy (tilde-pre‐
       fix).  Jeżeli żaden ze znaków w przedrostku tyldy nie jest cytowany, to
       jego znaki następujące po znaku tyldy traktowane są jako możliwa  nazwa
       logowania  (login  name).   Jeśli  ta  nazwa  logowania  jest łańcuchem
       pustym, to tylda zastępowana jest  wartością  parametru  powłoki  HOME.
       Jeżeli  HOME  nie  jest  ustawione,  to podstawiany jest za nie katalog
       domowy użytkownika  uruchamiającego  powłokę.   W  przeciwnym  wypadku,
       przedrostek  tyldy  zastępowany  jest  katalogiem domowym skojarzonym z
       określoną nazwą logowania.

       Jeśli przedrostkiem tyldy jest `~+', to jest on  zastępowany  wartością
       zmiennej  PWDpowłoki.   Jeśli przedrostkiem tyldy jest `~-', to jest on
       zastępowany wartością zmiennej powłoki OLDPWD, jeśli  jest  ona  ustaw‐
       iona.  Jeżeli występujące w przedrostku po tyldzie znaki składają się z
       liczby N, opcjonalnie poprzedzonej przez `+' lub  `-',  to  przedrostek
       tyldy  zastępowany  jest  odpowiednim  elementem  stosu katalogów, jaki
       zostałby wyświetlony przez wbudowane  dirs,  wywołane  z  przedrostkiem
       tyldy jako argumentem.  Jeżeli w przedrostku tyldy znaki występujące po
       tyldzie składają się z liczby bez początkowego `+' lub `-',  to  przyj‐
       mowane jest `+'.

       Jeśli  nazwa  logowania  jest nieprawidłowa lub interpretacja tyldy nie
       powiodła się, to słowo z tyldą pozostaje niezmienione.

       Każde z przypisań do zmiennej sprawdzane jest na obecność niecytowanych
       przedrostków tyldy występujących bezpośrednio po : lub =.  W tych przy‐
       padkach również jest wykonywana jest interpretacja  tyldy.   Na  skutek
       tego,  można posługiwać się nazwami plików z tyldami w przypisaniach do
       PATH, MAILPATH i CDPATH, a powłoka przypisze zinterpretowaną wartość.

   Podstawianie parametrów
       Znak  `$'  wprowadza  podstawianie  parametrów,  podstawianie   wyników
       poleceń  i  interpretację wyrażeń arytmetycznych. Podlegająca interpre‐
       tacji nazwa parametru lub symbol mogą być  ujęte  w  nawiasy  klamrowe,
       które  są  opcjonalne,  ale  służą  do ochrony interpretowanej zmiennej
       przed znakami, jakie występują bezpośrednio po niej,  a  które  mogłyby
       zostać zinterpretowane jako część nazwy.

       Gdy używane są nawiasy, pasującym nawiasem kończącym jest pierwszy `}',
       nie chroniony przez  odwrotny  ukośnik,  nie  znajdujący  się  wewnątrz
       cytowanego  łańcucha  ani  nie osadzony w wyrażeniu arytmetycznym, pod‐
       stawieniu wyniku polecenia czy podstawieniu parametru.

       ${parametr}
              Podstawiana jest wartość  parametru.  Nawiasy  wymagane  są  gdy
              parametr  jest parametrem pozycyjnym o więcej niż jednej cyfrze,
              lub gdy po parametrze występuje znak,  który  nie  powinien  być
              interpretowany jako część jego nazwy.

       Jeżeli  pierwszym  znakiem  parametru jest wykrzyknik, to rozpoczyna on
       poziom zagnieżdżenia zmiennej pośredniej.  Bash posługuje się wartością
       zmiennej  utworzonej z reszty parametru jako nazwą zmiennej; zmienna ta
       jest następnie interpretowana a w  dalszym  podstawianiu  używana  jest
       otrzymana  wartość  zamiast  wartości  samego parametru.  Znane jest to
       jako interpretacja pośrednia (indirect expansion).  Wyjątkami są inter‐
       pretacja   ${!przedrostek*}   i   ${!nazwa[@]}   opisane  poniżej.  Aby
       wprowadzić  interpretację   pośrednią,   wykrzyknik   musi   występować
       bezpośrednio po lewym nawiasie klamrowym.

       W  każdym  z  poniższych przypadków, słowo podlega interpretacji tyldy,
       podstawianiu parametrów, podstawianiu wyników poleceń  i  interpretacji
       wyrażeń arytmetycznych.

       Gdy  nie  przeprowadza  interpretacji  podłańcuchów,  bash sprawdza czy
       parametr nie jest pusty lub nieustawiony. Pominięcie dwukropka skutkuje
       sprawdzeniem jedynie tego, czy parametr nie jest nieustawiony.

       ${parametr:-słowo}
              Używa wartości domyślnych. Jeżeli parametr jest nieustawiony lub
              pusty, to podstawiane jest zinterpretowane słowo.  W  przeciwnym
              razie, podstawiana jest wartość parametru.
       ${parametr:=słowo}
              Przypisuje wartości domyślne.  Jeżeli parametr jest nieustawiony
              lub  pusty,  to  jest  mu  przypisywane  zinterpretowane  słowo.
              Następnie  podstawiana  jest wartość parametru.  Nie można w ten
              sposób przypisywać wartości parametrom pozycyjnym ani parametrom
              specjalnym.
       ${parametr:?słowo}
              Wyświetla  błąd  jeśli  pusty lub nieustawiony.  Jeżeli parametr
              jest nieustawiony lub pusty, to na  standardowe  wyjście  błędów
              zapisywane  jest  zinterpretowane  słowo  (lub komunikat o takim
              wyniku, jeśli brak słowa).  Jeśli powłoka nie jest interaktywna,
              to kończy pracę.  W przeciwnym wypadku, podstawiana jest wartość
              parametru.
       ${parametr:+słowo}
              Używa wartości alternatywnej.  Jeżeli parametr jest nieustawiony
              lub  pusty, to nic nie jest podstawiane, w przeciwnym razie pod‐
              stawiane jest zinterpretowane słowo.
       ${parametr:przesunięcie}
       ${parametr:przesunięcie:długość}
              Interpretacja podłańcuchów.  Interpretuje  co  najwyżej  długość
              znaków  parametru  poczynając  od znaków określonych przez prze‐
              sunięcie. Jeśli pominięto długość,  to  interpretuje  podłańcuch
              parametru  poczynając  od  znaku określonego przez przesunięcie.
              długość i przesunięcie  są  wyrażeniami  arytmetycznymi  (zobacz
              OBLICZANIE  WYRAŻEŃ ARYTMETYCZNYCH poniżej).  długość musi dawać
              w wyniku liczbę większą bądź równą  zero.   Jeżeli  przesunięcie
              daje  w  wyniku liczbę mniejszą od zera, a parametrem nie jest @
              ani tablica indeksowana lub  asocjacyjna,  to  uzyskana  wartość
              używana  jest  jako  offset liczony od końca wartości parametru,
              zamiast liczby znaków, a interpretacją są znaki  pomiędzy  dwoma
              przesunięciami.   Jeżeli  parametrem  jest  @,  to wynikiem jest
              długość  parametrów  pozycyjnych,  począwszy  od   przesunięcia.
              Jeżeli  parametr  jest nazwą tablicy indeksowanej przez @ lub *,
              to  wynikiem  jest  długość  członków   tablicy   począwszy   od
              ${parametr[przesunięcie]}.  Wartość  ujemna  jest interpretowana
              jako różnica w stosunku do maksymalnego  indeksu  danej  tablicy
              powiększonym  o  jeden. Interpretacja podłańcucha zastosowana do
              tablicy asocjacyjnej daje niezdefiniowane wyniki. Proszę zwrócić
              uwagę,  że ujemne przesunięcie musi być oddzielone dwukropkiem i
              co najmniej jedną spacją, aby uniknąć pomylenia z  interpretacją
              :-.  Indeksowanie  podłańcucha  rozpoczyna się od zera, chyba że
              używane są parametry pozycyjne, wówczas indeksowanie zaczyna się
              od  1.  Jeżeli  przesunięciem  jest  0 oraz używane są parametry
              pozycyjne, to $0 jest dodawane jako przedrostek do listy.

       ${!przedrostek*}
       ${!przedrostek@}
              Nazywa pasujący przedrostek. Rozwija się w listę nazw tych  zmi‐
              ennych,   których   nazwy   rozpoczynają   się  od  przedrostka,
              rozdzielonych od siebie pierwszym  znakiem  zmiennej  specjalnej
              IFS.  Jeśli  używane  jest  @, a interpretacja jest ujęta w cud‐
              zysłowy, to każda nazwa zmiennej jest interpretowana  jako  odd‐
              zielne słowo.

       ${!nazwa[@]}
       ${!nazwa[*]}
              Lista kluczy z tablicy. Jeśli nazwa jest zmienną tablicową, jest
              rozwijana do listy wskaźników (kluczy) tablicowych  przypisanych
              do  nazwy.  Jeśli nazwa nie jest tablicą, interpretowana jest do
              0, jeśli nazwa jest ustawiona lub pozostaje pusta  w  przeciwnym
              wypadku.  Gdy  używane jest !, a interpretacja jest ujęta w cud‐
              zysłowy, każdy klucz jest rozwijany do oddzielnego słowa.

       ${#parametr}
              Długość parametru. Podstawiana jest długość, w znakach, wartości
              parametru.   Jeżeli parametrem jest * lub @, wartość podstawiana
              jest liczbą parametrów pozycyjnych.  Jeżeli parametr jest  nazwą
              tablicy  o  indeksowanej przez * lub @, wartość podstawiana jest
              liczbą elementów tablicy.

       ${parametr#słowo}
       ${parametr##słowo}
              Usuwanie pasującego wzorca  przedrostka.  Słowo  jest  interpre‐
              towane  tworząc  wzorzec,  tak  samo  jak  przy  rozwijaniu nazw
              plików. Jeżeli wzorzec pasuje do początku wartości parametru, to
              wynikiem  interpretacji jest zinterpretowana wartość parametru z
              usuniętym najkrótszym (przypadek ,,#”)  lub  najdłuższym  (przy‐
              padek ,,##”) pasującym wzorcem.  Jeżeli parametrem jest @ lub *,
              to operacja usunięcia wzorca stosowana jest do każdego po  kolei
              parametru  pozycyjnego, zaś wynikiem interpretacji jest powstała
              lista.  Jeśli parametr jest zmienną tablicową indeksowaną  przez
              @  lub  *,  to  operacja  usuwania wzorca jest przeprowadzana po
              kolei na każdym elemencie tablicy,  zaś  wynikiem  interpretacji
              jest powstała lista.

       ${parametr%słowo}
       ${parametr%%słowo}
              Usuwanie pasującego wzorca przyrostka. Słowo jest interpretowane
              tworząc wzorzec, tak  samo  jak  przy  rozwijaniu  nazw  plików.
              Jeżeli  wzorzec  pasuje  do  końcowej  części  zinterpretowanego
              parametru, wynikiem interpretacji jest  zinterpretowana  wartość
              parametru   z   usuniętym   najkrótszym   (przypadek  ,,%”)  lub
              najdłuższym (przypadek ,,%%”) pasującym wzorcem. Jeżeli  parame‐
              trem  jest  @ lub *, to operacja usunięcia wzorca stosowana jest
              do każdego po kolei parametru pozycyjnego, zaś  wynikiem  inter‐
              pretacji  jest   powstała  lista.  Jeśli  parametr  jest zmienną
              tablicową indeksowaną przez @ lub *,  operacja  usuwania  wzorca
              jest  przeprowadzana  po  kolei na każdym elemencie tablicy, zaś
              wynikiem interpretacji jest powstała lista.

       ${parametr/wzorzec/łańcuch}
              Zastępowanie wzorca.  Wzorzec jest interpretowany  w  identyczny
              sposób  jak  to ma miejsce przy rozwijaniu nazw plików. Parametr
              jest rozwijany, a najdłuższe dopasowanie wzorca do jego wartości
              jest  zastępowane  łańcuchem. Jeśli wzorzec rozpoczyna się /, to
              wszystkie dopasowania wzorca są zastępowane  łańcuchem.  Normal‐
              nie,  zastępowane jest tylko pierwsze dopasowanie. Jeśli wzorzec
              rozpoczyna się #, to musi pasować do  początku  zinterpretowanej
              wartości  parametru. Jeśli zaczyna się %, musi natomiast pasować
              do końca tej wartości. Jeśli łańcuch jest pusty, wszystkie dopa‐
              sowania  wzorca  są  usuwane,  a początkowy / wzorca może zostać
              pominięty. Jeśli parametrem jest @ lub *, to operacja podstawia‐
              nia jest przeprowadzana na każdym parametrze pozycyjnym z kolei,
              a zinterpretowanym wynikiem jest powstała lista. Jeśli  parametr
              jest  zmienną tablicową, w której jako indeks podano @ lub *, to
              operacja podstawiania jest przeprowadzana na każdym  jej  wpisie
              po kolei, a zinterpretowanym wynikiem jest powstała lista.

       ${parametr^wzorzec}
       ${parametr^^wzorzec}
       ${parametr,wzorzec}
       ${parametr,,wzorzec}
              Modyfikacja   wielkości   znaków.  Ta  interpretacja  modyfikuje
              wielkość zawartych liter  zgodnie  z  parametrem.  Wzorzec  jest
              interpretowany  w  taki  sposób,  jak  czyni  to rozwijanie nazw
              plików. Operator ^ konwertuje małe litery pasujące do wzorca  na
              wielkie,  operator  , działa odwrotnie. ^^ i ,, konwertują każdy
              dopasowany znak interpretowanej wartości, natomiast ^ i  ,  kon‐
              wertują  jedynie  jej pierwszy znak. Jeśli nie podano wzorca, to
              przyjmuje się za niego ?, co powoduje dopasowanie każdego znaku.
              Jeśli   parametrem  jest  @  lub  *,  to  operacja  podstawiania
              stosowana jest do każdego po kolei  parametru  pozycyjnego,  zaś
              wynikiem interpretacji jest powstała lista.  Jeśli parametr jest
              zmienną tablicową indeksowaną przez @ lub *, operacja podstawia‐
              nia  jest  przeprowadzana  po kolei na każdym elemencie tablicy,
              zaś wynikiem interpretacji jest powstała lista.

   Podstawianie wyników poleceń
       Podstawianie  wyników  poleceń  (command   substitution)   pozwala   na
       zastępowanie  nazwy  polecenia  wyjściem  (wynikiem)  z jego działania.
       Posiada dwie postaci:

              $(polecenie)
       lub
              `polecenie`

       Bash wykonuje interpretację wykonując polecenie i  zastępując  podstaw‐
       iane  polecenie  jego  utworzonym  standardowym  wyjściem, z usuniętymi
       końcowymi znakami nowej linii.  Zawarte  wewnątrz  wyniku  znaki  nowej
       linii  nie są usuwane, ale mogą być usunięte podczas podziału na słowa.
       Podstawienie wyniku polecenia $(cat plik) można  zastąpić  równoważnym,
       ale szybszym $(< plik).

       Gdy  używane  jest  podstawianie  w  starym stylu, z użyciem odwrotnych
       apostrofów,  odwrotny  ukośnik  zachowuje  swe  znaczenie  dosłowne,  z
       wyjątkiem  przypadków, gdy jest poprzedzony przez $, ` lub \.  Pierwszy
       odwrotny apostrof (`) nie poprzedzony odwrotnym ukośnikiem kończy  pod‐
       stawianie   wyniku   polecenia.    Podczas  posługiwania  się  postacią
       $(polecenie), polecenie  tworzą  wszystkie  znaki  pomiędzy  nawiasami;
       żaden nie jest traktowany specjalnie.

       Podstawianie  wyników  poleceń  może  być  zagnieżdżane.  W  celu  zag‐
       nieżdżenia postaci z odwrotnymi apostrofami zabezpiecz wewnętrzne przed
       interpretacją używając odwrotnych ukośników.

       Jeżeli  podstawianie  pojawia  się wewnątrz cudzysłowów, to na wynikach
       nie jest przeprowadzany podział na słowa ani rozwinięcie nazw plików.

   Interpretacja wyrażeń arytmetycznych
       Interpretacja wyrażeń  arytmetycznych  pozwala  na  obliczanie  wyrażeń
       arytmetycznych  i  podstawianie  wyniku. Format interpretacji arytmety‐
       cznej:

              $((wyrażenie))

       Stary format $[wyrażenie]  jest  przestarzały  i  zostanie  usunięty  w
       przyszłych wersjach basha.

       wyrażenie  traktowane jest tak, jakby było ujęte w cudzysłowy, ale cud‐
       zysłów wewnątrz nawiasów nie  jest  traktowany  specjalnie.   Wszystkie
       tokeny  w  wyrażeniu  podlegają interpretacji parametrów, interpretacji
       łańcuchów,  podstawianiu  wyników  poleceń  i   usuwaniu   cudzysłowów.
       Wyrażenia arytmetyczne mogą być zagnieżdżane.

       Interpretacja przeprowadzana jest zgodnie z zasadami podanymi poniżej w
       sekcji OBLICZENIA ARYTMETYCZNE.  Jeżeli wyrażenie  jest  nieprawidłowe,
       bash  wypisuje komunikat o niepowodzeniu i nie występuje żadne podstaw‐
       ienie.

   Podstawianie wyników procesów (Process substitution)
       Podstawianie   wyników   procesów   obsługiwane   jest   na   systemach
       obsługujących  potoki  nazwane  (FIFO)  lub  metodę  /dev/fd  nazywania
       otwartych plików.  Przybiera ono postać <(lista) lub >(lista).   Proces
       lista  uruchamiany  jest  z wejściem i wyjściem podłączonym do FIFO lub
       jakiegoś pliku w /dev/fd.  W  wyniku  interpretacji  nazwa  tego  pliku
       przesyłana  jest  jako  argument bieżącego polecenia.  Jeżeli posłużono
       się postacią >(lista), zapis  do  pliku  będzie  stanowić  wejście  dla
       listy.  Jeżeli  posłużono  się  postacią <(lista), plik przekazany jako
       argument powinien zostać odczytany w celu uzyskania wyjścia listy.

       Gdy jest to  możliwe,  podstawianie  wyników  procesu  wykonywane  jest
       równocześnie  z  interpretacją  parametrów  i  zmiennych, podstawianiem
       wyników poleceń i interpretacją wyrażeń arytmetycznych.

   Podział na słowa
       Powłoka  przeszukuje  wyniki  interpretacji  parametrów,   podstawiania
       poleceń i interpretacji wyrażeń arytmetycznych, które nie pojawiają się
       wewnątrz cudzysłowów, w celu przeprowadzenia podziału na słowa.

       Powłoka  traktuje  każdy  znak  IFS  jak  separator  i  w  miejscu  ich
       występowania  dzieli  na słowa wyniki innych interpretacji.  Jeżeli IFS
       nie   jest   ustawione    lub    jego    wartością    jest    dokładnie
       <spacja><tab><nowalinia>, wartość domyślna, to sekwencje składające się
       ze <spacji>, <tabulatora> i <nowejlinii> na początku  i  końcu  wyników
       poprzednich  interpretacji  są ignorowane, a do podziału na słowa służy
       dowolna sekwencja znaków IFS, jeżeli nie znajduje się na  początku  lub
       końcu.   Jeżeli  IFS  posiada  wartość  inną niż domyślna, to sekwencje
       białych znaków spacji i tabulacji są ignorowane  na  początku  i  końcu
       słowa,  dopóki  biały  znak  występuje w wartości IFS (biały znak IFS).
       Inne znaki w IFS nie będące białymi znakami IFS,  łącznie  z  dowolnymi
       przyległymi  białymi  znakami IFS, ograniczają pole.  Sekwencja białych
       znaków IFS jest również traktowana jako ogranicznik.   Jeśli  IFS  jest
       łańcuchem pustym, to nie występuje podział na słowa.

       Jawnie  puste argumenty ("" lub '') są pozostawiane.  Niecytowane argu‐
       menty puste niejawnie, wynikające z interpretacji parametrów nie  posi‐
       adających  wartości, są usuwane.  Jeśli parametr bez wartości interpre‐
       towany jest wewnątrz cudzysłowów, to wynikiem  jest  argument  pusty  i
       jest on zachowywany.

       Zauważ,  że  jeśli  nie  występuje  interpretacja,  to nie jest również
       wykonywany podział.

   Rozwijanie nazw plików (Pathname Expansion)
       Po podziale na słowa, jeżeli nie ustawiona została opcja -f,  przegląda
       każde  słowo w poszukiwaniu znaków *, ? i [.  Jeśli pojawia się jeden z
       nich, to słowo uważane jest za wzorzec i zastępowane  jest  posortowaną
       alfabetycznie  listą  nazw  plików  pasujących  do  wzorca.  Jeżeli nie
       znaleziono pasujących nazw a wyłączona  jest  opcja  nullglob  powłoki,
       słowo pozostawiane jest bez zmian. Jeżeli nullglob jest włączone, a nie
       znaleziono dopasowań, to słowo jest usuwane. Jeśli ustawiona jest opcja
       failglob  powłoki i nie znaleziono dopasowań, to wyświetlany jest komu‐
       nikat o błędzie, a polecenie nie jest wykonywane. Jeżeli włączona  jest
       opcja  nocaseglob  powłoki, to dopasowywanie wzorca wykonywane jest bez
       zwracania uwagi na wielkość liter. Proszę zwrócić uwagę, ze  gdy  użyte
       są  wyrażenia  zakresowe,  takie  jak [a-z] (patrz niżej), mogą również
       zostać uwzględnione litery innej wielkości, w zależności od  ustawienia
       LC_COLLATE.  Gdy  do  rozwinięcia nazw plików używa się wzorca, to znak
       "." na początku nazwy lub bezpośrednio po ukośniku  musi  zostać  dopa‐
       sowany  dosłownie,  chyba  że ustawiono opcję dotglob powłoki.  Podczas
       dopasowywania nazwy pliku znak ukośnika musi zawsze  zostać  dopasowany
       dosłownie.   W  pozostałych  przypadkach, kropka ". nie jest traktowana
       specjalnie.  Zobacz poniżej opis shopt  w  sekcji  WBUDOWANE  POLECENIA
       POWŁOKI, gdzie znajdziesz omówienie opcji powłoki nocaseglob, nullglob,
       failglob i dotglob.

       Do ograniczenia zestawu nazw plików pasujących do  wzorca  można  wyko‐
       rzystać  zmienną powłoki GLOBIGNORE.  Jeżeli GLOBIGNORE jest ustawione,
       każda z pasujących nazw plików pasująca również do jednego ze wzorców w
       GLOBIGNORE  jest usuwana z listy dopasowań.  Nazwy plików "." i ".." są
       zawsze ignorowane,  nawet  gdy  GLOBIGNORE  jest  ustawione.  Jednakże,
       ustawienie  GLOBIGNORE  skutkuje  włączeniem opcji dotglob, tak że będą
       dopasowywane wszystkie inne nazwy plików rozpoczynające się od  kropki.
       W celu uzyskania starego zachowania, ignorującego nazwy zaczynające się
       ".", jednym ze wzorców w GLOBIGNORE należy zrobić ".*".  Opcja  dotglob
       jest wyłączana, gdy kasowane jest GLOBIGNORE.

       Dopasowanie wzorca

       Każdy  znak  pojawiający  się  we  wzorcu,  różny od specjalnych znaków
       wzorca opisanych poniżej, dopasowuje sam  siebie.  Znak  NUL  nie  może
       wystąpić  we  wzorcu.  Odwrotny ukośnik cytuje następujący po nim znak;
       sam ukośnik jest pomijany podczas dopasowania. Specjalne  znaki  wzorca
       muszą być cytowane, jeżeli mają być dopasowane dosłownie.

       Specjalne znaki wzorca mają następujące znaczenie:

              *      Dopasowuje  dowolny  łańcuch, łącznie z łańcuchem pustym.
                     Jeśli włączona jest opcja  globstar  powłoki,  a  *  jest
                     użyte   w  kontekście  rozwijania  nazw  plików,  to  dwa
                     złączone znaki *  użyte  w  pojedynczym  wzorcu  dopasują
                     wszystkie  pliki wraz z zerem lub więcej katalogów i pod‐
                     katalogów. Jeśli po dwóch gwiazdkach * wystąpi ukośnik /,
                     to dopasowane będą wyłącznie katalogi i podkatalogi.
              ?      Dopasowuje dowolny pojedynczy znak.
              [...]  Dopasowuje  jeden  z ujętych w nawiasy kwadratowe znaków.
                     Para  znaków  rozdzielona  myślnikiem  opisuje  wyrażenie
                     zakresu;  dopasowywany  jest nim dowolny znak, który przy
                     sortowaniu leksykalnym, z zastosowaniem bieżącego  ustaw‐
                     ienia  locale  i zestawu znaków, wypada między tymi dwoma
                     znakami,  włącznie  z  nimi.   Jeżeli  pierwszym  znakiem
                     występującym  po  [  jest  !  lub ^, to dopasowywany jest
                     dowolny znak nie zawarty w nawiasach.  Kolejność sortowa‐
                     nia  znaków  w  wyrażeniach  zakresu określona jest przez
                     bieżące   ustawienie   locale    i    wartość    zmiennej
                     środowiskowej  LC_COLLATE,  jeśli istnieje.  Znak - można
                     dopasować włączając  go  jako  pierwszy  lub  ostatni  ze
                     znaków zestawu.  Znak ] można dopasować włączając go jako
                     pierwszy znak zestawu.

                     Wewnątrz [ i ], można  podawać  klasy  znaków  (character
                     classes),  używając  składni  [:klasa:], gdzie klasa jest
                     jedną z  poniższych  klas  zdefiniowanych  w  standardzie
                     POSIX:
                     alnum  alpha  ascii  blank  cntrl digit graph lower print
                     punct space upper word xdigit
                     Klasa znaków dopasowuje  dowolny  znak  należący  do  tej
                     klasy.  Klasa znaków word dopasowuje litery, cyfry i znak
                     podkreślenia "_".

                     Wewnątrz [ i ], można podać klasę równoważności, używając
                     składni  [=z=],  która  dopasowuje  wszystkie znaki o tej
                     samej wadze sortowania (zdefiniowaną w bieżącym  ustawie‐
                     niu locale) co znak z.

                     Wewnątrz  [  i  ],  składnia [.symbol.] dopasowuje symbol
                     sortowania (collating symbol) symbol.

       Jeżeli przy pomocy wbudowanego shopt włączono opcję extglob, to rozpoz‐
       nawane  jest  kilka  rozszerzonych  operatorów  dopasowania wzorców.  W
       poniższym opisie, lista-wzorców jest listą złożoną z jednego lub więcej
       wzorców rozdzielonych znakiem |.  Wzorce złożone można konstruować przy
       pomocy jednego lub więcej poniższych pod-wzorców:

              ?(lista-wzorców)
                     Dopasowuje zero lub jedno wystąpienie zadanych wzorców
              *(lista-wzorców)
                     Dopasowuje zero lub więcej wystąpień zadanych wzorców
              +(lista-wzorców)
                     Dopasowuje jedno lub więcej wystąpień zadanych wzorców
              @(lista-wzorców)
                     Dopasowuje jeden z zadanych wzorców
              !(lista-wzorców)
                     Dopasowuje cokolwiek prócz jednego z zadanych wzorców

   Usunięcie cytowań
       Po  poprzednich  interpretacjach,  wszystkie  niecytowane   wystąpienia
       znaków \, ' i ", które nie wynikły z jednej z powyższych interpretacji,
       są usuwane.

PRZEKIEROWANIE
       Przed  wykonaniem  polecenia,  jego  wejście  i  wyjście  mogą   zostać
       przekierowane  przy  pomocy  specjalnej  notacji  interpretowanej przez
       powłokę.  Przekierowań można  też  używać  do  otwierania  i  zamykania
       plików  dla środowiska wykonywania bieżącej powłoki. Poniższe operatory
       przekierowania mogą występować  przed  lub  pojawiać  się  gdziekolwiek
       wewnątrz polecenia prostego lub występować po poleceniu. Przekierowania
       przetwarzane są w kolejności występowania, od lewej do prawej.

       Każde przekierowanie, które może być  poprzedzone  numerem  deskryptora
       pliku,  może  być  w  zamian  poprzedzone słowem zapisanym następująco:
       {nazwa-zmiennej}. W takim przypadku, dla każdego operatora przekierowa‐
       nia, z wyjątkiem >&- i <&-, powłoka nada deskryptor pliku większy od 10
       i przypisze go do nazwy-zmiennej. Jeśli >&- lub  <&-  jest  poprzedzone
       {nazwą-zmiennej},  to wartość nazwy-zmiennej definiuje deskryptor pliku
       przeznaczony do zamknięcia.

       W poniższych opisach, jeśli pominięto  deskryptor  pliku,  a  pierwszym
       znakiem  operatora  przekierowania jest <, przekierowanie dotyczy stan‐
       dardowego wejścia (deskryptor pliku 0).  Jeżeli pierwszym znakiem oper‐
       atora  przekierowania  jest  >,  przekierowanie  dotyczy  standardowego
       wyjścia (deskryptor pliku 1).

       Słowo następujące do operatorze  przekierowania  w  poniższych  opisach
       podlega, chyba że podano inaczej, interpretacji nawiasów, interpretacji
       tyldy, interpretacji parametrów, podstawianiu wyników  poleceń,  inter‐
       pretacji  wyrażeń  arytmetycznych,  usuwaniu  cytowań,  rozwijaniu nazw
       plików i podziałowi na  słowa.   Jeśli  zinterpretowane  zostanie  jako
       więcej niż jedno słowo, to bash zgłosi błąd.

       Zauważ, że kolejność przekierowań jest znacząca. Na przykład, polecenie

              ls > dirlist 2>&1

       kieruje   zarówno  standardowe  wyjście  jak  i  wyjście  diagnostyczne
       (stderr)  do pliku dirlist, podczas gdy polecenie

              ls 2>&1 > dirlist

       kieruje tylko standardowe wyjście do pliku dirlist, gdyż wyjście błędów
       zostało  zduplikowane  jako  standardowe  wyjście przed przekierowaniem
       wyjścia do dirlist.

       Bash obsługuje kilka nazw plików w sposób specjalny gdy są one użyte  w
       przekierowaniach. Opisano to w poniższej tablicy:

              /dev/fd/fd
                     Jeżeli  fd jest poprawną liczbą całkowitą, to duplikowany
                     jest deskryptor pliku fd.
              /dev/stdin
                     Duplikowany jest deskryptor pliku 0.
              /dev/stdout
                     Duplikowany jest deskryptor pliku 1.
              /dev/stderr
                     Duplikowany jest deskryptor pliku 2.
              /dev/tcp/host/port
                     Jeśli host jest poprawną nazwą hosta lub adresem interne‐
                     towym,  a  port  jest  liczbą całkowitą określającą numer
                     portu lub nazwą usługi, to bash usiłuje otworzyć połącze‐
                     nie TCP do odpowiedniego gniazda.
              /dev/udp/host/port
                     Jeśli host jest poprawną nazwą hosta lub adresem interne‐
                     towym, a port jest  liczbą  całkowitą  określającą  numer
                     portu lub nazwą usługi, to bash usiłuje otworzyć połącze‐
                     nie UDP do odpowiedniego gniazda.

       Nieudane  otwarcie  lub   utworzenie   pliku   powoduje   niepowodzenie
       przekierowania.

       Przekierowania używające deskryptorów plików, większych niż 9 muszą być
       używane z dużą ostrożnością, gdyż mogą być w konflikcie z deskryptorami
       plików używanymi wewnętrznie przez powłokę.

       Proszę  zauważyć, że wbudowane polecenie exec może tworzyć przekierowa‐
       nia odnoszące się do bieżącej powłoki.

   Przekierowanie wejścia
       Przekierowanie wejścia powoduje  otwarcie  do  odczytu  pliku,  którego
       nazwa  wynika  z  interpretacji  słowa.   Odczyt  będzie  wykonywany  z
       deskryptora pliku n lub standardowego wejścia (zerowy deskryptor pliku)
       jeśli nie podano n.

       Ogólny format przekierowania wejścia:

              [n]<słowo

   Przekierowanie wyjścia
       Przekierowanie wyjścia powoduje otwarcie do zapisu pliku, którego nazwa
       wynika z interpretacji słowa.  Zapis będzie  wykonywany  z  deskryptora
       pliku n lub standardowego wyjścia (deskryptor pliku 1) jeśli nie podano
       n.  Jeżeli plik nie istnieje jest tworzony;  jeżeli  istnieje  obcinany
       jest do rozmiaru zerowego.

       Ogólny format przekierowania wyjścia:

              [n]>słowo

       Jeżeli  operatorem  przekierowania  jest  >,  a  została włączona opcja
       noclobber wbudowanego polecenia set, to  przekierowanie  nie  powiedzie
       się  jeżeli  plik o nazwie wynikającej z interpretacji słowa istnieje i
       jest zwykłym plikiem.  Jeżeli operatorem przekierowania jest  >|,  albo
       operatorem jest > przy niewłączonej opcji noclobber, to wykonywana jest
       próba przekierowania, nawet jeśli plik słowo istnieje.

   Dołączanie przekierowanego wyjścia
       Przekierowanie  wyjścia  w  ten  sposób  powoduje,  że  plik  o  nazwie
       wynikającej  z  interpretacji  słowa  zostanie  otwarty  do  dołączania
       (append).  Dołączanie będzie wykonywane z deskryptora pliku n lub stan‐
       dardowego wyjścia (deskryptor pliku 1) jeśli nie podano n.  Jeżeli plik
       nie istnieje jest tworzony.

       Ogólny format dołączania wyjścia:

              [n]>>słowo

   Przekierowanie standardowego wyjścia i wyjścia błędów
       Bash pozwala, przy pomocy  tej  konstrukcji,  przekierować  standardowe
       wyjście  (deskryptor  pliku 1) i standardowe wyjście błędów (deskryptor
       plików 2) do pliku, którego nazwą jest zinterpretowane słowo.

       Istnieją dwie postaci takiego przekierowania:

              &>słowo
       i
              >&słowo

       Spośród nich, zalecaną jest  pierwsza  forma.   Jest  ona  semantycznie
       równoważna

              >słowo 2>&1

   Dołączanie standardowego wyjścia i wyjścia błędów
       Ta konstrukcja pozwala na dołączanie, standardowego wyjścia (deskryptor
       pliku 1) i standardowego wyjścia błędów (deskryptor plików 2) do pliku,
       którego nazwą jest zinterpretowane słowo.

       Format dołączania standardowego wyjścia i wyjścia błędów:

              &>>słowo

       Jest to semantycznie równoważne

              >>słowo 2>&1

   Dokumenty włączone (Here Documents)
       Ten   typ  przekierowania  instruuje  powłokę,  by  czytała  wejście  z
       bieżącego źródła aż do napotkania  wiersza  zawierającego  tylko  słowo
       (bez  żadnych  kończących  odstępów).  Wszystkie wiersze przeczytane do
       tego momentu są następnie używane jako standardowe wejście polecenia.

       Format dokumentów włączonych jest następujący:

              <<[-]słowo
                      dokument włączony
              ogranicznik

       Na słowie nie jest wykonywana  interpretacja  parametrów,  podstawiania
       wyników poleceń, rozwijanie nazw plików ani interpretacja wyrażeń aryt‐
       metycznych.  Jeżeli jakieś znaki w słowie są cytowane,  to  ogranicznik
       jest  wynikiem  usunięcia  cytowań  ze  słowa,  a  wiersze w dokumencie
       włączonym nie są  interpretowane.   Jeżeli  słowo  nie  jest  cytowane,
       wszystkie   wiersze   dokumentu   włączonego   podlegają  interpretacji
       parametrów, podstawianiu  poleceń  i  interpretacji  wyrażeń  arytmety‐
       cznych.   W   tym   ostatnim  przypadku,  sekwencja  \<nowalinia>  jest
       ignorowana, a do cytowania znaków \, $ i ` musi być użyte \.

       Jeżeli operatorem przekierowania  jest  <<-,  to  wszystkie  początkowe
       znaki  tabulacji  są  obcinane  z  wierszy  wejściowych  i wiersza zaw‐
       ierającego ogranicznik.  Pozwala to na ustawienie naturalnych wcięć dla
       dokumentów włączonych w skryptach powłoki.

   Łańcuchy włączone (Here Strings)
       Wariant dokumentów włączonych, którego format jest następujący:

              <<<słowo

       Słowo  jest  interpretowane i podawane do polecenia na jego standardowe
       wejście.

   Powielanie deskryptorów plików
       Operator przekierowania

              [n]<&słowo

       służy do powielania deskryptorów plików wejściowych.  Jeżeli słowo zin‐
       terpretowane  zostanie  jako jedna lub więcej cyfr, to deskryptor pliku
       oznaczony przez n czyniony jest kopią tego deskryptora.  Jeżeli cyfry w
       słowie  nie  określają  otwartego  dla wejścia deskryptora, pojawia się
       błąd  przekierowania.   Jeżeli  słowo  zinterpretowane  jest  jako   -,
       deskryptor  pliku  n  jest zamykany. Jeżeli n nie zostało określone, to
       stosowane jest standardowe wejście (deskryptor pliku 0).

       Operator

              [n]>&słowo

       podobnie,  służy  do  powielania  deskryptorów  standardowego  wyjścia.
       Jeżeli  nie określono n, stosowane jest standardowe wyjście (deskryptor
       pliku 1).  Jeżeli  cyfry  w  słowie  nie  określają  deskryptora  pliku
       otwartego  do  wyjścia,  pojawia  się błąd przekierowania.  W przypadku
       specjalnym, jeżeli pominięto n, a słowo nie  jest  interpretowane  jako
       jedna  lub  więcej  cyfr,  to  przekierowywane są standardowe wyjście i
       standardowe wyjście błędów, jak opisano poprzednio.

   Przenoszenie deskryptorów plików
       Operator przekierowania

              [n]<&słowo-

       przenosi deskryptor pliku słowo do deskryptora pliku n lub,  jeśli  nie
       podano  n,  na  standardowe  wejście  (deskryptor  pliku 0). Słowo jest
       zamykane po zduplikowaniu do n.

       Podobnie, operator przekierowania

              [n]>&słowo-

       przenosi deskryptor pliku słowo do deskryptora pliku n lub,  jeśli  nie
       podano n, na standardowe wyjście (deskryptor pliku 1).

   Otwieranie deskryptorów plików do odczytu i zapisu
       Operator przekierowania

              [n]<>słowo

       powoduje,  że  plik  o  nazwie  wynikłej z interpretacji słowa zostanie
       otwarty do odczytu i zapisu.  Odczyt i zapis będą wykonywane z deskryp‐
       tora  pliku  n lub standardowego wejścia (deskryptor pliku 0) jeśli nie
       podano n.  Jeżeli plik nie istnieje, to jest tworzony.

ALIASY
       Aliasy (czyli synonimy) pozwalają na zastąpienie słowa  łańcuchem,  gdy
       zostanie  ono  użyte  jako pierwsze słowo w poleceniu prostym.  Powłoka
       utrzymuje listę aliasów, które mogą być ustawiane i  unieważniane  przy
       pomocy  wbudowanych  poleceń  alias i unalias (zobacz poniżej WBUDOWANE
       POLECENIA POWŁOKI).  Dla pierwszego słowa każdego polecenia, jeśli  nie
       jest  cytowane,  następuje  sprawdzenie,  czy posiada ono alias. Jeżeli
       tak, to słowo to jest zastępowane tekstem aliasu. Znaki /, $, ` i  =  i
       wszystkie  metaznaki  powłoki oraz znaki cytowania wypisane powyżej nie
       mogą być nazwą aliasu. Tekst zastępujący może zawierać dowolne poprawne
       wejście  powłoki,  łącznie z metaznakami powłoki. Pierwsze słowo tekstu
       zastępującego jest z kolei sprawdzane na aliasy, ale słowo identyczne z
       interpretowanym  właśnie  aliasem  nie  jest  interpretowane powtórnie.
       Oznacza to, że można mieć alias ls do ls -F, na przykład,  a  bash  nie
       będzie   usiłował  rekurencyjnie  interpretować  zastępującego  tekstu.
       Jeżeli ostatnim znakiem wartości aliasu jest odstęp, to następne  słowo
       polecenia  występujące  po  aliasie ma również sprawdzaną interpretację
       aliasów.

       Aliasy są tworzone i pokazywane poleceniem alias, a usuwane  poleceniem
       unalias.

       Nie  ma  żadnego  mechanizmu  posługiwania  się  argumentami  w tekście
       zastępującym.  Jeśli  potrzebne  są  argumenty,  powinna  zostać  użyta
       funkcja powłoki (zobacz poniżej FUNKCJE).

       Aliasy  nie są interpretowane, gdy powłoka nie jest interaktywna, chyba
       że ustawiono opcję powłoki expand_aliases  przy  pomocy  shopt  (zobacz
       opis shopt w sekcji WBUDOWANE POLECENIA POWŁOKI poniżej).

       Reguły  dotyczące  definiowania i używania aliasów są nieco zagmatwane.
       Bash zawsze czyta co najmniej jeden pełny wiersz z wejścia przed  wyko‐
       naniem  jakichkolwiek  poleceń tego wiersza. Aliasy interpretowane są w
       czasie odczytu polecenia, nie podczas jego wykonywania. Z tego  powodu,
       definicja aliasu występująca w tym samym wierszu, co inne polecenie nie
       zadziała aż do przeczytania następnego wiersza wejścia.   Na  polecenia
       występujące po definicji aliasu, w tym samym wierszu, nowy alias nie ma
       wpływu.  Zachowanie to ujawnia się także podczas  wykonywania  funkcji.
       Aliasy  interpretowane  są  w czasie odczytu definicji funkcji, nie zaś
       podczas jej wykonywania, gdyż sama definicja funkcji stanowi  polecenie
       złożone.  W  skutek tego aliasy zdefiniowane w funkcji nie są dostępne,
       aż  do  chwili  po  wykonaniu  funkcji.   Dla  bezpieczeństwa,   zawsze
       umieszczaj  definicje  aliasów  w odrębnym wierszu i nie używaj alias w
       poleceniach złożonych.

       Prawie w każdym zastosowaniu aliasy są wyparte przez funkcje powłoki.

FUNKCJE
       Punkcja powłoki, zdefiniowana jak opisano powyżej, w  sekcji  GRAMATYKA
       POWŁOKI,  przechowuje  szereg  poleceń  do późniejszego wykonania.  Gdy
       nazwa funkcji powłoki  używana  jest  jako  nazwa  polecenia  prostego,
       wykonywana  jest  lista poleceń związanych z tą nazwą funkcji.  Funkcje
       wykonywane są w kontekście bieżącej powłoki; do ich  interpretacji  nie
       jest tworzony żaden nowy proces (zauważ różnicę w stosunku do wykonania
       skryptu powłoki).  Podczas wykonywania funkcji,  przekazane  jej  argu‐
       menty  stają  się parametrami pozycyjnymi. Aktualizowany jest specjalny
       parametr #, tak by odzwierciedlał zmianę. Parametr pozycyjny 0 nie jest
       zmieniany.  Zmienna FUNCNAME podczas wykonywania funkcji ustawiana jest
       na jej nazwę.

       Wszystkie inne aspekty środowiska  wykonywania  powłoki  są  identyczne
       między  funkcją  i  jej wywołującym, z następującymi wyjątkami: pułapki
       (trap) DEBUG i RETURN (zobacz opis wbudowanego trap poniżej,  w  sekcji
       WBUDOWANE  POLECENIA  POWŁOKI) nie są dziedziczone, chyba że funkcja ma
       podany atrybut trace (patrz opis wbudowanego declare poniżej) lub opcja
       powłoki -o functrace została włączona wbudowanym set (w takim przypadku
       wszystkie funkcje dziedziczą pułapki DEBUG i RETURN). Pułapka  ERR  nie
       jest dziedziczona, chyba że włączono opcję -o errtrace powłoki.

       Zmienne  lokalne  dla  funkcji  mogą  być  deklarowane przy pomocy wbu‐
       dowanego polecenia local.  Zwykle zmienne i ich wartości są wspólne dla
       funkcji i jej wołającego.

       Jeśli  zmienna  FUNCNEST zostanie ustawiona na wartość liczbową większą
       od 0, to będzie definiować  maksymalny  poziom  zagnieżdżenia  funkcji.
       Wywołania  funkcji przekraczające ten poziom będą powodowały przerwanie
       całego polecenia.

       Jeżeli w funkcji wywoływane jest wbudowane  polecenie  return,  funkcja
       kończy  działanie  i wykonywanie wznawiane jest od następnego polecenia
       po wywołaniu funkcji. Każda funkcja powiązana  z  pułapką  RETURN  jest
       wykonywana przed wznowieniem wykonywania. Gdy funkcja kończy działanie,
       parametrom  pozycyjnym  i  parametrowi  specjalnemu  #  przywracane  są
       wartości, jakie posiadały one przed wykonaniem funkcji.

       Listę  nazw i definicji funkcji można uzyskać przy pomocy opcji -f wbu‐
       dowanych poleceń declare lub typeset.  Opcja  -F  poleceń  declare  lub
       typeset  podaje  same  nazwy  funkcji (i opcjonalnie plik źródłowy oraz
       numer wiersza, jeśli włączono opcję powłoki extdebug).   Funkcje  można
       eksportować, tak że będą one automatycznie zdefiniowane w podpowłokach.
       Wykonuje się to przy pomocy  opcji  -f  wbudowanego  polecenia  export.
       Definicję  funkcji  można  usunąć opcją -f lub wbudowanym unset. Proszę
       zauważyć, że funkcje i zmienne powłoki posiadające tę samą  nazwę  mogą
       dać  w  wyniku  wiele  wpisów  o  identycznych  nazwach  w  środowisku,
       przekazywanym do potomków powłoki. Należy zachować ostrożność  w  przy‐
       padkach, w których może to powodować problemy.

       Funkcje  mogą  być  rekurencyjne.  Zmienna  FUNCNEST  może  posłużyć do
       ograniczenia głębokości stosu wywołań funkcji i liczby wywołań funkcji.
       Domyślnie,  nie  ma  narzuconego  ograniczenia na liczbę rekurencyjnych
       wywołań.

OBLICZANIE WYRAŻEŃ ARYTMETYCZNYCH
       Powłoka pozwala, pod pewnymi warunkami, na obliczanie wartości  wyrażeń
       arytmetycznych  (zobacz wbudowane polecenie let i Interpretacja wyrażeń
       arytmetycznych).  Obliczenia wykonywane są na  liczbach  całkowitych  o
       ustalonej  wielkości  (fixed-width),  bez kontroli przepełnienia (over‐
       flow), mimo iż dzielenie przez 0 jest przechwytywane i  oznaczane  jako
       błąd.   Operatory  i ich priorytety oraz sposób ich dołączania są takie
       same jak w języku C.  Poniższa  lista  operatorów  pogrupowana  jest  w
       poziomy  operatorów  o  jednakowym priorytecie.  Poziomy podano w kole‐
       jności malejącego priorytetu.

       id++ id--
              post-inkrementacja i post-dekrementacja zmiennej
       ++id --id
              pre-inkrementacja i pre-dekrementacja zmiennej
       - +    jednoargumentowy minus i plus
       ! ~    negacja logiczna i bitowa
       **     potęgowanie
       * / %  mnożenie, dzielenie, reszta z dzielenia
       + -    dodawanie, odejmowanie
       << >>  lewo i prawostronne przesunięcie bitowe
       <= >= < >
              porównanie
       == !=  równości i nierówność
       &      bitowa koniunkcja (AND)
       ^      bitowa alternatywa wyłączna (XOR)
       |      bitowa alternatywa (OR)
       &&     logiczna koniunkcja (AND)
       ||     logiczna alternatywa (OR)
       wyraż?wyraż:wyraż
              operator warunkowy
       = *= /= %= += -= <<= >>= &= ^= |=
              przypisanie
       wyraż1 , wyraż2
              przecinek

       Jako operandy dozwolone są zmienne  powłoki;  interpretacja  parametrów
       przeprowadzana  jest  przed obliczeniem wyrażenia.  Wewnątrz wyrażenia,
       do zmiennych powłoki można się też odwoływać przez  nazwę,  bez  użycia
       składni interpretacji parametrów. Zmienna powłoki, która jest pusta lub
       nieustawiona jest przyjmowana jako 0, gdy odwołuje się do jej nazwy bez
       używania składni interpretacji parametrów. Gdy wystąpi odwołanie się do
       zmiennej lub gdy przypisano wartość zmiennej, której  nadano  wcześniej
       atrybut  liczby  całkowitej  przy  użyciu  declare  -i,  to jej wartość
       obliczana jest jako wyrażenie arytmetyczne. Pusta wartość  jest  inter‐
       pretowana  jako  0.  Zmienna  powłoki nie musi mieć włączonego atrybutu
       liczby całkowitej by mogła być użyta w wyrażeniu.

       Stałe  z  początkowym  0  interpretowane  są  jako   liczby   ósemkowe.
       Początkowe  0x  lub 0X oznacza liczbę szesnastkową. W pozostałych przy‐
       padkach liczby mają postać [podstawa#]n, gdzie opcjonalna podstawa jest
       liczbą  dziesiętną pomiędzy 2 a 64 reprezentującą podstawę układu pozy‐
       cyjnego, zaś n liczbą w układzie o tej podstawie.  Jeśli pominięto pod‐
       stawa#,  to  używana  jest  podstawa 10.  Cyfry większe niż 9 reprezen‐
       towane są przez małe litery, wielkie litery, @ i _, w  tej  kolejności.
       Jeżeli  podstawa  jest  mniejsza  bądź  równa  36,  to  do zapisu liczb
       pomiędzy 10 a 35 można używać zamiennie małych i wielkich liter.

       Operatory interpretowane są w  kolejności  priorytetu.  Podwyrażenia  w
       nawiasach  obliczane  są  jako  pierwsze i mogą unieważnić podane wyżej
       reguły priorytetów.

WYRAŻENIA WARUNKOWE
       Wyrażenia warunkowe używane są przez polecenie złożone [[ oraz  polece‐
       nia  wbudowane  test  i  [  do testowania atrybutów pliku i wykonywania
       porównań  łańcuchowych  i  arytmetycznych.   Wyrażenia  złożone  są   z
       poniższych  jedno- i dwuargumentowych składowych.  Jeśli któryś z argu‐
       mentów plikowych jednej z  składowych  jest  w  postaci  /dev/fd/n,  to
       sprawdzany  jest  deskryptor  pliku  n.   Jeżeli  argument plik którejś
       składowej jest jednym z /dev/stdin,  /dev/stdout  lub  /dev/stderr,  to
       sprawdzany jest, odpowiednio, deskryptor 0, 1 lub 2.

       Jeśli  nie określono inaczej, składowe operujące na plikach podążają za
       dowiązaniami symbolicznymi i działają na  celu  dowiązania,  a  nie  na
       samym dowiązaniu.

       Gdy  operatory  <  i > są używane z poleceniem [[, to sortują zgodnie z
       porządkiem leksykograficznym,  używając  bieżącego  ustawienia  locale.
       Polecenie test sortuje korzystając z kolejności ASCII.

       -a plik
              Prawda jeśli plik istnieje.
       -b plik
              Prawda jeśli plik istnieje i jest blokowym plikiem specjalnym.
       -c plik
              Prawda jeśli plik istnieje i jest znakowym plikiem specjalnym.
       -d plik
              Prawda jeśli plik istnieje i jest katalogiem.
       -e plik
              Prawda jeśli plik istnieje.
       -f plik
              Prawda jeśli plik istnieje i jest plikiem zwykłym.
       -g plik
              Prawda jeśli plik istnieje i ma ustawiony bit set-group-id.
       -h plik
              Prawda jeśli plik istnieje i jest dowiązaniem symbolicznym.
       -k plik
              Prawda  jeśli  plik  istnieje i ma ustawiony bit ochrony (sticky
              bit).
       -p plik
              Prawda jeśli plik istnieje i jest potokiem nazwanym (FIFO).
       -r plik
              Prawda jeśli plik istnieje i daje się czytać.
       -s plik
              Prawda jeśli plik istnieje i ma rozmiar większy niż zero.
       -t fd  Prawda jeśli deskryptor pliku fd jest otwarty i  odnosi  się  do
              terminala.
       -u plik
              Prawda jeśli plik istnieje i ma ustawiony bit set-user-id.
       -w plik
              Prawda jeśli plik istnieje i daje się doń zapisać.
       -x plik
              Prawda jeśli plik istnieje i jest wykonywalny.
       -G plik
              Prawda jeśli plik istnieje i jego właścicielem jest efektywny id
              grupy.
       -L plik
              Prawda jeśli plik istnieje i jest dowiązaniem symbolicznym.
       -N plik
              Prawda jeśli plik istnieje i został zmodyfikowany od czasu  jego
              ostatniego odczytu.
       -0 plik
              Prawda jeśli plik istnieje i jego właścicielem jest efektywny id
              użytkownika.
       -S plik
              Prawda jeśli plik istnieje i jest gniazdem.
       plik1 -ef plik2
              Prawda jeśli plik1 i plik2 odnoszą się do tego samego urządzenia
              i numeru i-węzła.
       plik1 -nt plik2
              Prawda,  jeśli  plik1  jest nowszy (według daty modyfikacji) niż
              plik2 lub plik1 istnieje a plik2 nie.
       plik1 -ot plik2
              Prawda, jeśli plik1 jest starszy niż plik2 lub plik2 istnieje  a
              plik1 nie.
       -o nazwa_opcji
              Prawda  jeśli  opcja  powłoki nazwa_opcji jest włączona.  Zobacz
              zestawienie opcji w opisie opcji -o wbudowanego set, poniżej.
       -v nazwa-zmiennej
              Prawda, jeśli zmienna  powłoki  zmienna-powłoki  jest  ustawiona
              (została jej przypisana wartość).
       -z łańcuch
              Prawda jeśli długość łańcucha wynosi zero.
       string
       -n łańcuch
              Prawda jeśli łańcuch ma długość niezerową.

       łańcuch1 == łańcuch2
       łańcuch1 = łańcuch2
              Prawda,  jeśli  łańcuchy są sobie równe. = powinno być używane z
              poleceniem test, w celu zachowania zgodności z normą POSIX.

       łańcuch1 != łańcuch2
              Prawda jeśli łańcuchy nie są równe.

       łańcuch1 < łańcuch2
              Prawda  jeśli  łańcuch1  przy  sortowaniu   występowałby   przed
              łańcuchem2 według bieżącego ustawienia locale.

       łańcuch1 > łańcuch2
              Prawda  jeśli łańcuch1 przy sortowaniu występowałby po łańcuchu2
              według bieżącego ustawienia locale.

       arg1 OP arg2
              OP jest jednym z -eq, -ne, -lt, -le, -gt lub -ge.  Te  arytmety‐
              czne  operatory  dwuargumentowe  zwracają prawdę jeśli arg1 jest
              odpowiednio równe (eq),  nie  równe  (ne),  mniejsze  niż  (lt),
              mniejsze  bądź  równe  (le),  większe  niż (gt) lub większe bądź
              równe (ge) arg2.  Arg1 i arg2 mogą być  dodatnimi  lub  ujemnymi
              liczbami całkowitymi.

INTERPRETACJA POLECEŃ PROSTYCH
       Gdy  wykonywane  jest  polecenie  proste,  powłoka wykonuje następujące
       interpretacje, przypisania i przekierowania, od lewej do prawej.

       1.     Słowa oznaczone przez analizator składni jako przypisania zmien‐
              nych    (poprzedzające   nazwę   polecenia)   i   przekierowania
              zachowywane są do późniejszego przetworzenia.

       2.     Słowa, nie będące przypisaniami zmiennych  ani  przekierowaniami
              są  interpretowane.  Jeżeli  po  interpretacji  pozostaną jakieś
              słowa, to pierwsze z nich przyjmowane jest za nazwę polecenia  a
              pozostałe za argumenty.

       3.     Wykonywane  są  przekierowania,  jak  opisano  powyżej  w sekcji
              PRZEKIEROWANIE.

       4.     W każdym przypisaniu zmiennej tekst po znaku równości =  podlega
              interpretacji   tyldy,  interpretacji  parametrów,  podstawianiu
              wyników poleceń, interpretacji wyrażeń arytmetycznych i usuwaniu
              cudzysłowów, zanim zostanie przypisany do zmiennej.

       Jeżeli  nie  otrzymano żadnej nazwy polecenia, to przypisania zmiennych
       dotyczą środowiska aktualnej powłoki. W przeciwnym  razie,  zmienne  są
       dodawane  do  środowiska  wykonywanego  polecenia  i nie mają wpływu na
       środowisko bieżącej powłoki. jeżeli któreś z  przypisań  usiłuje  nadać
       wartość  zmiennej read-only, pojawia się błąd, a polecenie kończy pracę
       z niezerowym kodem.

       Jeżeli nie otrzymano żadnej nazwy polecenia, wykonywane są przekierowa‐
       nia,  ale  nie  mają  one  wpływu  na  bieżące środowisko powłoki. Błąd
       przekierowania powoduje, że polecenie kończy pracę z niezerowym kodem.

       Jeżeli po interpretacji istnieje nazwa polecenia, to wykonywanie odbywa
       się  jak opisano poniżej. W przeciwnym wypadku, polecenie kończy pracę.
       Jeżeli jednym z wykonanych kroków było podstawienie wyników  polecenia,
       to  zwracany  kod zakończenia jest kodem ostatniego wykonanego podstaw‐
       ienia polecenia. Jeśli nie wystąpiło podstawianie poleceń, to polecenie
       kończy pracę z kodem zerowym.

WYKONYWANIE POLECEŃ
       Po  podziale  polecenia  na  słowa,  jeśli jego wynikiem jest polecenie
       proste z opcjonalną listą argumentów, podejmowane są poniższe akcje.

       Jeśli polecenie nie zawiera ukośników, powłoka usiłuje je zlokalizować.
       Jeżeli  istnieje  funkcja  powłoki  o  tej  nazwie,  wywoływana jest ta
       funkcja, jak opisano powyżej w sekcji FUNKCJE.  Jeżeli nazwa nie pasuje
       do  funkcji,  powłoka  szuka  jej na liście poleceń wbudowanych. Jeżeli
       znaleziono pasujące, to jest ono wywoływane.

       Jeżeli nazwa nie jest ani funkcją powłoki ani poleceniem  wbudowanym  i
       nie  zawiera  ukośników,  to  bash  przeszukuje  każdy  element  z PATH
       usiłując znaleźć katalog zawierający plik wykonywalny o takiej  nazwie.
       Bash  posługuje  się  tablicą mieszającą (hash table) do zapamiętywania
       pełnych nazw plików wykonywalnych (zobacz hash  w  WBUDOWANE  POLECENIA
       POWŁOKI  poniżej).   Pełne  przeszukiwanie  katalogów z PATH wykonywane
       jest tylko wtedy, gdy polecenia nie znaleziono w  tablicy  mieszającej.
       Jeżeli  wyszukiwanie  nie  powiedzie  się,  powłoka szuka zdefiniowanej
       funkcji powłoki o nazwie  command_not_found_handle.  Jeśli  ta  funkcja
       istnieje,  jest  wywoływana  z pierwotnym poleceniem i jego argumentami
       użytymi jako jej argumenty, a  kod  wyjścia  funkcji  staje  się  kodem
       wyjścia  powłoki. Jeśli funkcja nie jest zdefiniowana, powłoka wypisuje
       komunikat o błędzie i zwraca kod zakończenia równy 127.

       Jeżeli poszukiwanie było pomyślne lub  jeśli  nazwa  polecenia  zawiera
       jeden  lub więcej ukośników, powłoka wykonuje zadany program w odrębnym
       środowisku wykonania.  Argumentowi 0 przypisywana jest podana nazwa,  a
       pozostałym argumentom polecenia podane argumenty, jeśli były takowe.

       Jeżeli wykonanie to nie powiedzie się, gdyż plik nie ma formatu wykony‐
       walnego, a nie jest katalogiem, to zakłada się,  że  jest  on  skryptem
       powłoki,  plikiem zawierającym polecenia powłoki.  Powoływana jest pod‐
       powłoka do jego wykonania. Powłoka ta reinicjuje się, zatem efekt  jest
       taki,  jakby  do  obsługi  skryptu  została  wywołana  nowa  powłoka, z
       wyjątkiem tego, że położenia poleceń zapamiętane przez rodzica  (zobacz
       hash  poniżej  w  WBUDOWANE  POLECENIA  POWŁOKI  są  zachowywane  przez
       potomka.

       Jeżeli program jest plikiem o zawartości rozpoczynającej się od #!,  to
       reszta  pierwszego  wiersza  określa  interpreter  dla  tego  programu.
       Powłoka uruchamia podany interpreter na systemach  operacyjnych,  które
       same  nie  obsługują  tego  formatu wykonywalnego. Argumenty dla inter‐
       pretera   składają   się   z   pojedynczego   opcjonalnego    argumentu
       występującego  po  nazwie  interpretera  w  pierwszym wierszu programu,
       następującej po nim nazwy programu i następujących po  niej  argumentów
       polecenia, jeśli były takowe.

ŚRODOWISKO WYKONYWANIA POLECEŃ
       Powłoka  posiada  środowisko  wykonywania  (execution  environment), na
       które składają się:

       ·      otwarte pliki odziedziczone przez powłokę przy wywołaniu, zmody‐
              fikowane  przez przekierowania przekazane do wbudowanego polece‐
              nia exec

       ·      bieżący katalog roboczy ustawiony przez cd, pushd lub popd, albo
              odziedziczony przez powłokę przy wywołaniu

       ·      maska   trybu  tworzonych  plików  ustawioną  przez  umask  albo
              odziedziczoną po rodzicu powłoki

       ·      bieżące pułapki ustawione przez trap

       ·      parametry powłoki ustawione  przez  przypisania  zmiennych  przy
              pomocy set albo odziedziczone ze środowiska rodzica powłoki

       ·      funkcje  powłoki zdefiniowane podczas wykonywania lub odziedzic‐
              zone ze środowiska rodzica powłoki

       ·      opcje włączone przy wywołaniu (albo domyślnie albo  przy  pomocy
              argumentów wiersza poleceń) albo przez set

       ·      opcje włączone przez shopt

       ·      aliasy powłoki zdefiniowane przy pomocy alias

       ·      różne id procesów, łącznie z identyfikatorami zadań tła, wartość
              $$ i wartość $PPID

       Gdy ma zostać wykonane polecenie proste inne niż  funkcja  powłoki  lub
       polecenie  wbudowane,  wywoływane jest w odrębnym środowisku wykonania,
       składających się z poniższych  elementów.  Jeśli  nie  podano  inaczej,
       wartości dziedziczone są z powłoki.


       ·      otwarte  pliki  powłoki,  plus  modyfikacje  i dodatki określone
              przez przekierowania polecenia

       ·      bieżący katalog roboczy

       ·      maska trybu tworzonych plików

       ·      zmienne powłoki oznaczone do wyeksportowania, razem ze zmiennymi
              wyeksportowanymi do polecenia, przekazane w środowisku

       ·      pułapki  przechwycone  przez  powłokę  resetowane są do wartości
              odziedziczonych przez nią od rodzica, a pułapki ignorowane przez
              powłokę są ignorowane.

       Polecenie wywołane w odrębnym środowisku nie może wpływać na środowisko
       wykonywania powłoki.

       Podstawienia wyników poleceń i polecenia asynchroniczne wywoływane są w
       środowisku podpowłoki, które jest kopią środowiska powłoki, z wyjątkiem
       tego, że pułapki przechwycone przez powłokę są resetowane do  wartości,
       jakie  powłoka  odziedziczyła  po  rodzicu podczas wywołania. Polecenia
       wbudowane  wywoływane  jako  część  potoku  również  wykonywane  są   w
       środowisku podpowłoki. Zmiany wykonane w środowisku podpowłoki nie mogą
       wpływać na środowisko wykonywania powłoki.

       Podpowłoki utworzone do wykonania podstawiania wyników poleceń  dziedz‐
       iczą  wartość  opcji -e z powłoki macierzystej. Jeśli bash nie działa w
       trybie posix, to czyści opcję -e w takich podpowłokach.

       Jeżeli po poleceniu występuje &, a nie uaktywniono  sterowania  zadani‐
       ami,  to  domyślnym standardowym wejściem dla tego polecenia jest pusty
       plik /dev/null. W  przeciwnym  razie  wywoływane  polecenie  dziedziczy
       deskryptory  plików  po wołającej powłoce, zmodyfikowane przekierowani‐
       ami.

ŚRODOWISKO
       Podczas  wywoływania  program   otrzymuje   tablicę   łańcuchów   zwaną
       środowiskiem  (environment). Jest to lista par nazwa-wartość, o postaci
       nazwa=wartość.

       Powłoka pozwala na manipulowanie środowiskiem na kilka  sposobów.  Przy
       wywołaniu,  przeszukuje  ona  własne  środowisko  i tworzy parametr dla
       każdej znalezionej nazwy, automatycznie zaznaczając go do wyeksportowa‐
       nia  do procesów potomnych. Wykonywane polecenia dziedziczą środowisko.
       Polecenia export i declare -x pozwalają  na  dodawanie  i  usuwanie  ze
       środowiska  parametrów  i  funkcji.  Jeżeli w środowisku zmieniana jest
       wartość parametru,  to  nowa  wartość  staje  się  częścią  środowiska,
       zastępując   starą.  Środowisko  dziedziczone  przez  każde  wykonywane
       polecenie  składa  się  z  początkowego  środowiska  powłoki,   którego
       wartości  mogą  być w powłoce zmieniane, minus ewentualne pary usunięte
       poleceniem unset, plus dodane poprzez polecenia export i declare -x.

       Środowisko dla dowolnego polecenia prostego czy funkcji może  być  tym‐
       czasowo   powiększone   przez   poprzedzenie   polecenia   przypisaniem
       parametrów, jak opisano powyżej  w  sekcji  PARAMETRY.   Te  instrukcje
       przypisania  mają  wpływ  wyłącznie  na środowisko postrzegane przez to
       polecenie.

       Jeżeli ustawiona jest opcja -k (zobacz poniżej opis wbudowanego polece‐
       nia   set),  to  wszystkie  przypisania  parametrów  umieszczane  są  w
       środowisku polecenia, a nie tylko te, które poprzedzają  nazwę  polece‐
       nia.

       Gdy  bash  wywołuje  polecenie  zewnętrzne, zmienna _ ustawiana jest na
       pełną nazwę pliku  polecenia  i  przekazywana  temu  poleceniu  w  jego
       środowisku.

KOD ZAKOŃCZENIA
       Kod  zakończenia  wykonanego  polecenia  jest  wartością zwracaną przez
       wywołanie systemowe waitpid lub  funkcję  będącą  jego  odpowiednikiem.
       Kody  zakończenia  mieszczą  się w zakresie od 0 do 255, przy czym, jak
       wyjaśniono poniżej, powłoka może używać wartości powyżej 125  w  sposób
       specjalny.  Kod  zakończenia  z  wbudowanych  poleceń powłoki i poleceń
       złożonych  również  są  ograniczone   do   powyższego   przedziału.   W
       szczególnych  przypadkach, powłoka używa wartości specjalnych aby poin‐
       formować o konkretnym trybie błędu.

       Dla celów powłoki, polecenie, które zakończyło pracę  z  zerowym  kodem
       zakończenia, powiodło się. Zerowy kod oznacza powodzenie. Niezerowy kod
       oznacza niepowodzenie. Gdy polecenie kończy pracę z  błędem  krytycznym
       N, bash posługuje się wartością 128+N jako kodem zakończenia.

       Jeżeli  nie znaleziono polecenia, proces potomny powołany do jego wyko‐
       nania zwraca kod 127. Jeżeli polecenie zostało znalezione, ale nie jest
       wykonywalne, kod zakończenia wynosi 126.

       Jeżeli  polecenie nie powiodło się z powodu błędu podczas interpretacji
       lub przekierowania, kod zakończenia jest większy od zera.

       Wbudowane polecenia powłoki zwracają kod  0  (true  prawda)  jeśli  się
       powiodły,  i  niezerowy  (false  fałsz)  jeśli  podczas ich wykonywania
       pojawił się błąd.  Wszystkie polecenia wbudowane  zwracają  kod  2  dla
       wskazania niepoprawnego użycia.

       Sam  Bash zwraca kod zakończenia ostatniego wykonanego polecenia, chyba
       że pojawi się błąd składni, wówczas kończy pracą z wartością niezerową.
       Zobacz też poniżej polecenie wbudowane exit.

SYGNAŁY
       Gdy  bash  jest interaktywny, przy braku jakichkolwiek pułapek (przech‐
       wytywania sygnałów), ignoruje on SIGTERM (tak, że  kill  0  nie  zabija
       powłoki  interaktywnej),  a  SIGINT  jest  przechwytywany i obsługiwany
       (tak, że wbudowane polecenie wait daje się  przerwać).   We  wszystkich
       przypadkach, bash ignoruje SIGQUIT.  Jeżeli działa kontrola zadań, bash
       ignoruje SIGTTIN, SIGTTOU i SIGTSTP.

       Zadania synchroniczne uruchomione przez  bash  mają  procedury  obsługi
       sygnałów  (signal  handlers)  ustawione na wartości odziedziczone przez
       powłokę po rodzicu. Jeżeli nie pracuje  kontrola  zadań,  to  polecenia
       asynchroniczne  ignorują również SIGINT i SIGQUIT.  Polecenia uruchami‐
       ane wskutek  podstawiania  poleceń  ignorują  generowane  z  klawiatury
       sygnały kontroli zadań SIGTTIN, SIGTTOU i SIGTSTP.

       Powłoka  domyślnie  kończy pracę po otrzymaniu SIGHUP.  Przed zakończe‐
       niem, powłoka  interaktywna  rozsyła  otrzymany  SIGHUP  do  wszystkich
       zadań,  pracujących  lub  zatrzymanych.  Do zatrzymanych zadań wysyłany
       jest SIGCONT by  upewnić  się,  że  otrzymują  SIGHUP.   Chcąc  uniknąć
       wysłania sygnału przez powłokę do konkretnego zadania, należy usunąć je
       z tablicy  zadań  przy  pomocy  wbudowanego  polecenia  disown  (zobacz
       poniżej WBUDOWANE POLECENIA POWŁOKI)  lub oznakować, by nie otrzymywało
       SIGHUP, posługując się disown -h.

       Jeżeli przy pomocy shopt została  ustawiona  opcja  huponexit  powłoki,
       bash  wysyła  SIGHUP do wszystkich zadań, gdy kończy pracę interaktywna
       powłoka zgłoszeniowa.

       Gdy bash podczas oczekiwania na ukończenie polecenia otrzymuje  sygnał,
       dla  którego  ustawiono pułapkę, pułapka ta nie zostanie wykonana aż do
       zakończenia pracy polecenia.  Gdy bash oczekuje na polecenie asynchron‐
       iczne  za  pośrednictwem  wbudowanego wait, odbiór sygnału, dla którego
       ustawiono przechwytywanie  spowoduje,  że  wbudowane  wait  natychmiast
       skończy  pracę  z  kodem  większym od 128, po czym natychmiast zostanie
       wywołana pułapka.

KONTROLA ZADAŃ
       Kontrola zadań odnosi  się  do  możliwości  selektywnego  zatrzymywania
       (zawieszania  - suspend) wykonywania procesów i późniejszej kontynuacji
       (wznawiania - resume) ich wykonywania. Użytkownik  zwykle  wykorzystuje
       to  udogodnienie  za  pośrednictwem  interaktywnego interfejsu obsługi‐
       wanego wspólnie przez systemowy sterownik terminala i bash.

       Powłoka kojarzy z każdym potokiem zadanie.  Przechowuje tablicę aktual‐
       nie  wykonywanych  zadań,  którą  można  przeglądać za pomocą polecenia
       jobs.  Gdy bash uruchamia zadanie  asynchronicznie  (w  tle),  wypisuje
       wiersz w rodzaju:

              [1] 25647

       wskazujący,  że  zadanie to ma numer 1 a ID ostatniego procesu w potoku
       związanym z zadaniem wynosi 25647.  Wszystkie procesy w  jednym  potoku
       należą do tego samego zadania.  Bash posługuje się abstrakcją (abstrac‐
       tion) zadania jako podstawą kontroli zadań.

       Dla ułatwienia implementacji interfejsu użytkownika do kontroli  zadań,
       system  operacyjny utrzymuje pojęcie ID grupy procesów bieżącego termi‐
       nala (current terminal process group ID).  Elementy tej grupy  procesów
       (procesy,  których  ID  grupy  procesów  jest  równy  ID grupy procesów
       bieżącego terminala) otrzymują generowane z klawiatury  sygnały,  takie
       jak  SIGINT.   Mówimy,  że procesy te pracują pierwszoplanowo.  Procesy
       tła to takie, których ID grupy procesów różni się od terminala; procesy
       takie  są  odporne  na sygnały pochodzące z klawiatury.  Tylko procesom
       pierwszoplanowym wolno czytać i, jeśli użytkownik ustawi  stty  tostop,
       pisać  na  terminal.  Do procesów tła usiłujących czytać z (i pisać do,
       jeśli działa stty tostop) terminala wysyłany jest przez sterownik  ter‐
       minala  sygnał  SIGTTIN  (SIGTTOU),  który,  jeśli nie zostanie przech‐
       wycony, wstrzymuje proces.

       Jeżeli system operacyjny, na  którym  działa  bash  obsługuje  kontrolę
       zadań,  bash zawiera funkcje do jej wykorzystywania.  Naciśnięcie klaw‐
       isza wstrzymania (zwykle ^Z, Control-Z) podczas pracy procesu powoduje,
       że  proces  ten  zostanie  zatrzymany a sterowanie zostanie zwrócone do
       bash.  Naciśnięcie klawisza  opóźnione  wstrzymanie  (zwykle  ^Y,  Con‐
       trol-Y)  powoduje,  że proces zostanie zatrzymywany gdy będzie usiłował
       czytać wejście z terminala, a sterowanie powróci do  bash.   Użytkownik
       może następnie zmieniać stan takiego zadania, posługując się poleceniem
       bg do kontynuacji zadania w tle, fg do kontynuacji na pierwszym  planie
       lub  poleceniem  kill  do  zabicia zadania.  ^Z działa natychmiast i ma
       efekt uboczny: powoduje  odrzucenie  oczekującego  wyjścia  i  wprowad‐
       zonych, a nieprzetworzonych naciśnięć klawiszy (typeahead).

       Istnieje   kilka  sposobów  wskazywania  zadania  w  powłoce.   Znak  %
       poprzedza nazwę  zadania.  Zadanie  numer  n  można  wskazać  jako  %n.
       Zadanie może być też określone przez użycie przedrostka nazwy użytej do
       jego uruchomienia  lub  podłańcucha,  jaki  występuje  w  jego  wierszu
       poleceń.   Na  przykład,  %ce  odnosi  się  do zatrzymanego zadania ce.
       Jeśli przedrostek pasuje do więcej niż jednego  zadania,  bash  zgłasza
       błąd.  Z  drugiej  strony, użycie %?ce, wskazuje na zadanie zawierające
       podłańcuch ce w swym wierszu poleceń. Jeżeli łańcuch pasuje  do  więcej
       niż jednego zadania, bash zgłasza błąd. Symbole %% i %+ określają rozu‐
       miane przez powłokę bieżące zadanie, będące ostatnim  zadaniem  zatrzy‐
       manym,  gdy  było  na  pierwszym  planie  lub  uruchomionym  w tle.  Do
       poprzedniego zadania można odwoływać się przy  pomocy  %-.   W  wyjściu
       odnoszącym  się  do zadań (np. wyjście polecenia jobs), bieżące zadanie
       jest zawsze zaznaczone znakiem +, a zadanie poprzednie -. Pojedynczy  %
       (bez towarzyszącego określenia zadania) również odnosi się do bieżącego
       zadania.

       Do przywrócenia zadania na pierwszy plan można posłużyć się  po  prostu
       jego nazwą: %1 jest synonimem dla ,,fg %1”, przywracającego zadanie 1 z
       tła na pierwszy plan.  Podobnie, ,,%1  &”  wznawia  zadanie  1  w  tle,
       równoważnie do ,,bg %1””.

       Powłoka  natychmiast  dowiaduje się czy zadanie zmieniło stan.  Normal‐
       nie, bash czeka ze zgłoszeniem zmian  do  momentu,  gdy  ma  wyświetlić
       zachętę, by nie przerywać innego wyjścia. Jeżeli włączono opcję -b wbu‐
       dowanego polecenia set, bash zgłasza  takie  zmiany  natychmiast.   Dla
       każdego  kończącego  pracę procesu potomnego wykonywana jest ewentualna
       pułapka przechwytująca SIGCHLD.

       Jeżeli wykonano próbę zakończenia pracy bash przy istniejących  zatrzy‐
       manych  zadaniach  (lub,  gdy włączono opcję powłoki checkjobs używając
       wbudowanego shopt, działających zadaniach), powłoka wypisuje  komunikat
       ostrzegawczy  i, jeśli włączono opcję checkjobs wypisuje zadania wraz z
       ich stanem. Można wówczas posłużyć się poleceniem jobs  do  sprawdzenia
       ich  stanu.  Jeżeli  wykonywana  jest druga próba zakończenia pracy bez
       wystąpienia wtrąconego między nie polecenia, powłoka nie wypisuje kole‐
       jnego ostrzeżenia a zatrzymane zadania są przerywane.

ZACHĘTA POWŁOKI
       Przy  wykonywaniu  interaktywnym  bash  wyświetla główny symbol zachęty
       (primary prompt) PS1 kiedy jest gotowa na odczyt polecenia, zaś  wtórną
       (secondary)  zachętę  PS2  kiedy  potrzebuje więcej danych z wejścia do
       uzupełnienia polecenia.  Bash pozwala na dostosowywanie tych  łańcuchów
       zachęty  poprzez  wstawianie  wielu znaków specjalnych rozpoczynających
       się odwrotnym ukośnikiem, które są dekodowane jak następuje:
              \a     znak dzwonka ASCII (07)
              \d     data w formacie "DzieńTyg Miesiąc Dzień"  (np.  "Tue  May
                     26")
              \D{format}
                     format  jest  przekazywany  do  strftime(3), a wynik jest
                     wstawiany do łańcucha zachęty. Pusty format daje w wyniku
                     czas w lokalnym formacie. Nawiasy klamrowe są wymagane
              \e     znak escape ASCII (033)
              \h     nazwa hosta do pierwszej kropki `.'
              \H     nazwa hosta
              \j     liczba zadań aktualnie obsługiwanych przez powłokę
              \l     główna część nazwy urządzenia terminala powłoki
              \n     znak nowej linii
              \r     powrót karetki (carriage return)
              \s     nazwa   powłoki,   główna   część   nazwy   $0  (fragment
                     występujący po ostatnim ukośniku)
              \t     bieżący czas w formacie 24-godzinnym GG:MM:SS
              \T     bieżący czas w formacie 12-godzinnym GG:MM:SS
              \@     bieżący czas w 12-godzinnym formacie am/pm
              \A     bieżący czas w 24-godzinnym formacie GG:MM
              \u     nazwa bieżącego użytkownika (username)
              \v     wersja programu bash (np. 2.00)
              \V     wydanie bash, wersja+poziom łat (np., 2.00.0)
              \w     bieżący katalog roboczy,  z  $HOME  zapisanym  w  skrócie
                     tyldą (używa wartości ze zmiennej PROMPT_DIRTRIM)
              \W     główna  część nazwy bieżącego katalogu roboczego, z $HOME
                     zapisanym w skrócie tyldą
              \!     numer tego polecenia w historii
              \#     numer polecenia tego polecenia
              \$     jeżeli efektywnym UID jest 0, to #, w przeciwnym razie $
              \nnn   znak odpowiadający ósemkowej liczbie nnn
              \\     odwrotny ukośnik
              \[     początek sekwencji  znaków  niedrukowalnych,  która  może
                     służyć do osadzenia w zachęcie sekwencji sterujących ter‐
                     minalem
              \]     koniec sekwencji znaków niedrukowalnych

       Numer polecenia i numer w historii są zwykle różne: numer  polecenia  w
       historii  jest  jego  pozycją  na liście historii, która może obejmować
       polecenia odtworzone z pliku historii (zobacz poniżej  HISTORIA),  pod‐
       czas  gdy numer polecenia jest pozycją w sekwencji poleceń wykonanych w
       obecnej sesji powłoki.  Po zdekodowaniu,  łańcuch  jest  interpretowany
       poprzez  interpretację parametrów, podstawianie wyników poleceń, inter‐
       pretację wyrażeń arytmetycznych,  interpretację  łańcuchów  i  usuwanie
       cytowań,  zgodnie  z  wartością  opcji  promptvars powłoki (zobacz opis
       polecenia shopt w sekcji WBUDOWANE POLECENIA POWŁOKI poniżej).

READLINE
       Jest to biblioteka obsługująca odczytywanie wejścia podczas  posługiwa‐
       nia  się  powłoką  interaktywną, chyba że przy wywołaniu powłoki podano
       opcję --noediting.  Domyślnie, polecenia edycji wiersza są  podobne  do
       występujących w macsie.  Dostępny jest także interfejs edycji wiersza w
       stylu vi.  Edycja wiersza może zostać włączona w dowolnym czasie,  przy
       użyciu  opcji -o emacs lub -o vi wbudowanego polecenia set. By wyłączyć
       edycję wiersza po uruchomieniu powłoki, użyj opcji +o emacs lub  +o  vi
       wbudowanego polecenia set (zobacz WBUDOWANE POLECENIA POWŁOKI poniżej).

   Notacja Readline
       W tej sekcji, do zapisu naciśnięć klawiszy używana jest notacja w stylu
       emacsa. Klawisze Control zapisywane są jako C-klawisz, np., C-n oznacza
       Control-N.  Podobnie, meta klawisze zapisywane są jako M-klawisz, zatem
       M-x oznacza Meta-X.  (Na klawiaturach bez klawisza meta M-x oznacza ESC
       x,  tj.  naciśnij  klawisz  Escape a następnie klawisz x.  Czyni to ESC
       przedrostkiem meta (meta prefix).  Kombinacja  M-C-x  oznacza  ESC-Con‐
       trol-x, lub naciśnij klawisz Escape, następnie przytrzymaj klawisz Con‐
       trol podczas naciskania klawisza x.)

       Poleceniom readline można podawać numeryczne argumenty, które normalnie
       działają  jako  licznik  powtórzeń.  Czasami jednak, znaczący jest znak
       argumentu. Przekazanie ujemnego argumentu  poleceniu,  które  działa  w
       przód  (np.  kill-line)  powoduje,  że  będzie  ono  działać  odwrotnym
       kierunku (wstecz).  Polecenia, których zachowanie z argumentami odbiega
       od podanego odnotowano poniżej.

       Gdy  polecenie  opisano  jako usuwające (killing) tekst, tekst ten jest
       zachowywany to ewentualnego późniejszego odzyskania (przywołania  yank‐
       ing).  Kolejne  usunięcia  powodują,  że  tekst  jest  zbierany w jedną
       całość, którą można odzyskać naraz. Polecenia nie usuwające tekstu odd‐
       zielają kawałki tekstu w stosie usuwania (killing ring).

   Inicjalizacja Readline
       Readline  dostosowywane  jest przy pomocy poleceń umieszczanych w pliku
       inicjującym (plik inputrc).  Nazwa tego pliku  brana  jest  z  wartości
       zmiennej INPUTRC.  Jeżeli zmienna ta nie jest ustawiona, domyślną nazwą
       jest ~/.inputrc.  Gdy startuje program używający  biblioteki  readline,
       odczytywany  jest  plik  inicjujący,  po  czym ustawiane są przypisania
       klawiszy i zmienne.  Istnieje tylko kilka podstawowych konstrukcji doz‐
       wolonych  w  pliku  inicjacji  readline.   Puste wiersze są ignorowane.
       Wiersze rozpoczynające się od #  są  komentarzami.   Wiersze  rozpoczy‐
       nające  się  od  $  wskazują  konstrukcje warunkowe.  Inne wiersze wyz‐
       naczają przypisania klawiszy i ustawienia zmiennych.

       Domyślne przypisania klawiszy można zmienić przy pomocy pliku  inputrc.
       Inne programy posługujące się tą biblioteką mogą dodawać własne polece‐
       nia i przypisania.

       Na przykład, umieszczenie

              M-Control-u: universal-argument
       lub
              C-Meta-u: universal-argument
       w inputrc spowodowałoby, że M-C-u wywoływałoby polecenie readline  uni‐
       versal-argument.

       Rozpoznawane są następujące symboliczne nazwy znaków: RUBOUT, DEL, ESC,
       LFD, NEWLINE, RET, RETURN, SPC, SPACE i TAB.

       Oprócz nazw poleceń readline pozwala przypisywać klawisze do  łańcucha.
       Łańcuch ten zostanie wstawiony po naciśnięciu klawisza (makro).

   Przypisania klawiszy Readline
       Składnia  przypisań  klawiszy  sterujących w pliku inputrc jest prosta.
       Wymagana jest wyłącznie nazwa polecenia lub  tekst  makra  i  sekwencja
       klawiszy, do której powinno być przypisane. Klawisze mogą być podane na
       dwa sposoby: jako symboliczna nazwa klawisza, może być z  przedrostkami
       Meta- lub Control-, lub jako sekwencja klawiszy.

       Przy użyciu postaci nazwa-klaw:nazwa-funkcji lub makro, nazwa-klaw jest
       nazwą klawisza zapisaną w jęz.angielskim. Na przykład:

              Control-u: universal-argument
              Meta-Rubout: backward-kill-word
              Control-o: "> output"

       W powyższym przykładzie, C-u przypisane jest do funkcji universal-argu‐
       ment,  M-DEL przypisane jest do funkcji backward-kill-word a C-o przyp‐
       isane do uruchamiania makra wyrażonego po prawej (to  jest,  wstawiania
       tekstu ``> output'' w wiersz).

       W drugiej postaci, "sekw-klaw":nazwa-funkcji lub makro, sekw-klaw różni
       się od nazwa-klaw powyżej tym, że przez umieszczenie sekwencji  w  cud‐
       zysłowach  można  podać  łańcuchy  oznaczające całą sekwencję klawiszy.
       Można  posłużyć  się  niektórymi  kombinacjami  klawiszy  w  stylu  GNU
       Emacs-a,  jak  w poniższym przykładzie, nie są jednak rozpoznawane sym‐
       boliczne nazwy znaków:

              "\C-u": universal-argument
              "\C-x\C-r": re-read-init-file
              "\e[11~": "Klawisz funkcyjny 1"

       W tym przykładzie, C-u jest  ponownie  przypisane  do  funkcji  univer‐
       sal-argument.   C-x  C-r  przypisane jest do funkcji re-read-init-file,
       zaś ESC [ 1 1 ~ przypisane jest do  wstawienia  tekstu  ``Function  Key
       1''.

       Oto pełny zestaw sekwencji specjalnych w stylu GNU Emacs
              \C-    przedrostek control
              \M-    przedrostek meta
              \e     znak escape
              \\     odwrotny ukośnik (backslash)
              \"     dosłowny cudzysłów "
              \'     dosłowny apostrof '

       Oprócz  sekwencji  specjalnych  w stylu GNU Emacsa, dostępny jest drugi
       zestaw sekwencji z użyciem odwrotnego ukośnika:
              \a     alarm (dzwonek)
              \b     backspace
              \d     delete
              \f     znak wysuwu strony (form feed)
              \n     znak nowej linii
              \r     powrót karetki (carriage return)
              \t     tabulacja pozioma (horizontal tab)
              \v     tabulacja pionowa (vertical tab)
              \nnn   ośmiobitowy znak, którego wartością jest ósemkowa  liczba
                     nnn (jedna do trzech cyfr)
              \xHH   ośmiobitowy  znak,  którego  wartością  jest szesnastkowa
                     liczba nnn (jedna lub dwie cyfry szesnastkowe)

       Podczas wprowadzania tekstu makra, do wskazania  jego  definicji  muszą
       być  użyte  pojedyncze  lub podwójne cudzysłowy.  Zakłada się, że tekst
       niecytowany jest nazwą funkcji.  W ciele makra interpretowane  są  sek‐
       wencje   specjalne  z  użyciem  odwrotnego  ukośnika  opisane  powyżej.
       odwrotny ukośnik cytuje dowolny inny znak w tekście makra, łącznie z  "
       i '.

       Bash umożliwia wyświetlanie i zmianę bieżących przypisań klawiszy read‐
       line  za  pomocą  wbudowanego  polecenia  bind.   Tryb   edycji   można
       przełączać  podczas  używania interaktywnego przez posłużenie się opcją
       -o  wbudowanego  polecenia  set  (zobacz  poniżej  WBUDOWANE  POLECENIA
       POWŁOKI).

   Zmienne Readline
       Readline  posiada  zmienne,  których  można  używać do dodatkowego dos‐
       tosowania jej zachowania. Zmienna może być ustawiana  w  pliku  inputrc
       przy pomocy instrukcji postaci

              set nazwa-zmiennej wartość

       Z  wymienionymi  niżej  wyjątkami,  zmienne  readline  mogą  przyjmować
       wartości On lub Off (wielkość znaków nie ma  znaczenia).  Nierozpoznane
       nazwy  zmiennych  są ignorowane. Gdy odczytywana jest wartość zmiennej,
       puste lub wyzerowane wartości, "on" (bez względu na wielkość  liter)  i
       "1" są równoważne On. Wszystkie pozostałe wartości są równoważne Off. A
       oto zmienne i ich wartości domyślne:

       bell-style (audible)
              Kontroluje,  co  dzieje  się  gdy  readline  chce  użyć  sygnału
              dźwiękowego  terminala.  Jeśli ustawiona na none, readline nigdy
              nie emituje  sygnału.   Jeśli  ustawiona  na  visible,  readline
              posługuje  się "widzialnym dzwonkiem" (visible bell), jeśli jest
              dostępny.  Jeżeli ustawiona na audible, readline usiłuje uzyskać
              sygnał dźwiękowy z terminala.
       bind-tty-special-chars (On)
              Jeśli  ustawiona  na On, readline będzie próbował przypiąć znaki
              kontrolne traktowane w sposób specjalny przez  sterownik  termi‐
              nala jądra do ich odpowiedników readline.
       comment-begin (,,#”)
              Łańcuch  wstawiany, gdy wykonywane jest polecenie insert-comment
              readline.  Polecenie to jest przypisane do M-# w  trybie  emacs,
              zaś do # w trybie vi.
       completion-ignore-case (Off)
              Jeżeli  ustawiona  na  On,  readline  wykonuje  dopasowywanie  i
              uzupełnianie nazw plików bez rozróżniania wielkości liter.
       completion-prefix-display-length (0)
              Długość  (w  znakach)  wspólnego  przedrostka  listy   możliwych
              uzupełnień,  które  są  wyświetlane  bez  modyfikacji.  Gdy jest
              ustawiona  na  wartość  większą  od  zera,  wspólne  przedrostki
              dłuższe  od  tej  wartości  są zastępowane wielokropkiem podczas
              wyświetlania dostępnych uzupełnień.
       completion-query-items (100)
              Określa, kiedy użytkownik jest pytany o oglądanie takiej  liczby
              możliwych uzupełnień tworzonych przez polecenie possible-comple‐
              tions.  Może być ustawiona na dowolną liczbę  całkowitą  większą
              lub równą zero.  Jeżeli liczba możliwych uzupełnień jest większa
              bądź równa wartości tej zmiennej, to użytkownik jest pytany  czy
              chce je oglądnąć; w przeciwnym razie są one po prostu pokazywane
              na terminalu.
       convert-meta (On)
              Jeśli ustawione na On, readline będzie zamieniał znaki z  ustaw‐
              ionym  ósmym  bitem  na  sekwencje klawiszy ASCII przez obcięcie
              ósmego bitu i poprzedzenie znakiem escape (w  efekcie,  używając
              escape jako przedrostka meta).
       disable-completion (Off)
              Jeśli ustawione na On, readline zabroni uzupełniania słów. Znaki
              uzupełniania zostaną  wstawione  w  wiersz  tak,  jakby  zostały
              przypisane do self-insert.
       editing-mode (emacs)
              Kontroluje  czy  readline  rozpoczyna pracę z zestawem przypisań
              klawiszy podobnym do emacs czy do  vi.   editing-mode  może  być
              ustawiane albo na emacs albo na vi.
       echo-control-characters (On)
              Jeśli  ustawione  na  On,  readline wyświetla znak odpowiadający
              sygnałowi otrzymanemu z klawiatury, w systemach które  informują
              o obsługiwaniu tej właściwości.
       enable-keypad (Off)
              Gdy  jest  ustawione  na  On,  readline  będzie usiłować włączyć
              numeryczny blok klawiatury (application keypad) przy  wywołaniu.
              Niektóre systemy potrzebują tego do włączenia klawiszy strzałek.
       enable-meta-key (On)
              Gdy  jest  ustawiona  na  On,  readline próbuje włączyć dostępne
              modyfikujące klawisze meta, o których obsługiwaniu zapewnia ter‐
              minal, gdy są wywoływane. Na wielu terminalach meta klawisz jest
              używany do wysyłania znaków ośmiobitowych.
       expand-tilde (Off)
              Jeżeli ustawione na On, podczas próby uzupełniania słów readline
              wykonuje interpretację tyldy.
       history-preserve-point (Off)
              Ustawione  na  on  powoduje,  że  kod  obsługi  historii poleceń
              usiłuje w każdym wierszu poleceń  odzyskanym  za  pomocą  previ‐
              ous-history  lub  next-history  umieścić  punkt (bieżącą pozycję
              kursora) w tym samym miejscu.
       history-size (0)
              Ustawia maksymalną liczbę wpisów historii zapisywanych w  liście
              historii.  Gdy  jest  ustawiona  na zero, liczba wpisów w liście
              historii jest nieograniczona.
       horizontal-scroll-mode (Off)
              Ustawione na On powoduje, że readline do wyświetlania  posługuje
              się  pojedynczym  wierszem.  Jeśli wejście jest dłuższe niż sze‐
              rokość ekranu, to  jego  zawartość  jest  wówczas  przewijana  w
              poziomie  w  pojedynczym  wierszu  ekranu,  zamiast zawijania do
              następnego wiersza.
       input-meta (Off)
              Jeśli ustawiona na On, readline dopuści ośmiobitowe wejście  (to
              znaczy,  nie będzie obcinać ósmego bitu z odczytywanych znaków),
              bez względu na to, co twierdzi terminal  o  możliwości  obsługi.
              Nazwa meta-flag jest synonimem tej zmiennej.
       isearch-terminators (,,C-[C-J”)
              Łańcuch  znaków,  który  powinien przerywać wyszukiwanie krokowe
              (incremental search) bez  późniejszego  wykonywania  znaku  jako
              polecenia.  Jeżeli zmiennej tej nie nadano wartości, to wyszuki‐
              wanie krokowe będą przerywać ESC i C-J.
       keymap (emacs)
              Ustawia  bieżące  mapowanie   klawiatury   readline.   Zestawami
              poprawnych   mapowań   są   emacs,  emacs-standard,  emacs-meta,
              emacs-ctlx, vi, vi-command i vi-insert.  vi jest  równoważnikiem
              dla  vi-command;  emacs jest równoważne emacs-standard. Domyślną
              wartością jest emacs; wartość  editing-mode  również  wpływa  na
              domyślne mapowanie.
       mark-directories (On)
              Jeżeli  ustawione  na  On,  to  uzupełniane nazwy katalogów mają
              dołączany końcowy ukośnik.
       mark-modified-lines (Off)
              Jeżeli  ustawione  na  On,  wiersze  historii,   które   zostały
              zmienione wyświetlane są z poprzedzającą je gwiazdką (*).
       mark-symlinked-directories (Off)
              Gdy  ustawiona na On, uzupełniane nazwy będące dowiązaniami sym‐
              bolicznymi do katalogów, mają dodany  znak  ukośnika  (przedmiot
              wartości mark-directories).
       match-hidden-files (On)
              Ta  zmienna,  gdy  jest  ustawiona  na On, powoduje, że readline
              wykonując uzupełnianie nazw  plików  dopasowuje  pliki,  których
              nazwy  zaczynają się od kropki `.' (pliki ukryte). Gdy ustawiona
              na Off, początkowa kropka w nazwie jaka ma być uzupełniona, musi
              być wpisana przez użytkownika.
       menu-complete-display-prefix (Off)
              Gdy  ustawiona  na On, uzupełnianie menu wyświetla wspólny prze‐
              drostek listy możliwych uzupełnień (który może być pusty)  przed
              cyklicznym przełączaniem się między pozycjami z listy.
       output-meta (Off)
              Jeżeli  ustawione  na  On, readline wyświetla znaki z ustawionym
              ósmym bitem wprost zamiast jako sekwencje specjalne z meta-prze‐
              drostkiem.
       page-completions (On)
              Gdy  ustawione  na  On,  readline  używa  wewnętrznego  programu
              wyświetlającego  podobnego  do  more,  do  wyświetlania  pełnego
              ekranu możliwych uzupełnień na raz.
       print-completions-horizontally (Off)
              Jeżeli   ustawione   na   On,   readline   wyświetla  dopasowane
              uzupełnienia w kolejności alfabetycznej poziomo, zamiast  w  dół
              ekranu.
       revert-all-at-newline (Off)
              Gdy  ustawione  na On, readline anuluje wszystkie zmiany w wier‐
              szach historii przed powrotem, gdy wykonywane jest  accept-line.
              Domyślnie, wiersze historii mogą zostać zmodyfikowane i zachować
              swe listy anulowań poprzez odwołania do readline.
       show-all-if-ambiguous (Off)
              Zmienia to domyślne zachowanie funkcji uzupełniania. Jeżeli jest
              ustawione  na  on,  to  słowa  mające  więcej  niż jedno możliwe
              uzupełnienie powodują, że natychmiast zostaną podane dopasowania
              zamiast wyemitowania sygnału dźwiękowego.
       show-all-if-unmodified (Off)
              Zmienna  modyfikuje  domyślne  zachowanie funkcji uzupełnienia w
              sposób podobny do show-all-if-ambiguous. Gdy jest  ustawiona  na
              On,  słowa  które mają więcej niż jedno możliwe uzupełnienie bez
              możliwych uzupełnień częściowych (możliwe uzupełnienia nie posi‐
              adają  wspólnego  przedrostka),  są  wypisywane natychmiast, bez
              wcześniejszego używania brzęczyka.
       skip-completed-text (Off)
              Gdy  jest  ustawiona  na  On,  modyfikuje  domyślne   zachowanie
              uzupełniania  gdy  do  wiersza  wstawiane  jest pojedyncze dopa‐
              sowanie.  Jest  to   aktywne   tylko   podczas   przeprowadzania
              uzupełnienia  w  środku  słowa.  Gdy jest włączona, readline nie
              wstawia znaków z uzupełniania, które pasują do znaków w  miejscu
              wprowadzania w uzupełnianym słowie, dzięki czemu części słowa za
              kursorem, nie są duplikowane.
       visible-stats (Off)
              Jeżeli  ustawione  na  On,  to   przy   wyświetlaniu   możliwych
              uzupełnień  do  nazwy  pliku zostanie dołączony znak określający
              typ pliku wskazywany przez stat(2).

   Konstrukcje warunkowe Readline
       Readline implementuje udogodnienie podobne duchem do funkcji kompilacji
       warunkowej  preprocesora  C, pozwalające na wykonywanie przypisań klaw‐
       iszy i ustawień zmiennych w zależności od  wyniku  testów.  Używane  są
       cztery dyrektywy analizatora składni.

       $if    Konstrukcja  $if pozwala na wykonanie przypisań klawiszy w opar‐
              ciu o tryb edycji, używany terminal lub aplikację korzystającą z
              readline.  Tekst  testu  rozciąga  się do końca wiersza; do jego
              wydzielenia nie są wymagane żadne znaki.

              mode   Postać mode= dyrektywy $if służy do sprawdzania czy read‐
                     line jest w trybie emacs czy vi. Może być wykorzystywana,
                     na przykład, w połączeniu z  poleceniem  set  keymap,  do
                     ustawienia   przypisań  w  mapowaniach  emacs-standard  i
                     emacs-ctlx tylko jeśli readline uruchamia  się  w  trybie
                     emacs.

              term   Postać  term=  można  wykorzystywać  do  włączenia specy‐
                     ficznych dla terminala przypisań klawiszy,  być  może  do
                     przypisania  wyjścia  dla  sekwencji klawiszy funkcyjnych
                     terminala. Słowo po prawej stronie =  sprawdzane  jest  z
                     zarówno  pełną nazwą terminala, jaki i częścią jego nazwy
                     przed pierwszym -. Umożliwia to, na przykład, dopasowanie
                     przez sun zarówno sun jak i sun-cmd.

              aplikacja
                     Konstrukcja  aplikacja służy do włączania ustawień specy‐
                     ficznych dla aplikacji. Każdy program korzystający z bib‐
                     lioteki  readline  ustawia  nazwę  aplikacji (application
                     name), a plik inicjujący może sprawdzić czy ma ona  jakąś
                     szczególną wartość.  Może to być używane do przypisywania
                     sekwencji klawiszy funkcjom przydatnym w danym programie.
                     Na przykład, poniższe polecenie dodaje sekwencję klawiszy
                     wykonującą w bash cytowanie  bieżącego  lub  poprzedniego
                     słowa:

                     $if Bash
                     # Cytuj bieżące lub poprzednie słowo
                     "\C-xq": "\eb\"\ef\""
                     $endif

       $endif Polecenie to, jak widać w poprzednim przykładzie, kończy wykony‐
              wanie polecenia $if.

       $else  Polecenia w tej gałęzi  dyrektywy  $if  wykonywane  są  gdy  nie
              powiedzie się sprawdzenie warunku.

       $include
              Dyrektywa  ta  pobiera  jako  argument  pojedynczą nazwę pliku i
              odczytuje polecenia i przypisania z  tego  pliku.  Na  przykład,
              poniższa dyrektywa odczytałaby /etc/inputrc:

              $include  /etc/inputrc

   Wyszukiwanie
       Readline  zapewnia polecenia do wyszukiwania w historii poleceń (zobacz
       poniżej HISTORIA)  wierszy zawierających zadany łańcuch.  Istnieją  dwa
       tryby  wyszukiwania: krokowy (incremental) i nie-niekrokowy (non-incre‐
       mental).

       Wyszukiwania krokowe rozpoczynają  się  przed  zakończeniem  wpisywania
       przez   użytkownika  szukanego  tekstu.   Po  wpisaniu  każdego  znaków
       szukanego  łańcucha  readline  wyświetla  następną   pozycję   historii
       pasującą  do  wpisanego  do  tej  pory  łańcucha.  Wyszukiwanie krokowe
       wymaga tylko tylu znaków ile potrzebne jest  do  znalezienia  pożądanej
       pozycji historii.  Znaki występujące w wartości zmiennej isearch-termi‐
       nators służą do przerwania wyszukiwania krokowego.  Jeżeli  zmienna  ta
       nie  ma przypisanej wartości, to wyszukiwanie przerywają znaki Escape i
       Control-J.  Control-G porzuca wyszukiwanie krokowe  i  przywraca  pier‐
       wotny  wiersz.   Gdy  przerwie  się wyszukiwanie, pozycja historii zaw‐
       ierająca poszukiwany łańcuch staje się bieżącym wierszem.

       W  celu  odnalezienia  innych  pasujących  pozycji,   należy   nacisnąć
       odpowiednio  Control-S  lub Control-R.  Wyszukuje to wstecz lub w przód
       kolejną pasującą do dotychczas  wpisanego  łańcucha  pozycję  historii.
       Wszystkie inne sekwencje klawiszy przypisane do polecenia readline prz‐
       erywają wyszukiwanie i wykonują zadane polecenie.   Na  przykład,  znak
       nowej   linii  przerywa  wyszukiwanie  i  akceptuje  wiersz,  wykonując
       skutkiem tego polecenie z listy historii.

       Readline pamięta łańcuch użyty w ostatnim wyszukiwaniu krokowym. Jeżeli
       Control-R  zostanie  naciśnięte  dwa  razy,  bez  wprowadzenia pomiędzy
       naciśnięciami innych znaków definiujących  nowy  łańcuch  szukania,  to
       wykorzystywany jest uprzednio zapamiętany łańcuch.

       Wyszukiwania   nie-krokowe   czytają   cały   szukany   łańcuch   przed
       rozpoczęciem wyszukiwania pasujących wierszy historii. Łańcuch może być
       wpisany przez użytkownika lub być częścią zawartości bieżącego wiersza.

   Nazwy poleceń Readline
       Poniżej  podano  listę nazw poleceń i domyślnych sekwencji klawiszy, do
       których są one przypisane.  Nazwy poleceń bez  towarzyszącej  sekwencji
       klawiszy  są  domyślnie  nieprzypisane.   W  poniższych  opisach, punkt
       oznacza bieżącą pozycję kursora, zaś  zaznaczenie  do  pozycji  kursora
       zapamiętanej  przez  polecenie set-mark.  Tekst pomiędzy punktem a zaz‐
       naczeniem nazywany jest obszarem.

   Polecenia ruchu
       beginning-of-line (C-a)
              Przesuwa na początek bieżącego wiersza.
       end-of-line (C-e)
              Przesuwa na koniec wiersza.
       forward-char (C-f)
              Przesuwa o znak w przód.
       backward-char (C-b)
              Przesuwa o znak wstecz.
       forward-word (M-f)
              Przesuwa na koniec następnego słowa. Słowa złożone są ze  znaków
              alfanumerycznych (liter i cyfr).
       backward-word (M-b)
              Przesuwa  na  początek bieżącego, lub poprzedniego, słowa. Słowa
              złożone są ze znaków alfanumerycznych (liter i cyfr).
       shell-forward-word
              Przesuwa na koniec następnego słowa w przód. Słowa są oddzielone
              niecytowanymi metaznakami powłoki.
       shell-backward-word
              Przesuwa  na  początek  bieżącego  lub poprzedniego słowa w tył.
              Słowa są oddzielone niecytowanymi metaznakami powłoki.
       clear-screen (C-l)
              Czyści ekran pozostawiając bieżący wiersz  na  górze  ekranu.  Z
              argumentem, odświeża bieżący wiersz bez czyszczenia ekranu.
       redraw-current-line
              Odświeża bieżący wiersz.

   Polecenia operujące na historii
       accept-line (Newline, Return)
              Akceptuje  wiersz  bez względu na to, gdzie znajduje się kursor.
              Jeżeli wiersz ten nie jest pusty, to dodaje go do listy historii
              stosownie  do  stanu  zmiennej  HISTCONTROL.  Jeżeli wiersz jest
              zmienionym wierszem historii, to  odtwarza  wiersz  historii  do
              stanu pierwotnego.
       previous-history (C-p)
              Sprowadza poprzednie polecenie z listy historii, przesuwając się
              wstecz listy.
       next-history (C-n)
              Ściąga następne polecenie z listy historii, przesuwając  się  do
              przodu na liście.
       beginning-of-history (M-<)
              Przesuwa na pierwszy wiersz w historii.
       end-of-history (M->)
              Przesuwa   na   koniec   historii   wprowadzania,   tj.  obecnie
              wprowadzanego wiersza.
       reverse-search-history (C-r)
              Wyszukuje wstecz poczynając od bieżącego wiersza  i  przesuwając
              się,  w  razie potrzeby, 'w górę' historii. Jest to wyszukiwanie
              krokowe.
       forward-search-history (C-s)
              Wyszukuje w przód poczynając od bieżącego wiersza i  przesuwając
              się,  w  razie  potrzeby, 'w dół' historii. Jest to wyszukiwanie
              krokowe.
       non-incremental-reverse-search-history (M-p)
              Wyszukuje wstecz poczynając od bieżącego wiersza posługując  się
              wyszukiwaniem nie-krokowym podanego przez użytkownika łańcucha.
       non-incremental-forward-search-history (M-n)
              Wyszukuje w przód poczynając od bieżącego wiersza posługując się
              wyszukiwaniem nie-krokowym podanego przez użytkownika łańcucha.
       history-search-forward
              Wyszukuje w przód w historii łańcucha znaków pomiędzy początkiem
              bieżącego wiersza a punktem.  Jest to wyszukiwanie nie-krokowe.
       history-search-backward
              Wyszukuje  wstecz w historii łańcucha znaków pomiędzy początkiem
              bieżącego wiersza a bieżącą pozycją kursora  (punkt).   Jest  to
              wyszukiwanie nie-krokowe.
       yank-nth-arg (M-C-y)
              Wstawia  pierwszy argument poprzedniego polecenia (zwykle drugie
              słowo z poprzedniego wiersza) w punkt (bieżącą pozycję kursora).
              Z argumentem n, wstawia n-te słowo poprzedniego polecenia (słowa
              w poprzednim poleceniu  zaczynają  się  od  słowa  0).  Argument
              ujemny  wstawia  n-te  słowo od końca poprzedniego polecenia. Po
              obliczeniu argumentu n, jest on wyodrębniany w taki sposób,  jak
              gdyby podano opcję interpretowania historii "!n".
       yank-last-arg (M-., M-_)
              Wstawia  ostatni argument poprzedniego polecenia (ostatnie słowo
              poprzedniej  pozycji  historii).   Z   argumentem   numerycznym,
              zachowuje   się   dokładnie   tak,  jak  yank-nth-arg.   Kolejne
              wywołania yank-last-arg przesuwają wstecz listy historii, wstaw‐
              iając po kolei ostatni argument (lub słowo określone przez argu‐
              ment do pierwszego wywołania) każdego  wiersza.  Każdy  argument
              numeryczny podany do pomyślnego wywołania określa kierunek ruchu
              w historii. Argument ujemny zmienia kierunek poruszania  się  (w
              tył  lub  w przód). Możliwości interpretacji historii są używane
              do  wyodrębnienia  ostatniego  argumentu,  podobnie  jak   gdyby
              wybrano interpretację historii za pomocą "!$".
       shell-expand-line (M-C-e)
              Interpretuj  wiersz,  jak czyni to powłoka. Wykonuje to aliasy i
              interpretację historii, jak również interpretację słów  powłoki.
              Zobacz INTERPRETACJA HISTORII poniżej.
       history-expand-line (M-^)
              Wykonuje  interpretację powłoki w odniesieniu do bieżącego wier‐
              sza.  Zobacz INTERPRETACJA HISTORII poniżej.
       magic-space
              Wykonuje interpretację powłoki w odniesieniu do bieżącego  wier‐
              sza i wstawia spację.  Zobacz INTERPRETACJA HISTORII poniżej.
       alias-expand-line
              Wykonuje  interpretację aliasów w odniesieniu do bieżącego wier‐
              sza.  Zobacz ALIASY powyżej.
       history-and-alias-expand-line
              Wykonuje interpretację  historii  i  aliasów  w  odniesieniu  do
              bieżącego wiersza.
       insert-last-argument (M-., M-_)
              Synonim yank-last-arg.
       operate-and-get-next (C-o)
              Akceptuje  do  wykonania  bieżący  wiersz  i  ściąga  do  edycji
              następny względem bieżącego  wiersz  z  historii.  Argumenty  są
              ignorowane.
       edit-and-execute-command (C-xC-e)
              Przywołuje  edytor  w  bieżącym wierszu poleceń i wykonuje wynik
              jako polecenie powłoki. Bash stara się wywołać $VISUAL,  $EDITOR
              i emacs jako edytor, w tej kolejności.

   Polecenia zmiany tekstu
       delete-char (C-d)
              Usuwa   znak  w  punkcie  (pod  kursorem).   Jeżeli  punkt  jest
              początkiem wiersza, nie ma żadnych znaków w wierszu,  a  ostatni
              wpisany znak został przypisany do delete-char, to zwraca EOF.
       backward-delete-char (Rubout)
              Usuwa  znak  przed  kursorem. Jeżeli podano argument numeryczny,
              zachowuje usunięty tekst na stosie usunięć.
       forward-backward-delete-char
              Usuwa znak pod kursorem, chyba że kursor znajduje się  na  końcu
              wiersza, wówczas usuwany jest znak przed kursorem.
       quoted-insert (C-q, C-v)
              Dodaje  następny  znak do wiersza dosłownie. W ten sposób wstaw‐
              iane są znaki takie, jak na przykład C-q.
       tab-insert (C-v TAB)
              Wstawia znak tabulacji.
       self-insert (a, b, A, 1, !, ...)
              Wstawia wpisany znak.
       transpose-chars (C-t)
              Zamienia miejscami znak sprzed  punktu  ze  znakiem  w  punkcie,
              równocześnie  przesuwając  punkt  w  przód. Jeżeli punkt jest na
              końcu wiersza to zamienia to miejscami dwa znaki przed  punktem.
              Argumenty ujemne nie skutkują.
       transpose-words (M-t)
              Zamienia  miejscami  słowo  sprzed  punktu ze słowem za punktem,
              przesuwając  równocześnie  punkt  za  przesunięte  sprzed  niego
              słowo.  Jeżeli punkt jest na końcu wiersza to zamienia to miejs‐
              cami dwa ostanie słowa wiersza.
       upcase-word (M-u)
              Zamienia na wielkie litery bieżące (lub następne) słowo. Z argu‐
              mentem  ujemnym zamienia na wielkie litery poprzednie słowo, ale
              nie przesuwa punktu.
       downcase-word (M-l)
              Zamienia na małe litery bieżące (lub następne)  słowo.  Z  argu‐
              mentem ujemnym zamienia na małe litery poprzednie słowo, ale nie
              przesuwa punktu.
       capitalize-word (M-c)
              Zamienia na kapitaliki (pierwsza litera wielka, pozostałe  małe)
              bieżące (następne) słowo. Z argumentem ujemnym zamienia na kapi‐
              taliki poprzednie słowo, ale nie przesuwa punktu.
       overwrite-mode
              Przełącza  tryb  nadpisywania.  Z  jawnym,  dodatnim  argumentem
              liczbowym,  przełącza do trybu nadpisywania. Z jawnym, niedodat‐
              nim argumentem liczbowym, przełącza do trybu wstawiania. Polece‐
              nie  dotyczy  jedynie  trybu  emacs,  tryb  vi  nadpisuje w inny
              sposób. Każde odwołania do readline() jest uruchamiane w  trybie
              wstawiania.   W   trybie   nadpisywania,   znaki  przypisane  do
              self-insert zastępują tekst pod kursorem, zamiast przesuwać go w
              prawą stronę. Znaki przypisane do backward-delete-char zastępują
              znak przed kursorem spacją. Domyślnie,  to  polecenie  nie  jest
              przypisane.

   Usuwanie i wklejanie
       kill-line (C-k)
              Usuwa tekst od punktu do końca wiersza.
       backward-kill-line (C-x Rubout)
              Usuwa wstecz do początku wiersza.
       unix-line-discard (C-u)
              Usuwa  wstecz  od punktu do początku wiersza. Usuwany tekst jest
              zachowywany na stosie usunięć.
       kill-whole-line
              Usuwa  wszystkie  znaki  bieżącego  wiersza,  bez   względu   na
              położenie punktu.
       kill-word (M-d)
              Usuwa  od  punktu  do  końca  bieżącego  słowa,  lub jeśli użyte
              pomiędzy słowami, do końca następnego  słowa.  Granice  słów  są
              takie same, jak używane przez forward-word.
       backward-kill-word (M-Rubout)
              Usuwa  słowo  sprzed  punktu.  Granice  słów  są takie same, jak
              używane przez backward-word.
       shell-kill-word (M-d)
              Usuwa od kursora do końca bieżącego słowa lub, jeśli kursor zna‐
              jduje  się  pomiędzy słowami, do końca następnego słowa. Granice
              słów są takie same, jak używane przez shell-forward-word.
       shell-backward-kill-word (M-Rubout)
              Usuwa słowo sprzed punktu.  Granice  słów  są  takie  same,  jak
              używane przez shell-backward-word.
       unix-word-rubout (C-w)
              Usuwa słowo sprzed punktu, jako separatora słów używając białych
              znaków.  Usunięty tekst zachowywany jest na stosie usunięć.
       unix-filename-rubout
              Usuwa słowo sprzed punktu, jako separatora słów używając białych
              znaków  i  ukośnika.Usunięty  tekst  zachowywany  jest na stosie
              usunięć.
       delete-horizontal-space (M-\)
              Usuwa wszystkie spacje i tabulatory wokół punktu.
       kill-region
              Usuwa tekst w bieżącym obszarze.
       copy-region-as-kill
              Kopiuje tekst obszaru do bufora usuwania.
       copy-backward-word
              Kopiuje słowo sprzed punktu do bufora usuwania.  Granice słów są
              takie same, jak dla backward-word.
       copy-forward-word
              Kopiuje   słowo  występujące  po  punkcie  do  bufora  usuwania.
              Granice słów są takie same, jak dla forward-word.
       yank (C-y)
              Wkleja wierzchołek stosu usunięć do bufora w punkcie (w  miejscu
              kursora).
       yank-pop (M-y)
              Obraca  stos  usunięć  i  wkleja  nowy wierzchołek. Działa tylko
              następując po yank lub yank-pop.

   Argumenty numeryczne
       digit-argument (M-0, M-1, ..., M--)
              Dodaje tę cyfrę do już składanego argumentu lub rozpoczyna  nowy
              argument.  M-- rozpoczyna argument ujemny.
       universal-argument
              Jest  to inna metoda podawania argumentu.  Jeżeli po tym polece‐
              niu występuje jedna lub więcej cyfr, z  opcjonalnym  początkowym
              znakiem  minus,  to  cyfry  te  definiują  argument.   Jeżeli po
              poleceniu występują cyfry, to powtórne wykonanie universal-argu‐
              ment  kończy  argument numeryczny, ale w przeciwnym wypadku jest
              ignorowane.  W przypadku specjalnym, jeżeli bezpośrednio po  tym
              poleceniu występuje znak nie będący ani cyfrą ani znakiem minus,
              to argument licznik dla następnego polecenia mnożony jest  przez
              cztery.   Argument  licznik [zwykle powtórzeń] wynosi początkowo
              cztery, toteż wykonanie tej funkcji po raz  pierwszy  nadaje  mu
              wartość cztery, po raz drugi szesnaście, i tak dalej.

   Uzupełnianie
       complete (TAB)
              Usiłuje  przeprowadzić  uzupełnianie tekstu przed punktem.  Bash
              próbuje  uzupełniania  traktując  tekst  kolejno:  jako  zmienną
              (jeżeli  tekst zaczyna się od $), nazwę użytkownika (jeśli tekst
              zaczyna się od ~), nazwę hosta (jeśli tekst zaczyna  się  od  @)
              lub  polecenie  (łącznie z aliasami i funkcjami). Jeżeli żadne z
              powyższych nie daje dopasowania, to próbowane jest  uzupełnianie
              nazw plików.
       possible-completions (M-?)
              Pokazuje możliwe uzupełnienia tekstu przed punktem.
       insert-completions (M-*)
              Wstawia  przed  punktem  wszystkie  uzupełnienia  tekstu,  które
              zostałyby wygenerowane przez possible-completions.
       menu-complete
              Podobne do  complete,  ale  zastępuje  słowo,  jakie  ma  zostać
              uzupełnione  pojedynczym  uzupełnieniem z listy możliwych.  Pow‐
              tarzane wykonanie menu-complete powoduje  krokowe  przechodzenie
              przez  listę możliwych uzupełnień i wstawianie każdego z nich po
              kolei (zamiast uzupełnianego słowa).  Na końcu listy  uzupełnień
              emitowany   jest   sygnał   dźwiękowy   (zależny  od  ustawienia
              bell-style) i przywracany  jest  pierwotny  tekst.   Argument  n
              przesuwa  n  pozycji w przód na liście dopasowań; do przesuwania
              się wstecz można użyć argumentu ujemnego. Polecenie w  zamierze‐
              niu  ma  być  przypisane do klawisza TAB, ale domyślnie nie jest
              przypisane.
       menu-complete-backward
              Podobne do menu-complete, ale przemieszcza się wstecz po  liście
              możliwych  uzupełnień,  identycznie  gdyby  menu-complete podano
              ujemny argument. To polecenie jest domyślnie nieprzypisane.
       delete-char-or-list
              Usuwa znak pod kursorem, jeśli nie jest to początek bądź  koniec
              wiersza (jak delete-char). Na końcu wiersza, zachowuje się iden‐
              tycznie jak possible-completions. To  polecenie  jest  domyślnie
              nieprzypisane.
       complete-filename (M-/)
              Usiłuje  wykonać uzupełnianie nazw plików na tekście sprzed kur‐
              sora.
       possible-filename-completions (C-x /)
              Pokazuje możliwe uzupełnienia tekstu sprzed  kursora,  traktując
              go jak nazwę pliku.
       complete-username (M-~)
              Usiłuje wykonać uzupełnianie tekstu sprzed kursora, traktując go
              jak nazwę użytkownika.
       possible-username-completions (C-x ~)
              Pokazuje możliwe uzupełnienia tekstu sprzed  kursora,  traktując
              go jak nazwę użytkownika.
       complete-variable (M-$)
              Usiłuje wykonać uzupełnianie tekstu sprzed kursora, traktując go
              jak zmienną powłoki.
       possible-variable-completions (C-x $)
              Pokazuje możliwe uzupełnienia tekstu sprzed  kursora,  traktując
              go jak zmienną powłoki.
       complete-hostname (M-@)
              Usiłuje wykonać uzupełnianie tekstu sprzed kursora, traktując go
              jak nazwę hosta.
       possible-hostname-completions (C-x @)
              Pokazuje możliwe uzupełnienia tekstu sprzed  kursora,  traktując
              go jak nazwę hosta.
       complete-command (M-!)
              Usiłuje  uzupełnić  tekst  sprzed punktu, traktując go jak nazwę
              polecenia.  Uzupełnianie polecenia próbuje dopasować tekst kole‐
              jno  do  aliasów,  słów  zastrzeżonych, funkcji powłoki, poleceń
              wbudowanych powłoki i wreszcie nazw plików wykonywalnych.
       possible-command-completions (C-x !)
              Pokazuje możliwe uzupełnienia tekstu sprzed  kursora,  traktując
              go jak nazwę polecenia.
       dynamic-complete-history (M-TAB)
              Usiłuje  uzupełnić  tekst  sprzed  kursora,  w celu odnalezienia
              możliwych uzupełnień porównując go z wierszami listy historii.
       dabbrev-expand
              Usiłuje wykonać uzupełnienie menu na tekście sprzed  kursora,  w
              celu odnalezienia możliwych uzupełnień porównując go z wierszami
              listy historii.
       complete-into-braces (M-{)
              Wykonuje uzupełnianie nazwy  pliku  i  wstawia  listę  możliwych
              uzupełnień  ujętą  w  nawiasy klamrowe, tak że jest ona dostępna
              dla powłoki (zobacz powyżej Interpretacja nawiasów).

   Makra klawiaturowe
       start-kbd-macro (C-x ()
              Rozpoczyna zachowywanie wpisywanych  znaków  w  bieżącym  makrze
              klawiaturowym.
       end-kbd-macro (C-x ))
              Zatrzymuje  zachowywanie  wpisywanych  znaków  w bieżącym makrze
              klawiaturowym i przechowuje definicję.
       call-last-kbd-macro (C-x e)
              Ponownie wykonuje  zdefiniowane  makro  klawiaturowe,  powodując
              pojawianie  się  znaków makra tak, jakby zostały wpisane z klaw‐
              iatury.

   Różne
       re-read-init-file (C-x C-r)
              Odczytuje zawartość pliku inputrc i dołącza wszystkie znalezione
              tam przypisania klawiszy i zmiennych.
       abort (C-g)
              Zaniechuje bieżącego polecenia edycji i emituje sygnał dźwiękowy
              terminala (zgodnie z ustawieniami bell-style).
       do-uppercase-version (M-a, M-b, M-x, ...)
              Jeżeli poprzedzony przedrostkiem meta znak x jest  małą  literą,
              uruchamia   plecenie,  które  jest  przypisane  do  odpowiedniej
              wielkiej litery.
       prefix-meta (ESC)
              Poprzedza przedrostkiem meta następny wpisany znak.  ESC f  jest
              równoważne Meta-f.
       undo (C-_, C-x C-u)
              Krokowe cofnięcie operacji, pamiętane odrębnie dla każdego wier‐
              sza.
       revert-line (M-r)
              Cofa wszystkie zmiany wykonane na tym wierszu. Podobne do  wyko‐
              nania  polecenia  undo  wystarczająco  wiele razy, by przywrócić
              wiersz do stanu początkowego.
       tilde-expand (M-&)
              Wykonuje interpretację tyldy w odniesieniu do bieżącego słowa.
       set-mark (C-@, M-<spacja>)
              stawia znacznik (mark) w bieżącym punkcie. Jeżeli  podano  argu‐
              ment numeryczny, znacznik jest ustawiany na takiej pozycji.
       exchange-point-and-mark (C-x C-x)
              Zamień  punkt ze znacznikiem. Aktualna pozycja kursora ustawiana
              jest na zapamiętaną, a dotychczasowa  pozycja  zachowywana  jako
              znacznik.
       character-search (C-])
              Odczytywany jest znak a punkt przesuwa się na następne wystąpie‐
              nie tego znaku. Licznik ujemny wyszukuje poprzednie wystąpienia.
       character-search-backward (M-C-])
              Odczytywany  jest  znak  a  punkt  przesuwa  się  na  poprzednie
              wystąpienie   tego   znaku.  Licznik  ujemny  wyszukuje  kolejne
              wystąpienia.
       skip-csi-sequence
              Odczytuje wystarczająco wiele znaków, aby pobrać sekwencje wielu
              klawiszy,  np. zdefiniowaną przez klawisze takie jak Home i End.
              Takie sekwencje zaczynają się znacznikiem  sekwencji  kontrolnej
              (Control  Sequence  Indicator - CSI), z reguły ESC-[. Jeśli taka
              sekwencja jest przypisana do "\[", to klawisze wchodzące w skład
              tej  sekwencji  nie będą działać (chyba że zostały jawnie przyp‐
              isane do polecenia readline) zamiast wstawiać niepowiązane znaki
              do  bufora  edycyjnego.  Domyślnie,  to polecenie jest nieprzyp‐
              isane, ale przypisanie powinno przeważnie odnosić się do ESC-[.
       insert-comment (M-#)
              Bez argumentu numerycznego, na początek bieżącego wiersza wstaw‐
              iana  jest wartość zmiennej comment-begin readline. Jeśli podano
              numeryczny argument, to polecenia działa jak przełącznik:  jeśli
              znaki  na początku wiersza nie pasują do wartości comment-begin,
              to wartość jest wstawiana, w przeciwnym  wypadku  znaki  w  com‐
              ment-begin są usuwane z początku każdego wiersza. W każdym przy‐
              padku wiersz jest akceptowany tak, jakby wprowadzono znak  nowej
              linii.  Domyślna wartość comment-begin powoduje, że polecenie to
              czyni bieżący wiersz komentarzem powłoki. Jeśli numeryczny argu‐
              ment powoduje usunięcie znaku komentarza, to dany wiersze będzie
              wykonany przez powłokę.
       glob-complete-word (M-g)
              Słowo sprzed kursora jest  traktowane  jako  wzorzec  rozwijania
              nazw  plików,  bez  jawnego  dodania  gwiazdki  (asterysku). Ten
              wzorzec może zostać użyty do wygenerowania listy pasujących nazw
              plików do możliwych uzupełnień.
       glob-expand-word (C-x *)
              Słowo sprzed kursora traktowane jest jak wzorzec rozwijania nazw
              plików  i  wstawiana  jest  lista  pasujących  nazw,  zastępując
              słowo-wzorzec. Jeśli podano numeryczny argument, to przed rozwi‐
              janiem nazw plików dodawana jest gwiazdka (asterysk).
       glob-list-expansions (C-x g)
              Wyświetlana jest  lista  rozwinięć,  jakie  zostałyby  utworzone
              przez  glob-expand-word,  a  wiersz  jest  ponownie wyświetlany.
              Jeśli podano numeryczny  argument,  to  przed  rozwijaniem  nazw
              plików dodawana jest gwiazdka (asterysk).
       dump-functions
              Wypisuje  do strumienia wyjściowego readline wszystkie funkcje i
              ich przypisania klawiszy.  Jeżeli  podano  argument  numeryczny,
              wyjście  jest  formatowane  w  taki  sposób,  by można zrobić je
              częścią pliku inputrc.
       dump-variables
              Wypisuje do strumienia wyjściowego readline wszystkie ustawialne
              zmienne   readline   i  ich  wartości.  Jeżeli  podano  argument
              numeryczny, wyjście jest formatowane w  taki  sposób,  by  można
              zrobić je częścią pliku inputrc.
       dump-macros
              Wypisuje  wszystkie  sekwencje  klawiszy  readline przypisane do
              makr i łańcuchy jakie dają w  wyniku.   Jeżeli  podano  argument
              numeryczny,  wyjście  jest  formatowane  w taki sposób, by można
              zrobić je częścią pliku inputrc.
       display-shell-version (C-x C-v)
              Wyświetla informację o wersji aktualnego egzemplarza bash.

   Programowalne uzupełnianie
       Gdy następuje próba uzupełnienia słowa  dla  argumentu  polecenia,  dla
       którego  zdefiniowano  specyfikację uzupełniania (completion specifica‐
       tion, compspec) przy pomocy wbudowanego polecenia complete (zobacz WBU‐
       DOWANE POLECENIA POWŁOKI poniżej), wywoływane są usługi programowalnego
       uzupełniania.

       Po pierwsze, identyfikowana jest nazwa polecenia. Jeśli słowo polecenia
       jest łańcuchem pustym (próba uzupełniania następuje na początku pustego
       wiersza), używany jest każdy compspec zdefiniowany  opcją  -E  do  com‐
       plete.  Jeżeli  dla  tego  polecenia zdefiniowano compspec, to compspec
       jest używane do utworzenia listy możliwych  uzupełnień  słowa.   Jeżeli
       słowo  polecenia  jest  pełną nazwą ścieżkową, to najpierw szukane jest
       compspec  dla  pełnej  nazwy.   Jeśli  nie  zostanie  odnalezione,   to
       następuje  próba znalezienia compspec dla części występującej po ostat‐
       nim ukośniku. Jeśli powyższe wyszukiwania nie dają wyniku  w  compspec,
       to jako domyślne używane są compspec zdefiniowane opcją -D do complete.

       Po   odnalezieniu  compspec,  jest  ono  używane  do  utworzenia  listy
       pasujących słów.  Jeżeli compspec nie zostało znalezione, to wykonywane
       jest domyślne uzupełnianie basha, jak opisano powyżej w Uzupełnianie.

       Na  początek,  używane  są  akcje określone przez compspec. Zwracane są
       wyłącznie  dopasowania  poprzedzone  dopasowywanym  słowem.    Gdy   do
       uzupełniania  nazw  plików lub katalogów użyto opcji -f lub -d, do fil‐
       trowania dopasowań wykorzystywana jest zmienna powłoki FIGNORE.

       W następnej kolejności tworzone są  ewentualne  uzupełnienia  określone
       przez  wzorzec  rozwinięcia nazw plików opcji -G.  Słowa tworzone przez
       wzorzec nie muszą pasować do uzupełnianego słowa.  Zmienna powłoki GLO‐
       BIGNORE  nie jest używana do filtrowania dopasowań, ale zmienna FIGNORE
       jest używana.

       Następnie, brany jest pod uwagę łańcuch podany jako argument opcji  -W.
       Łańcuch  jest  najpierw  rozbijany przy zastosowaniu znaków ze zmiennej
       specjalnej IFS jako separatorów.  Honorowane  jest  cytowanie  powłoki.
       Później  każde  ze  słów interpretowane jest z wykorzystaniem interpre‐
       tacji nawiasów, interpretacji tyld, podstawiania parametrów,  interpre‐
       tacji   zmiennych  i  wyrażeń  arytmetycznych  i  podstawiania  wyników
       poleceń, jak opisano powyżej w sekcji INTERPRETACJA.  Wyniki są  rozbi‐
       jane z zastosowaniem reguł opisanych powyżej w sekcji Podział na słowa.
       Wyniki  interpretacji  są  dopasowywane  przedrostkiem  z  uzupełnianym
       słowem, a pasujące słowa stają się możliwymi uzupełnieniami.

       Po  utworzeniu  tych  dopasowań,  wywoływana jest funkcja lub polecenie
       określone opcjami -F i -C.  Podczas wywoływania polecenia czy  funkcji,
       zmiennym  COMP_LINE,  COMP_POINT,  COMP_KEY i COMP_TYPE przypisywane są
       wartości, jak opisano to powyżej  w  sekcji  Zmienne  powłoki.   Jeżeli
       wywoływana   jest   funkcja   powłoki,  ustawiane  są  również  zmienne
       COMP_WORDS i COMP_CWORD.  Kiedy wywoływana jest funkcja czy  polecenie,
       pierwszym  argumentem  staje  się nazwa polecenia, którego argumenty są
       uzupełniane, drugim argumentem -- uzupełniane słowo,  a  trzecim  słowo
       poprzedzające  w wierszu poleceń słowo aktualnie uzupełniane.  Nie jest
       wykonywane  żadne  filtrowanie  utworzonych  uzupełnień  stosownie   do
       uzupełnianego słowa. Funkcja czy polecenie mają pełną swobodę tworzenia
       dopasowań.

       W pierwszej kolejności wywoływana jest funkcja określona przez -F.   Do
       tworzenia  dopasowań może ona korzystać z dowolnych możliwości powłoki,
       łącznie z opisanym poniżej poleceniem wbudowanym compgen.  Funkcja musi
       umieścić możliwe uzupełnienia w zmiennej tablicowej COMPREPLY.

       Następnie,  wywoływane  jest polecenie określone opcją -C, działające w
       środowisku równoważnym podstawianiu poleceń.  Powinno ono wypisać listę
       uzupełnień,  po  jednym w wierszu, na standardowe wyjście.  Jeżeli jest
       to niezbędne, do utworzenia znaku nowej linii  można  użyć  odwróconego
       ukośnika.

       Po  utworzeniu  wszelkich  możliwych uzupełnień, do listy tej stosowany
       jest filtr określony opcją -X.  Filtr jest takim wzorcem,  jak  używany
       przy  rozwijaniu  nazw  ścieżkowych.  Znak & we wzorcu zastępowany jest
       tekstem uzupełnianego słowa.  Literał & można otrzymać poprzedzając  go
       odwrotnym  ukośnikiem;  odwrotny  ukośnik zostanie usunięty przed próbą
       dopasowania.  Wszystkie uzupełnienia pasujące do wzorca będą usunięte z
       listy.   Początkowy  !  daje  zaprzeczenie wzorca. Będą wówczas usuwane
       uzupełnienia nie pasujące do wzorca.

       Na koniec, do każdego elementu listy dodawane są  przedrostek  i  przy‐
       rostek  określone  opcjami  -P  i  -S,  a  wynik  zwracany jest do kodu
       uzupełniania readline jako lista możliwych uzupełnień.

       Jeśli poprzednio zastosowane działania nie utworzyły żadnych dopasowań,
       zaś  przy definiowaniu compspec podano opcję -o dirnames polecenia com‐
       plete, to dokonywana jest próba uzupełnienia nazwy katalogu.

       Jeśli do complete podano opcję -o  plusdir  gdy  istnieje  zdefiniowane
       compspec,  to  próba  dopasowania nazw katalogów jest przeprowadzana, a
       ewentualne dopasowania są dodawane do wyników innych akcji.

       Domyślnie,  jeżeli  znaleziono  compspec,  to  cokolwiek  ono   utworzy
       zwracane  jest  do  kodu  uzupełniającego  jako  pełny zestaw możliwych
       uzupełnień.  Nie są próbowane domyślne uzupełnienia  bash,  a  domyślne
       uzupełnianie nazw ścieżkowych przez readline jest wyłączone. Jeśli przy
       definiowaniu compspec podano opcję -o bashdefault, to  jeżeli  compspec
       nie utworzy żadnych uzupełnień, wykonane zostanie domyślne uzupełnienia
       bash. Jeśli przy definiowaniu compspec podano opcję -o default  polece‐
       nia  complete, to jeżeli compspec nie utworzy żadnych uzupełnień, wyko‐
       nane zostanie domyślne uzupełnianie  z  readline  (i,  jeśli  próbowano
       domyślnych uzupełnień bash, także one).

       Gdy  compspec  informuje o żądaniu uzupełnienia nazwy katalogu, funkcje
       programowalnego uzupełnienia wymuszają na readline dodanie ukośnika, do
       uzupełnianych  nazw  będących  dowiązaniami symbolicznymi do katalogów,
       które  są  przedmiotem  wartości  zmiennej  mark-direstories  readline,
       niezależnie od ustawienia zmiennej mark-symlinked-directories readline.

       Istnieje  pewna  obsługa uzupełnień modyfikowanych dynamicznie. Jest to
       szczególnie użyteczne w kombinacji z domyślnym  uzupełnianiem  z  opcją
       complete   -D.   W   przypadku   funkcji   powłoki,  wykonywanych  jako
       odpowiedzialne  za  uzupełnianie,  możliwe   jest   poinformowanie   że
       uzupełnienie  powinno  być ponowione za pomocą kodu zakończenia równego
       124. Jeśli funkcja powłoki  zwróci  124  i  zmieni  powiązany  compspec
       poleceniem,  którego próbę uzupełnienia podjęto (podanego jako pierwszy
       argument  gdy  funkcja  jest  wykonywana),  programowalne  uzupełnianie
       rozpoczyna  od  początku, próbując znaleźć nowy compspec dla polecenia.
       Pozwala na ustawianie uzupełnień budowanych  dynamicznie  po  wykonanej
       próbie uzupełnienia, zamiast ładowania ich wszystkich naraz.

       Przykładowo,  przyjmując  że istnieje biblioteka składająca się z comp‐
       spec, każda przechowywana w pliku odpowiadającym nazwie  polecenia,  to
       następująca  domyślna funkcja uzupełnienia załaduje uzupełnienia dynam‐
       icznie:

       _completion_loader()
       {
            . "/etc/bash_completion.d/$1.sh" >/dev/null 2>&1 && return 124
       }
       complete -D -F _completion_loader


HISTORIA
       Jeżeli włączona jest opcja -o history  wbudowanego  polecenia  set,  to
       powłoka  zapewnia  dostęp do historii poleceń, listy poleceń poprzednio
       wprowadzonych.  Wartość  zmiennej  HISTSIZE  wykorzystywana  jest  jako
       liczba  poleceń  do  zachowania  na  liście historii.  Zachowywany jest
       tekst ostatnich HISTSIZE poleceń (domyślnie 500).  Powłoka  przechowuje
       każde  polecenie  na  liście  przed podstawieniem wartości parametrów i
       zmiennych (zobacz powyżej INTERPRETACJA), ale przed  wykonaniem  inter‐
       pretacji  historii,  w zależności od wartości zmiennych powłoki HISTIG‐
       NORE i HISTCONTROL.

       Przy uruchamianiu, historia inicjowana jest z pliku o nazwie  wskazanej
       zmienną  HISTFILE  (domyślnie ~/.bash_history). Plik o nazwie wziętej z
       wartości HISTFILE jest obcinany, jeśli zachodzi potrzeba,  by  zawierał
       nie  więcej  wierszy  niż określono to wartością zmiennej HISTFILESIZE.
       Gdy plik historii jest odczytywany, wiersze zaczynające  się  od  znaku
       komentarza  historii, po którym występuje bezpośrednio cyfra, są inter‐
       pretowane jako czasy poprzedzającego wcześniejszego historii. Czasy  te
       mogą  być  opcjonalnie  wyświetlane,  w zależności od wartości zmiennej
       HISTTIMEFORMAT. Podczas kończenia pracy powłoki interaktywnej, ostatnie
       $HISTSIZE wierszy kopiowane jest z listy historii do $HISTFILE.  Jeżeli
       włączona jest opcja powłoki histappend (zobacz opis shopt w sekcji WBU‐
       DOWANE  POLECENIA  POWŁOKI  poniżej),  to wiersze są dodawane na koniec
       pliku historii, w przeciwnym  razie  plik  historii  jest  nadpisywany.
       Jeżeli  HISTFILE  nie  jest  ustawione  lub  plik historii nie daje się
       zapisać, to historia nie jest zachowywana. Jeśli zmienna HISTTIMEFORMAT
       jest  ustawiona, to pieczątki czasowe oznaczone znakiem komentarza his‐
       torii  są  zapisywane  do  pliku  historii,  tak  więc  mogą  być   one
       zachowywane  pomiędzy  sesjami  powłoki.  Znak historii komentarza jest
       wykorzystywany w celu odróżnienia pieczątek czasowych od innych wierszy
       historii.  Po  zapisaniu,  plik historii jest obcinany, by nie zawierał
       więcej niż HISTFILESIZE wierszy. Jeśli HISTFILESIZE nie jest ustawione,
       to obcinanie nie jest wykonywane.

       Do edycji lub ponownego wykonania części listy historii można korzystać
       z  wbudowanego  polecenia  fc  (zobacz  WBUDOWANE   POLECENIA   POWŁOKI
       poniżej).   Wbudowanego  polecenia history można używać do wyświetlania
       lub zmiany listy historii  i  manipulacji  plikiem  historii.   Podczas
       posługiwania  się  edycją  wiersza  poleceń,  w  każdym z trybów edycji
       umożliwiających  dostęp  do  listy  historii,  dostępne  są   polecenia
       przeszukiwania.

       Powłoka  umożliwia  kontrolę nad tym, jakie polecenia są zachowywane na
       liście.  Można ustawić zmienne HISTCONTROL i HISTIGNORE, co  spowoduje,
       że  powłoka  będzie  zachowywać  tylko  podzbiór wprowadzonych poleceń.
       Opcja powłoki cmdhist,  jeżeli  jest  włączona,  powoduje,  że  powłoka
       będzie  usiłować zachować każdy wiersz polecenia wielowierszowego w tej
       samej pozycji historii, dodając, gdzie jest to niezbędne, średniki,  by
       zachować  poprawność  składni.   Opcja  powłoki  lithist  powoduje,  że
       powłoka będzie zachowywać polecenia z osadzonymi  znakami  nowej  linii
       zamiast średników. Zobacz opis wbudowanego shopt poniżej, w sekcji WBU‐
       DOWANE POLECENIA POWŁOKI, gdzie znajdziesz informacje  o  ustawianiu  i
       kasowaniu opcji powłoki.

INTERPRETACJA HISTORII
       Powłoka  obsługuje funkcję interpretacji historii, podobną do interpre‐
       tacji historii w csh.  Ta sekcja opisuje dostępne  możliwości  składni.
       Funkcja ta jest domyślnie włączona dla powłok interaktywnych i może być
       wyłączona przy  pomocy  opcji  +H  wbudowanego  polecenia  set  (zobacz
       poniżej   WBUDOWANE   POLECENIA   POWŁOKI).   Powłoki  nie-interaktywne
       domyślnie nie wykonują interpretacji historii.

       Interpretacja historii wprowadza słowa z listy historii  do  strumienia
       wejściowego,  ułatwiając  powtarzanie  poleceń  lub poprawianie szybkie
       błędów w poprzednich poleceniach.

       Interpretacja historii przeprowadzana jest bezpośrednio po przeczytaniu
       pełnego  wiersza,  przed jego podziałem na słowa przez powłokę.  Odbywa
       się w dwu częściach.  Pierwszą jest określenie, który  wiersz  z  listy
       historii  ma  zostać  użyty  podczas podstawiania.  Drugą stanowi wybór
       części tego wiersza do włączenia w bieżący.  Wybrany z historii  wiersz
       jest  zdarzeniem  (event),  a  jego  części  na  których  wykonywane są
       działania są słowami.  Dostępne są różne modyfikatory do  manipulowania
       wybranymi słowami.  Wiersz rozbijany jest na słowa w ten sam sposób jak
       podczas odczytu wejścia, tak że  kilka  słów  separowanych  metaznakami
       ujętych  w cudzysłowy traktowanych jest jak jedno słowo.  Interpretacja
       historii wprowadzana są obecnością znaku rozwijającego historię, którym
       domyślnie jest !.  Cytować ten znak mogą wyłącznie odwrotny ukośnik (\)
       i pojedyncze cudzysłowy.

       Następujące znaki powstrzymują  interpretację  historii  jeśli  zostaną
       znalezione  bezpośrednio za znakiem interpretacji historii, nawet jeśli
       jest niecytowany: spacja, tabulacja, znak nowego wiersza, znak  powrotu
       karetki  i  =. Jeśli włączono opcję powłoki extglob, to ( również zapo‐
       biegnie interpretacji.

       Kilka opcji powłoki  ustawianych  przy  pomocy  shopt  może  służyć  do
       śledzenia  działania  interpretacji  historii.  Jeżeli opcja histverify
       powłoki jest włączona (zobacz opis wbudowanego shopt)  i  używane  jest
       readline,  to  podstawienia  historii  nie są natychmiast przesyłane do
       analizatora składni (parsera) powłoki.  Zamiast  tego,  zinterpretowany
       wiersz jest ponownie ładowany do bufora edycyjnego readline w celu dal‐
       szej modyfikacji.  Jeżeli wykorzystywane jest readline i włączona  jest
       opcja  histreedit,  to  zakończone niepowodzeniem podstawienie historii
       zostanie ponownie załadowane  do  bufora  edycyjnego  readline  w  celu
       poprawienia.  Opcją -p wbudowanego polecenia history można posłużyć się
       do  oglądnięcia,  co  zrobi  interpretacja  historii  przed  jej   zas‐
       tosowaniem.   Opcji  -s wbudowanego polecenia history można użyć w celu
       dodania poleceń na koniec listy historii bez faktycznego ich wykonania,
       tak że będą dostępne dla następnych przywołań.

       Powłoka pozwala na kontrolowanie różnych znaków stosowanych przez mech‐
       anizm interpretacji historii (zobacz opis histchars powyżej,  w  sekcji
       Zmienne  powłoki).  Do  oznaczania  pieczątek  czasowych, powłoka używa
       znaku komentarza historii podczas zapisywania pliku historii.

   Desygnatory zdarzeń (Event Designators)
       Desygnator zdarzenia jest odwołaniem  do  pozycji  wiersza  poleceń  na
       liście  historii.  O  ile  odwołanie  nie  jest absolutne, zdarzenia są
       relatywne w stosunku do bieżącej pozycji w liście historii.

       !      Rozpoczyna podstawianie  historii,  z  wyjątkiem  sytuacji,  gdy
              występuje po nim odstęp, znak nowej linii, = lub ( (gdy włączono
              opcję powłoki extglob używając wbudowanego shopt).
       !n     Wskazuje na n-ty wiersz poleceń.
       !-n    Wskazuje na wiersz poleceń bieżący minus n.
       !!     Wskazuje na poprzednie polecenie. jest to synonim `!-1'.
       !łańcuch
              Wskazuje na ostatnie poleceniem rozpoczynające się od łańcucha.
       !?łańcuch[?]
              Wskazuje na ostatnie polecenie poprzedzające bieżącą  pozycję  w
              liście  historii, zawierające łańcuch.  Kończące ? można pominąć
              jeśli bezpośrednio po łańcuchu występuje znak nowej linii.
       ^łańcuch1^łańcuch2^
              Szybkie podstawianie. Powtarza ostatnie  polecenie,  wymieniając
              łańcuch1  na  łańcuch2.   Równoważnik  ,,!!:s/łańcuch1/łańcuch/”
              (zobacz poniżej Modyfikatory).
       !#     Cały wiersz poleceń wpisany do tego momentu.

   Desygnatory słów (Word Designators)
       Desygnatory słów  służą  do  wybierania  ze  zdarzenia  żądanych  słów.
       Dwukropek  :  oddziela  określenie zdarzenia od desygnatora słowa. Może
       być pominięty jeśli desygnator słowa rozpoczyna się od ^, $, *,  -  lub
       %.   Słowa  numerowane  są  od  początku wiersza, przy czym pierwsze ma
       numer 0 (zero).  Słowa są wstawiane do bieżącego  wiersza,  rozdzielane
       pojedynczymi spacjami.

       0 (zero)
              Słowo zerowe. Dla powłoki jest to słowo polecenia.
       n      n-te słowo.
       ^      Pierwszy argument. To znaczy, słowo 1.
       $      Ostatni argument.
       %      Słowo dopasowane przez ostatnie wyszukanie `?łańcuch?'.
       x-y    Zakres słów; `-y' jest skróconym `0-y'.
       *      Wszystkie  słowa prócz zerowego. jest to synonim dla `1-$'.  Nie
              jest błędem użycie * jeśli w zdarzeniu jest tylko jedno słowo; w
              tym przypadku zwracany jest łańcuch pusty.
       x*     Skrót od x-$.
       x-     Skrót od x-$ podobnie jak x*, ale pomija ostatnie słowo.

       jeśli  desygnator  słowa  podano bez określenia zdarzenia, za zdarzenie
       przyjmowane jest poprzednie polecenie.

   Modyfikatory
       Po opcjonalnym desygnatorze słowa może pojawić  się  sekwencja  jednego
       lub więcej poniższych modyfikatorów, każdy poprzedzony dwukropkiem `:'.

       h      Usuwa   końcową   składową   nazwy  pliku,  pozostawiając  tylko
              początek.
       t      Usuwa wszystkie początkowe składowe nazwy  pliku,  pozostawiając
              koniec.
       r      Usuwa  kończący  przyrostek  postaci  .xxx, pozostawiając główną
              część nazwy (basename).
       e      Usuwa wszystko prócz końcowego przyrostka.
       p      Wypisuje nowe polecenie, ale go nie wykonuje.
       q      Cytuje podstawiane słowa, zabezpieczając je przed  dalszym  pod‐
              stawianiem.
       x      Cytuje podstawiane słowa jak q, ale rozbija na słowa w miejscach
              odstępów i znaków nowej linii.
       s/stary/nowy/
              Zastępuje  nowym  pierwsze   wystąpienie   starego   w   wierszu
              zdarzenia.  Zamiast  /  może  zostać  użyty dowolny ogranicznik.
              Końcowy ogranicznik jest opcjonalny jeżeli jest ostatnim znakiem
              wiersza  zdarzenia. Separator może być cytowany w nowym i starym
              przy pomocy pojedynczego odwrotnego  ukośnika.  Jeżeli  w  nowym
              pojawia  się &, to jest zastępowany starym.  Pojedynczy odwrotny
              ukośnik będzie cytował &. Jeżeli stary jest pusty, to  ustawiany
              jest  na  ostatni podstawiany stary lub, jeśli nie było poprzed‐
              nich  podstawień  historii,  ostatni  łańcuch   w   wyszukiwaniu
              !?łańcuch[?].
       &      Powtarza poprzednie podstawienie.
       g      Powoduje,  że  zmiany  zostaną  zastosowane  do  całego  wiersza
              zdarzenia.  Używany w połączeniu z `:s' (np.  `:gs/stary/nowy/')
              lub  `:&'.  Jeśli  użyty z `:s', to zamiast / można posłużyć się
              dowolnym separatorem, a ostatni separator jest opcjonalny jeżeli
              jest ostatnim znakiem wiersza zdarzenia.
       G      Stosuje  następujący po nim modyfikator "s" raz do każdego słowa
              w wierszu zdarzenia.

WBUDOWANE POLECENIA POWŁOKI
       Jeśli nie podano inaczej,  każde  z  poleceń  wbudowanych  opisanych  w
       niniejszej  sekcji  jako  akceptujące  opcje  poprzedzone  -  akceptuje
       również symbol -- określający koniec opcji. Wbudowane :, true, false  i
       test  nie  akceptują  opcji  i nie traktują -- w sposób specjalny. Wbu‐
       dowane  exit,  logout,  break,  continue,  let  i  shift  akceptują   i
       przetwarzają  argumenty  zaczynające  się  od -, bez wymogu podania --.
       Inne wbudowane  polecenia,  które  akceptują  argumenty,  lecz  nie  są
       opisane  jako akceptujące opcje, interpretują argumenty zaczynające się
       od - jako opcje nieprawidłowe i wymagają --, aby zapobiec takiej inter‐
       pretacji,
       : [argumenty]
              Bez  efektów;  polecenie  to nie robi niczego poza interpretacją
              argumentów  i  wykonaniem  ewentualnych  podanych  przekierowań.
              Zwracany jest zerowy kod zakończenia.

        .  plik [argumenty]
       source plik [argumenty]
              Odczytuje  i  wykonuje  polecenia  z  zadanego pliku w aktualnym
              środowisku powłoki i zwraca  kod  zakończenia  ostatniego  wyko‐
              nanego  polecenia  z tego pliku.  Jeżeli nazwa pliku nie zawiera
              ukośnika, to do znalezienia katalogu  go  zawierającego  używana
              jest zmienna PATH.  Plik poszukiwany w PATH nie musi być wykony‐
              walny.  Jeśli bash nie jest w trybie posix, wówczas  jeżeli  nie
              znaleziono  pliku w PATH, to przeszukiwany jest katalog bieżący.
              Jeśli we wbudowanym poleceniu shopt wyłączona jest  opcja  sour‐
              cepath,  to  PATH  nie  jest przeszukiwane.  jeśli podano jakieś
              argumenty, to stają  się  one  parametrami  pozycyjnymi  podczas
              wykonywania   pliku.  W  przeciwnym  razie  argumenty  pozycyjne
              pozostają bez zmian.   Kod  zakończenia  jest  kodem  ostatniego
              zakończonego  przez  skrypt  polecenia  (0  jeśli  nie  wykonano
              żadnego polecenia), a fałszem jeżeli nie  znaleziono  pliku  lub
              nie można go odczytać.

       alias [-p] [nazwa[=wartość] ...]
              Alias  bez  argumentów  bądź z opcją -p wypisuje na standardowym
              wyjściu listę aliasów w postaci alias nazwa=wartość.  Jeśli  nie
              dostarczono argumentów, to definiowany jest alias (synonim)  dla
              każdej nazwy, dla której podano wartość.   Początkowa  spacja  w
              wartości  powoduje,  że  podczas  interpretacji  aliasu następne
              słowo będzie sprawdzane na  podstawianie  aliasów.   Dla  każdej
              nazwy  z  listy argumentów, dla której nie podano wartości, wyp‐
              isywana jest nazwa i wartość aliasu.  Alias zwraca prawdę, chyba
              że podano nazwę, dla której nie został zdefiniowany żaden alias.

       bg [spec_zad]
              Wznawia w tle zawieszone zadanie spec_zad, tak jakby zostało ono
              uruchomione z &.  Jeśli spec_zad nie występuje, to używane  jest
              bieżące  zadanie,  określone  tak,  jak  je pojmuje powłoka.  bg
              spec_zad zwraca 0, chyba że uruchomiono je przy wyłączonej  kon‐
              troli  zadań  (job  control) lub uruchomiono z włączoną kontrolą
              zadań, jeśli nie znaleziono spec_zad lub  uruchomiono  bez  kon‐
              troli zadań.

       bind [-m keymap] [-lpsvPSV]
       bind [-m keymap] [-q funkcja] [-u funkcja] [-r sekw_klaw]
       bind [-m keymap] -f plik
       bind [-m keymap] -x sekw_klaw:polec_powłoki
       bind [-m keymap] sekw_klaw:nazwa_funkcji
       bind readline-command
              Wyświetla  bieżące  ustawienia  przypisań  (bindings) klawiszy i
              funkcji readline lub przypisuje sekwencję  klawiszy  to  funkcji
              lub makra readline.  Składnia tych przypisań jest identyczna jak
              dla .inputrc, ale każde z  przypisań  musi  być  przesłane  jako
              osobny  argument;  np.,  '"\C-x\C-r": re-read-init-file'. Opcje,
              jeśli je podano, mają następujące znaczenie:
              -m keymap
                     Wykorzystuje keymap jako mapę klawiszy,  do  której  mają
                     być   zastosowane  następne  przypisania.   Akceptowanymi
                     nazwami   map   klawiszy   są   emacs,    emacs-standard,
                     emacs-meta,   emacs-ctlx,   vi,   vi-move,  vi-command  i
                     vi-insert.  vi równoważne  jest  vi-command;  emacs  jest
                     równoważne emacs-standard.
              -l     Podaje nazwy wszystkich funkcji readline.
              -p     Wyświetla  nazwy  funkcji i przypisania w taki sposób, że
                     mogą być ponownie odczytane.
              -P     Podaje bieżące przypisania i nazwy funkcji readline.
              -s     Wyświetla nazwy i  wartości  zmiennych  readline  w  taki
                     sposób, że mogą być ponownie odczytane.
              -S     Wyświetla  sekwencje klawiszy readline przypisane do makr
                     i łańcuchy jakie one wysyłają.
              -v     Wyświetla sekwencje klawiszy readline przypisane do  makr
                     i  łańcuchy jakie one wysyłają w taki sposób, że mogą być
                     ponownie odczytane.
              -V     Podaje bieżące nazwy i wartości zmiennych readline.
              -f plik
                     Czyta przypisania klawiszy z pliku.
              -q funkcja
                     Podaje, które klawisze wywołują podaną funkcję.
              -u funkcja
                     Odwołuje przypisania wszystkich klawiszy przypisanych  do
                     danej funkcji.
              -r sekw_klaw
                     Usuwa bieżące przypisania dla sekwencji klawiszy.
              -x sekw_klaw:polec_powłoki
                     Powoduje,  że  za  każdym naciśnięciem sekwencji klawiszy
                     zostanie  wykonane  polecenie  powłoki.   Gdy   polecenie
                     powłoki  jest  wykonywane,  powłoka ustawia zmienną READ‐
                     LINE_LINE na zawartość bufora wiersza readline oraz  zmi‐
                     enną   READLINE_POINT   na   bieżące   położenie  miejsca
                     wprowadzania znaków. Jeśli wykonywane  polecenie  zmienia
                     wartość  READLINE_LINE  lub  READLINE_POINT,  to  te nowe
                     wartości zostaną uwzględnione podczas edytowania.

              Zwracana jest wartość 0, chyba że podano nierozpoznaną opcję lub
              pojawił się błąd.

       break [n]
              Opuszcza  pętlę  for, while, until lub select.  Jeżeli podano n,
              przerywa działanie do n-tego poziomu.  n musi być ≥ 1. Jeżeli  n
              jest większe od liczby obejmujących polecenie pętli, to kończone
              są wszystkie obejmujące pętle. Wartością zwracaną jest 0,  chyba
              że powłoka nie wykonuje pętli podczas wykonania break.

       builtin wbudowane [argumenty]
              Wykonuje  zadane  polecenie  wbudowane  powłoki,  przesyłając mu
              argumenty i zwraca  jego  kod  zakończenia.   Przydatne  podczas
              definiowania  funkcji  o  nazwie  tożsamej  z  nazwą wbudowanego
              polecenia  powłoki,  zachowując  funkcjonalność  polecenia  wbu‐
              dowanego   wewnątrz  funkcji.   Wbudowane  cd  jest  powszechnie
              redefiniowane w ten sposób.  Kodem zakończenia jest fałsz  jeśli
              wbudowane nie jest wbudowanym poleceniem powłoki.

       caller [wyrażenie]
              Zwraca kontekst aktywnego wywołania podprogramu (funkcji powłoki
              lub skryptu wykonywanego wbudowanymi poleceniami . lub  source).
              Bez  wyrażenia,  caller  wyświetla numer wiersza i plik źródłowy
              bieżącego wywołania podprogramu. Jeśli do  wyrażenia  przekazano
              nieujemną  liczbę  całkowitą, to caller wyświetla numer wiersza,
              nazwę podprogramu i plik źródłowy związany z pozycją w  bieżącym
              stosie  wywołania. Te dodatkowe informacje mogą być użyte np. do
              wyświetlenia  stosu  wywołania.  Bieżąca  ramka  jest  ramką  0.
              Zwracaną  wartością  jest  0,  chyba  że  powłoka  nie  wykonuje
              wywołania  podprogramu  lub  wyrażenie   nie   odnosi   się   do
              prawidłowej pozycji w stosie wywołania.

       cd [-L|[-P [-e]]] [katalog]
              Zmienia  bieżący  katalog  roboczy  na  dir.  Zmienna  HOME jest
              domyślnym  katalogiem.    Zmienna   CDPATH   definiuje   ścieżkę
              przeszukiwań  dla  katalogu zawierającego katalog.  Alternatywne
              nazwy katalogów w CDPATH rozdzielane są dwukropkiem  (:).  Pusta
              nazwa  katalogu w CDPATH jest tym samym, co katalog bieżący, tj.
              ,,.”. Jeżeli katalog rozpoczyna się ukośnikiem  (/),  to  CDPATH
              nie  jest  używane. Opcja -P nakazuje użycie fizycznej struktury
              katalogów  zamiast  podążania  za   dowiązaniami   symbolicznymi
              (zobacz  też  opcja  -P  wbudowanego  polecenia  set);  Opcja -L
              wymusza podążanie za  dowiązaniami  symbolicznymi.  Jeśli  z  -P
              użyto  opcji  -e,  a  bieżący  katalog  roboczy  nie może zostać
              pomyślnie określony po pomyślnej zmianie katalogu, to cd  zwróci
              kod  oznaczający niepowodzenie. Argument - jest równoważny $OLD‐
              PWD. Jeśli użyta jest niepusta nazwa katalogu z CDPATH lub jeśli
              -  jest  pierwszym  argumentem,  a  zmiana  katalogu  odbyła się
              pomyślnie, na standardowe wyjście wypisywana jest ścieżka  abso‐
              lutna  do  nowego  katalogu  roboczego.  Wartością zwracaną jest
              prawda jeśli pomyślnie zmieniono katalog; w przeciwnym przypadku
              fałsz.

       command [-pVv] polecenie [arg ...]
              Uruchamia  polecenie z argumentami zakazując zwykłego wyszukiwa‐
              nia funkcji przez powłokę.  Wykonywane  są  wyłącznie  polecenia
              wbudowane  i  polecenia  znalezione w PATH.  Jeżeli podano opcję
              -p, wyszukiwanie polecenia wykonywane jest przy użyciu domyślnej
              PATH,  która  gwarantuje  znalezienie  wszystkich  standardowych
              narzędzi.  Jeśli użyto albo opcji -V albo -v, to wypisywany jest
              opis  polecenia.   Opcja  -v  powoduje,  że zostanie wyświetlone
              pojedyncze słowo wskazujące polecenie lub nazwę pliku, użyte  do
              wywołania  polecenia;  opcja  -V  tworzy bardziej obszerny opis.
              Jeżeli podano opcję -V lub -v, to kodem zakończenia jest  0  gdy
              odnaleziono  polecenie, zaś 1 gdy nie. Jeśli nie podano żadnej z
              tych opcji i pojawił się błąd lub nie można  znaleźć  polecenia,
              to  kod  zakończenia  wynosi  127.  W  przeciwnym  wypadku kodem
              zakończenia wbudowanego polecenia command jest  kod  zakończenia
              polecenia.

       compgen [opcja] [słowo]
              Tworzy  możliwe  dopasowania uzupełnień dla słowa zgodnie z opc‐
              jami, które mogą być dowolnymi z opcji akceptowanych przez  wbu‐
              dowane polecenie complete, z wyjątkiem -p i -r, i wypisuje dopa‐
              sowania na standardowe wyjście.  Przy stosowaniu  opcji  -F  lub
              -C, różne zmienne powłoki ustawiane przez usługi programowalnego
              uzupełniania,  gdy  są  dostępne,  nie  będą  mieć   użytecznych
              wartości.

              Dopasowania będą tworzone w ten sam sposób, jakby kod uzupełnia‐
              nia programowalnego tworzył je wprost ze specyfikacji uzupełnia‐
              nia  z tymi samymi flagami.  Jeżeli podano słowo, to wyświetlone
              zostaną wyłącznie uzupełnienia doń pasujące.

              Wartością zwracaną jest  prawda,  chyba  że  podano  niepoprawną
              opcję lub nie zostały utworzone żadne dopasowania.

       complete  [-abcdefgjksuv]  [-o  opcjacomp] [-DE] [-A akcja] [-G wzglob]
       [-W listasłów] [-F funkcja] [-C polecenie]
              [-X wzfiltr] [-P przedrostek] [-C przyrostek] nazwa [nazwa ...]
       complete -pr [-DE] [nazwa ...]
              Określa, w jaki sposób będą uzupełniane argumenty dla  każdej  z
              nazw.   Jeżeli podano opcję -p, lub nie podano żadnych opcji, to
              wypisywane są istniejące specyfikacje uzupełniania -  w  sposób,
              który  pozwala na ich ponowne wykorzystanie jako wejścia.  Opcja
              -r usuwa specyfikację uzupełniania dla każdej z nazw, lub  jeśli
              nazw  nie  podano, wszystkie specyfikacje uzupełniania. Opcja -D
              wskazuje,  że  pozostałe  opcje   i   akcje   powinny   dotyczyć
              "domyślnego"   polecenia  uzupełniania,  to  jest  uzupełniania,
              którego próbę podjęto na poleceniu o niezdefiniowanym  wcześniej
              uzupełnieniu.  Opcja  -E  oznacza,  że  pozostałe  opcje i akcje
              powinny  dotyczyć   "pustego"   polecenia   uzupełniania,   tzn.
              uzupełniania, którego próbę podjęto na pustym wierszu.

              Proces  stosowania  tych  specyfikacji  uzupełnień  podczas prób
              uzupełniania  słów  omówiono  powyżej  w  sekcji   Programowalne
              uzupełnianie.

              Pozostałe  opcje, jeśli je podano, mają niżej opisane znaczenie.
              Argumenty opcji -G, -W i -X (i, jeśli to  niezbędne,  -P  i  -S)
              powinny  być  cytowane  dla  ochrony  przed  interpretacją  jaka
              wystąpi zanim zostanie wywołane polecenie complete.
              -o opcjacomp
                      Wartość opcjacomp reguluje kilka aspektów zachowania się
                      compspec    wykraczających    poza    zwykłe   tworzenie
                      uzupełnień.  opcjacomp przyjmuje jedną z wartości:
                      bashdefault
                              Wykonuje pozostałe z domyślnych uzupełnień bash,
                              jeśli compspec nie utworzy żadnych dopasowań.
                      default Stosuje  domyślne  uzupełnianie  readline  jeśli
                              compspec nie utworzy żadnych dopasowań.
                      dirnames
                              Wykonuje uzupełnianie nazw katalogów jeśli comp‐
                              spec nie utworzy żadnych dopasowań.
                      filenames
                              Powiadamia  readline,  że  compspec tworzy nazwy
                              plików, zatem może wykonać przetwarzanie  specy‐
                              ficzne  dla takich nazw (jak dodanie ukośnika do
                              nazw katalogów czy usunięcie końcowych  spacji).
                              Zaprojektowane   do   stosowania   z   funkcjami
                              powłoki.
                      nospace Przekazuje readline,  aby  nie  dodawało  spacji
                              (domyślnie)  do  uzupełnionych  słów,  na  końcu
                              wiersza.
                      plusdirs
                              Po  utworzeniu  dopasowań  zdefiniowanych  przez
                              compspec,  przeprowadzana jest próba dopasowania
                              nazw  katalogów,  a  ewentualne  dopasowania  są
                              dodawane do wyników innych akcji.
              -A akcja
                      akcja  może  być  jedną  z  poniższych, tworzących listę
                      możliwych dopasowań:
                      alias   Nazwy aliasów. Można też podać jako -a.
                      arrayvar
                              Nazwy zmiennych tablicowych.
                      binding Nazwy przypisań klawiszy readline.
                      builtin Nazwy wbudowanych  poleceń  powłoki.  Można  też
                              podać jako -b.
                      command Nazwy poleceń. Można też podać jako -c.
                      directory
                              Nazwy katalogów. Można też podać jako -d.
                      disabled
                              Nazwy wyłączonych poleceń wbudowanych powłoki.
                      enabled Nazwy włączonych poleceń wbudowanych powłoki.
                      export  Nazwy  wyeksportowanych zmiennych powłoki. Można
                              też podać jako -e.
                      file    Nazwy plików. Można też podać jako -f.
                      function
                              Nazwy funkcji powłoki.
                      group   Nazwy grup. Można też podać jako -g.
                      helptopic
                              Tematy  pomocy   akceptowane   przez   wbudowane
                              polecenie help.
                      hostname
                              Nazwy  hostów, pobrane z pliku określonego przez
                              zmienną powłoki HOSTFILE.
                      job     Nazwy  zadań,  jeżeli  aktywne  jest  sterowanie
                              zadaniami. Można też podać jako -j.
                      keyword Zastrzeżone  słowa powłoki. Można też podać jako
                              -k.
                      running Nazwy działających zadań,  jeżeli  aktywne  jest
                              sterowanie zadaniami.
                      service Nazwy usług. Można też podać jako -s.
                      setopt  Dozwolone  argumenty  opcji  -o  polecenia  wbu‐
                              dowanego set.
                      shopt   Nazwy  opcji  powłoki,  takie,  jakie  akceptuje
                              polecenie wbudowane shopt.
                      signal  Nazwy sygnałów.
                      stopped Nazwy  zatrzymanych  zadań,  jeśli  aktywne jest
                              sterowanie zadaniami.
                      user    Nazwy użytkowników. Można też podać jako -u.
                      variable
                              Nazwy wszystkich zmiennych  powłoki.  Można  też
                              podać jako -v.
              -C polecenie
                      polecenie  jest  wykonywane  w  środowisku podpowłoki, a
                      jego wyjście jest używane jako możliwe uzupełnienia.
              -F funkcja
                      Funkcja  powłoki  funkcja  jest  wykonywana  w  bieżącym
                      środowisku   powłoki.   Po   jej   zakończeniu,  możliwe
                      uzupełnienia są pobierane z wartości zmiennej tablicowej
                      COMPREPLY.
              -G wzglob
                      Wzorzec  rozwijania  nazw  plików wzglob jest rozwijany,
                      tworząc listę możliwych uzupełnień.
              -P przedrostek
                      na początku każdego  z  możliwych  uzupełnień,  po  zas‐
                      tosowaniu  wszystkich  innych opcji, dodawany jest prze‐
                      drostek.
              -S przyrostek
                      na końcu każdego z możliwych uzupełnień, po zastosowaniu
                      wszystkich innych opcji, dodawany jest przyrostek.
              -W listasłów
                      listasłów  jest  rozbijana  przy  zastosowaniu znaków ze
                      zmiennej specjalnej IFS jako  separatorów,  a  każde  ze
                      słów    wynikowych    jest    interpretowane.    Możliwe
                      uzupełnienia są elementami listy  wynikowej,  pasującymi
                      do uzupełnianego słowa.
              -X wzfiltr
                      wzfiltr jest wzorcem używanym do rozwijania nazw plików.
                      Stosowany jest do listy możliwych uzupełnień  utworzonej
                      przez  poprzedzające  go  opcje  i  argumenty,  a  każde
                      pasujące do niego uzupełnienie  jest  usuwane  z  listy.
                      Początkowy  ! w wzfiltr powoduje negację wzorca; usuwane
                      są wówczas uzupełnienia nie pasujące do wzfiltr.

              Wartością zwracana jest  prawda,  chyba  że  podano  niepoprawną
              opcję,  podano  bez  argumentu  nazwa  opcję inną niż -p lub -r,
              usiłowano usunąć specyfikację uzupełniania dla nazwy, dla której
              nie  istnieje  żadna  specyfikacja,  albo  też podczas dodawania
              specyfikacji uzupełniania wystąpił błąd.

       compopt [-o opcja] [-DE] [+o opcja] [nazwa]
              Modyfikuje opcje uzupełniania dla każdej nazwy, zgodnie  z  opc‐
              jami lub dla właśnie wykonywanego uzupełnienia, jeśli nie podano
              nazwy. Jeśli nie podano opcji, wyświetla opcje uzupełniania  dla
              każdej   nazwy   lub   dla   bieżącego  uzupełniania.  Możliwymi
              wartościami opcji są opcje, które  są  poprawne  do  wbudowanego
              polecenia complete. Opcja -D oznacza, że pozostałe opcje powinny
              być  stosowane  do  "domyślnego"  polecenia  uzupełniania,  tzn.
              uzupełniania,  którego  próbę  przeprowadzono dla polecenia, dla
              którego nie zdefiniowano wcześniej uzupełnień. Opcja -E oznacza,
              że  pozostałe opcje powinny być zastosowane do "pustego" polece‐
              nia uzupełniania, tzn. uzupełnienia, którego  próbę  przeprowad‐
              zono na pustym wierszu.

              Zwracaną  wartością  jest  prawda, chyba że podano nieprawidłową
              opcję, przeprowadzono próbę zmodyfikowania opcji dla nazwy,  dla
              której  nie istnieje specyfikacja uzupełniania lub wystąpił błąd
              wyjścia.

       continue [n]
              Wznawia następną iterację obejmującej je pętli for, while, until
              lub  select.  Jeżeli podano n, wznawia n-tą obejmującą pętlę.  n
              musi być ≥ 1. Jeżeli n  jest  większe  niż  liczba  obejmujących
              pętli,  to  wznawiana  jest  ostatnia  z  pętli  (,,najwyższa”).
              Wartość zwracana wynosi 0, chyba że powłoka nie  wykonuje  pętli
              podczas wykonywania continue.

       declare [-aAfFgilrtux] [-p] [nazwa[=wartość]]
       typeset [-aAfFgilrtux] [-p] [nazwa[=wartość]]
              Deklaruje  zmienne  i/lub  nadaje im atrybuty.  Jeśli nie podano
              żadnych nazw, wyświetla wartości  zmiennych.   Opcja  -p  będzie
              wyświetlać atrybuty i wartości każdej nazwy. Gdy używane jest -p
              z argumentem nazwa, ignorowane  są  dodatkowe  opcje.  Opcja  -p
              podana bez argumentów nazwa wyświetli atrybuty i wartości wszys‐
              tkich zmiennych posiadających atrybuty określone przez dodatkowe
              opcje.  Jeśli  nie  podano  innych opcji z -p, declare wyświetli
              atrybuty i  wartości  wszystkich  zmiennych  powłoki.  Opcja  -f
              ograniczy  wyświetlanie  do  funkcji  powłoki. Opcja -F zabrania
              wyświetlania definicji funkcji;  wypisywane  są  tylko  nazwy  i
              atrybuty  funkcji.   Jeśli  włączono opcję powłoki extdebug przy
              użyciu shopt, to wyświetlane są również nazwa pliku źródłowego i
              numer wiersza, w którym zdefiniowano funkcję. Opcja -F implikuje
              -f. Opcja  -f  wymusza  tworzenie  i  modyfikację  zmiennych  na
              poziomie  globalnym, nawet gdy declare jest wykonywane w funkcji
              powłoki. Jest ona ignorowana we wszystkich  innych  przypadkach.
              Poniższych opcji można użyć do ograniczenia wyników do zmiennych
              o określonym atrybucie lub do nadania zmiennym atrybutów:
              -a     Każda z nazw jest indeksowaną zmienną  tablicową  (zobacz
                     Tablice powyżej).
              -A     Każda  z  nazw jest asocjacyjną zmienną tablicową (zobacz
                     Tablice powyżej).
              -f     Używa wyłącznie nazw funkcji.
              -i     Zmienna jest traktowana jak całkowita; gdy zmiennej  jest
                     przypisywana   wartość,   wykonywana  jest  interpretacja
                     wyrażeń arytmetycznych (zobacz OBLICZANIE  WYRAŻEŃ  ARYT‐
                     METYCZNYCH).
              -l     Gdy zmiennej przypisano wartość, wszystkie wielkie litery
                     są zamieniane na małe.  Przypisania  za  pomocą  wielkich
                     liter są wyłączone.
              -r     Powoduje, że dane nazwy stają się tylko-do-odczytu (read‐
                     only).   Nazwom  tym   nie   można   przypisać   wartości
                     następnymi  poleceniami  przypisania.   Nie można też ich
                     usunąć za pomocą unset.
              -t     Nadaje każdej nazwie atrybut trace. Funkcje z  tym  atry‐
                     butem  dziedziczą pułapki DEBUG i RETURN z wywołującej je
                     funkcji. Atrybut ten nie  ma  specjalnego  znaczenia  dla
                     zmiennych.
              -u     Gdy zmiennej przypisano wartość, wszystkie małe litery są
                     zamieniane na wielkie. Przypisania za pomocą małych liter
                     są wyłączone.
              -x     Zaznacza  nazwę  do  wyeksportowania  przez środowisko do
                     kolejnych poleceń.

              Użycie `+' zamiast `-' wyłącza atrybut, z wyjątkiem tego, że  +a
              nie może być używane do niszczenia zmiennej tablicowej. a +r nie
              usunie atrybutu tylko do odczytu. Użyte w funkcji, powodują,  że
              każda z nazw staje się lokalna, jak przy pomocy polecenia local,
              chyba że podano opcję -g. Jeśli po zmiennej występuje  =wartość,
              to  wartość  zmiennej  jest  ustawiana na wartość. Zwracana jest
              wartość 0, chyba że napotkano niepoprawną opcję,  próbę  zdefin‐
              iowania funkcji przy pomocy ``-f foo=bar'', przypisania wartości
              zmiennej readonly, przypisania wartości zmiennej tablicowej  bez
              użycia  składni  przypisania złożonego (zobacz Tablice powyżej),
              jedna z nazw nie jest poprawną nazwą zmiennej powłoki, usiłowano
              wyłączyć status readonly dla zmiennej tylko do odczytu, wyłączyć
              status tablicy dla zmiennej tablicowej albo próbowano wyświetlić
              nieistniejącą funkcję przy pomocy -f.

       dirs [+n] [-n] [-clpv]
              Bez  opcji  wyświetla  listę  aktualnie zapamiętanych katalogów.
              Domyślnie wyświetlana jest ona w pojedynczym wierszu, z  nazwami
              katalogów rozdzielonymi spacjami.  Katalogi dodawane są do listy
              poleceniem pushd polecenie popd usuwa pozycje z listy.
              +n     Wyświetla ntą pozycję licząc od lewej na  liście  pokazy‐
                     wanej  przez  dirs  przy  wywołaniu bez opcji; początkową
                     jest zero.
              -n     Wyświetla ntą pozycję licząc od prawej na liście  pokazy‐
                     wanej  przez  dirs  przy  wywołaniu bez opcji; początkową
                     jest zero.
              -c     Czyści stos katalogów usuwając wszystkie jego pozycje.
              -l     Tworzy  dłuższy  listing;   domyślnie   format   listingu
                     posługuje się tyldą do oznaczania katalogu domowego.
              -p     Wypisuje stos katalogów po jednej pozycji na wiersz.
              -v     Wypisuje  stos  katalogów  po  jednej  pozycji na wiersz,
                     poprzedzając  każdą  z  nich  jej  pozycją  (indeksem)  w
                     stosie.

              Wartością  zwracaną  jest 0, chyba że podano nieprawidłową opcję
              lub n wskazuje poza koniec stosu katalogów.

       disown [-ar] [-h] [zadanie ...]
              Bez opcji, każde z podanych zadań usuwane jest z  tablicy  zadań
              aktywnych. Jeśli nie podano zadania i nie użyto ani opcji -a ani
              -r, to używane jest zadanie bieżące  w  pojęciu  powłoki.  Jeśli
              użyto  opcji  -h,  każde zadanie nie jest usuwane z tablicy, ale
              jest jako takie zaznaczane, tak że do zadania nie jest  wysyłany
              sygnał  SIGHUP jeśli powłoka otrzymuje SIGHUP.  Jeśli nie podano
              zadania i nie użyto ani opcji -a ani -r, to używane jest zadanie
              bieżące.   Jeżeli podano zadanie, opcja -a oznacza usunięcie lub
              zaznaczenie wszystkich zadań; opcja  -r  bez  argumentu  zadania
              ogranicza  akcję do działających zadań.  Wartością zwracaną jest
              0, chyba że zadanie nie określa poprawnego zadania.

       echo [-neE] [argument ...]
              Wyświetla argumenty, rozdzielone  spacjami,  zakończone  znakiem
              nowej linii. Kodem zakończenia jest zawsze 0.  Jeżeli podano -n,
              to nie jest wysyłany kończący znak nowej linii.   Jeżeli  podano
              opcję  -e,  włączana  jest  interpretacja  podanych niżej znaków
              specjalnych. Opcja -E wyłącza interpretację tych  znaków,  nawet
              na  systemach, gdzie są one domyślnie interpretowane.  Do dynam‐
              icznego sprawdzania, czy echo interpretuje domyślnie  te  znaki,
              czy nie, służy opcja powłoki xpg_echo.  echo nie interpretuje --
              jako oznaczenia końca opcji.  echo interpretuje następujące sek‐
              wencje specjalne:
              \a     alarm (dzwonek)
              \b     backspace
              \c     pomiń kończący znak nowej linii
              \e
              \E     znak escape
              \f     znak wysuwu strony (form feed)
              \n     znak nowego wiersza (new line)
              \r     powrót karetki (carriage return)
              \t     tabulacja pozioma (horizontal tab)
              \v     tabulacja pionowa (vertical tab)
              \\     odwrotny ukośnik (backslash)
              \0nnn  ośmiobitowy  znak, którego wartością jest ósemkowa liczba
                     nnn (jedna do trzech cyfr)
              \xHH   ośmiobitowy znak,  którego  wartością  jest  szesnastkowa
                     liczba nnn (jedna lub dwie cyfry szesnastkowe)
              \uHHHH znak  Unicode  (ISO/IEC  10646)  o wartości szesnastkowej
                     HHHH (jedna do czterech cyfr szesnastkowych)
              \UHHHHHHHH
                     znak Unicode (ISO/IEC  10646)  o  wartości  szesnastkowej
                     HHHHHHHH (jedna do ośmiu cyfr szesnastkowych)

       enable [-a] [-dnps] [-f plik] [nazwa ...]
              Włącza   i  wyłącza  wbudowane  polecenia  powłoki.   Wyłączenie
              poleceń  wbudowanych  umożliwia  wykonanie  polecenia  dyskowego
              mającego  tę samą nazwę, co wbudowane, bez podawania jego pełnej
              nazwy ścieżkowej, mimo iż powłoka normalnie szuka  poleceń  wbu‐
              dowanych  przed  poleceniami  dyskowymi.   Jeżeli  posłużono się
              opcją -n, wyłączana jest każda z nazw; w przeciwnym razie  nazwy
              są  włączone.   Na  przykład,  chcąc  użyć  pliku binarnego test
              znalezionego przez PATH zamiast  wersji  wbudowanej  w  powłokę,
              należy   uruchomić   ``enable   -n  test''.   Opcja  -f  oznacza
              załadowanie  nowego  polecenia  wbudowanego  nazwa   z   obiektu
              dzielonego  (shared  object)   plik,  na systemach obsługujących
              dynamiczne  ładowanie.   Opcja  -d  usunie  polecenie  wbudowane
              załadowane poprzednio przez -f.  Jeżeli nie podano żadnych argu‐
              mentów nazwa lub jeśli podano opcję -p,  wypisywana  jest  lista
              poleceń  wbudowanych  powłoki.  Bez innych argumentów opcyjnych,
              lista ta  składa  się  ze  wszystkich  włączonych  poleceń  wbu‐
              dowanych.   Jeśli  podano  -n,  wypisywane  są  tylko  wyłączone
              polecenia wbudowane.  Jeżeli podano -a, wypisywana lista zawiera
              wszystkie  polecenia  wbudowane,  ze  wskazaniem przy każdym czy
              jest ono włączone  czy  też  nie.   Jeżeli  podano  -s,  wyjście
              ograniczone  jest  do  POSIX-owych  ,,specjalnych”  poleceń wbu‐
              dowanych.  Wartością zwracaną jest 0, chyba że  nazwa  nie  jest
              poleceniem  wbudowanym powłoki lub wystąpił błąd podczas ładowa‐
              nia nowego polecenia wbudowanego z obiektu dzielonego.

       eval [argument ...]
              Argumenty są czytane i łączone w pojedyncze polecenie.   Polece‐
              nie  to  jest  następnie odczytywane i wykonywane przez powłokę,
              zaś jego  kod  zakończenia  jest  zwracany  jako  wartość  eval.
              Jeżeli  nie  na  żadnych  argumentów, lub wszystkie argumenty są
              puste, eval zwraca 0.

       exec [-cl] [-a nazwa] [polecenie [argumenty]]
              Jeżeli podano polecenie, zastępuje ono  powłokę.   Nie  tworzony
              jest żaden nowy proces.  Argumenty stają się argumentami polece‐
              nia.  Jeśli  podano  opcję  -l,  umieszcza  kreskę  na  początku
              zerowego  argumentu  przesyłanego  do  polecenia.  Tak samo, jak
              robi to login(1).  Opcja  -c  powoduje,  że  polecenie  zostanie
              wykonane  z  pustym  środowiskiem.  Jeżeli  podano  -a,  powłoka
              przesyła do wykonywanego polecenia nazwę jako  zerowy  argument.
              Jeżeli  polecenie z jakiegoś powodu nie może zostać wykonane, to
              powłoka nie-interaktywna kończy pracę, chyba  że  włączona  jest
              opcja  powłoki  execfail, wówczas zwraca niepowodzenie.  Powłoka
              interaktywna zwraca niepowodzenie jeśli  plik  nie  może  zostać
              wykonany.   Jeżeli nie podano polecenia, przekierowania skutkują
              w bieżącej powłoce, a kodem  zakończenia  jest  0.  W  przypadku
              błędu przekierowania kod zakończenia wynosi 1.

       exit [n]
              Powoduje,  że  powłoka  kończy  pracę  z  kodem  równym n. Jeśli
              pominięto n, kodem zakończenia jest  kod  ostatniego  wykonanego
              polecenia.   Przed  końcem pracy powłoki wykonywane jest przech‐
              wycenie sygnału EXIT.

       export [-fn] [nazwa[=słowo]] ...
       export -p
              Podane nazwy zaznaczane są do automatycznego wyeksportowania  do
              środowiska  następnych  wykonywanych poleceń. Jeśli podano opcję
              -f, to nazwy odnoszą się do funkcji.  Jeżeli nie podano  żadnych
              nazw lub jeżeli podano opcję -p, to wypisywana jest lista wszys‐
              tkich eksportowanych w tej  powłoce  nazw.   Opcja  -n  powoduje
              usunięcie  cechy  eksportowania  z  podanych zmiennych. Jeśli po
              nazwie zmiennej  występuje  =słowo,  to  wartość  zmiennej  jest
              ustawiana  na słowo. export zwraca zerowy kod zakończenia, chyba
              że napotkano nieprawidłową opcję, jedna z nazw nie jest poprawną
              nazwą  zmiennej  powłoki  lub  podano -f z nazwą, która nie jest
              funkcją.

       fc [-e nazwa_e] [-lnr] [pierwsze] [ostatnie]
       fc -s [wzorzec=zastąpienie] [polecenie]
              Polecenie poprawiania (Fix Command).   W  pierwszej  postaci,  z
              listy  historii  wybierany  jest zakres poleceń od pierwszego do
              ostatniego.  Pierwsze i ostatnie mogą być podawane jako  łańcuch
              (do  odnalezienia  ostatniego polecenia rozpoczynającego się tym
              łańcuchem) lub jako liczba  (indeks  w  liście  historii,  gdzie
              liczba  ujemna  używana  jest  jako  offset  od numeru bieżącego
              polecenia), Jeżeli nie określono ostatniego, to jest ono  ustaw‐
              iane na bieżące polecenie w przypadku listowania (tak że ``fc -l
              -10'' wypisuje ostatnich 10 poleceń) i na pierwsze w pozostałych
              przypadkach.  Jeżeli nie określono pierwszego polecenia, to jest
              ono ustawiane na poprzednie polecenie w przypadku  edycji  a  na
              -16 przy listowaniu.

              Opcja  -n  wstrzymuje  wyświetlanie numerów poleceń podczas lis‐
              towania.  Opcja -r odwraca  kolejność  poleceń.   Jeżeli  podano
              opcję  -l,  to polecenia listowane są na standardowym wyjściu. W
              przeciwnym razie dla pliku zawierającego te polecenia wywoływany
              jest  edytor  podany  przez nazwa_e.  Jeżeli nie podano nazwa_e,
              używana jest wartość FCEDIT, a wartość EDITOR jeśli  nie  ustaw‐
              iono  FCEDIT.   Jeżeli nie ustawiono żadnej z nich, używany jest
              vi  Po  zakończeniu  edycji,  wysyłane  edytowane  polecenia  są
              wyświetlane przez echo i wykonywane.

              W  drugiej postaci, polecenie jest ponownie wykonywane po każdej
              wymianie  wystąpienia  wzorca  przez  zastąpienie.    Przydatnym
              aliasem  do wykorzystania z tą formą jest ``r="fc -s"'', tak, że
              napisanie ``r cc'' uruchamia ostatnie  polecenie  rozpoczynające
              się  od  ``cc''  a  napisanie  ``r''  ponownie wykonuje ostatnie
              polecenie.

              Jeżeli użyta została pierwsza postać, to wartością zwracaną jest
              0,  chyba  że  napotkano  nieprawidłową  opcję lub pierwszy albo
              ostatni określają wiersze historii spoza zakresu.  Jeżeli podano
              opcję  -e, wartością zwracaną jest wartość ostatniego wykonanego
              polecenia lub niepowodzenie jeśli pojawił się błąd  tymczasowego
              pliku  poleceń.  Jeżeli użyta została druga postać, to zwracanym
              kodem jest kod ponownie wykonanego polecenia, chyba że polecenie
              nie  określa  poprawnego  wiersza  poleceń  -- wówczas fc zwraca
              porażkę.

       fg [zadanie]
              Wznawia  zadanie  na  pierwszym  planie  i  czyni  je   zadaniem
              bieżącym.   Jeżeli  nie  podano  zadania,  używane  jest bieżące
              zadanie w pojęciu  powłoki.   Wartością  zwracaną  jest  wartość
              polecenia  umieszczonego na pierwszym planie, lub porażka jeżeli
              fb uruchomiono przy wyłączonej kontroli zadań,  lub  uruchomiono
              je  przy  włączonej  kontroli  zadań,  ale  zadanie  nie określa
              prawidłowego zadania lub zadanie określa zadanie, które  zostało
              uruchomione bez kontroli zadań.

       getopts łańcuch_opcji nazwa [argumenty]
              getopts   używane   jest  przez  procedury  powłoki  do  analizy
              parametrów pozycyjnych.   Łańcuch  opcji  zawiera  znaki  opcji,
              jakie   mają   być   rozpoznawane;  jeżeli  po  znaku  występuje
              dwukropek, to oczekuje się, że opcja będzie  posiadać  argument,
              który  powinien  być  od  niej  oddzielony białym znakiem.  Jako
              znaki opcji nie mogą wystąpić dwukropek i znak zapytania.   Przy
              każdym  wywołaniu  getopts  umieszcza  następną opcję w zmiennej
              powłoki  nazwa,  inicjując  nazwę  jeśli  nie  istniała.  Indeks
              następnego  argumentu do przetwarzania umieszczany jest w zmien‐
              nej OPTIND.  OPTIND inicjowany jest na 1 za  każdym  razem,  gdy
              wywoływana  jest  powłoka  lub  skrypt powłoki. Gdy opcja wymaga
              argumentu, getopts umieszcza go w zmiennej OPTARG.  Powłoka  nie
              resetuje  OPTIND  automatycznie;  musi być on resetowany ręcznie
              pomiędzy  wielokrotnymi  odwołaniami  do  getopts  w  tym  samym
              wywołaniu powłoki, jeśli używany ma być nowy zestaw parametrów.

              Po  napotkaniu  końca  opcji,  getopts  kończy  pracę  zwracając
              wartość większą od zera.  OPTIND ustawiane jest na indeks  pier‐
              wszego argumentu nie będącego opcją, zaś nazwa ustawiana jest na
              ?.

              getopts normalnie analizuje parametry  pozycyjne,  ale  jeśli  w
              argumentach,  podano więcej argumentów, to getopts przetwarza je
              zamiast parametrów pozycyjnych.

              getopts może zgłaszać błędy na  dwa  sposoby.  Jeżeli  pierwszym
              znakiem  łańcucha  opcji jest dwukropek, to stosowane jest ciche
              (silent) zgłaszanie błędów. Przy zwykłej pracy komunikaty  diag‐
              nostyczne  wypisywane  są  przy napotkaniu nieprawidłowych opcji
              lub brakujących argumentów opcji.  Jeżeli zmienna OPTERR  ustaw‐
              iona  jest  na  0, nie będą wyświetlane żadne komunikaty błędów,
              nawet jeśli pierwszym znakiem łańcucha opcji nie jest dwukropek.

              Przy napotkaniu  nieprawidłowej  opcji  getopts  umieszcza  ?  w
              nazwie  i, jeśli nie pracuje w trybie cichym, wypisuje komunikat
              błędu i kasuje OPTARG.  Jeżeli getopts pracuje w trybie  cichym,
              to  znaleziony  znak  opcji umieszczany jest w OPTARG i nie jest
              wypisywany żaden komunikat diagnostyczny.

              Jeśli nie znaleziono wymaganego argumentu, a getopts nie pracuje
              w  trybie  cichym,  w nazwa umieszczany jest znak zapytania (?),
              kasowane jest OPTARG i wyświetlany jest komunikat błędu.  Jeżeli
              getopts  pracuje  w  trybie cichym, to w nazwie umieszczany jest
              dwukropek (:), a OPTARG ustawiane jest na znaleziony znak opcji.

              getopts  zwraca  prawdę,  jeśli  znaleziono  określoną  lub  nie
              określoną opcję.  Zwraca fałsz jeżeli napotkano koniec opcji lub
              pojawił się błąd.

       hash [-lr] [-p plik] [-dt] [nazwa]
              Dla każdej nazwy określana  i  zapamiętywana  jest  pełna  nazwa
              plikowa  polecenia wyszukanego w katalogach $PATH. Jeżeli podano
              opcję -p, nie  jest  wykonywane  przeszukanie  ścieżki,  a  plik
              używane  jest  jako  pełna  nazwa  pliku  polecenia.   Opcja  -r
              powoduje, że powłoka zapomina  wszystkie  zapamiętane  wcześniej
              miejsca.  Opcja  -d  powoduje,  że  powłoka  zapomina  wszystkie
              zapamiętane wcześniej miejsca dla  każdej  nazwy.  Jeśli  podano
              opcję  -t,  to  wypisywana jest odpowiadająca nazwie pełna nazwa
              pliku.  Jeżeli przy więcej niż jednym  argumencie  nazwy  podano
              -t,  to  przed  każdą  przechowywaną pełną nazwą wypisywana jest
              nazwa.  Opcja -l powoduje wyświetlanie wyniku w formacie,  który
              może  zostać  ponownie  wykorzystany  jako  wejście.  Jeżeli nie
              podano żadnych  argumentów,  to  wypisywana  jest  informacja  o
              zapamiętanych  poleceniach.   Kodem zwracanym jest prawda, chyba
              że nie odnaleziono nazwy lub podano nieprawidłową opcję.

       help [-dms] [wzorzec]
              Wyświetla pomocne informacje o poleceniach  wbudowanych.  Jeżeli
              podano wzorzec, to help daje szczegółową pomoc dotyczącą wszyst‐
              kich poleceń pasujących do wzorca; w przeciwnym razie wypisywana
              jest   pomoc  dla  wszystkich  poleceń  wbudowanych  i  struktur
              sterujących powłoki.
              -d     Wyświetla krótki opis dla każdego wzorca
              -m     Wyświetla opis dla każdego wzorca w formacie podobnym  do
                     strony man
              -s     Wyświetla  jedynie  krótkie  podsumowanie  użycia każdego
                     wzorca

              Kodem zakończenia jest  0,  chyba  nie  nie  dopasowano  żadnego
              polecenia do wzorca.

       history [n]
       history -c
       history -d przesunięcie
       history -anrw [plik]
       history -p arg [arg ...]
       history -s arg [arg ...]
              Bez  żadnych  opcji, wyświetla listę historii poleceń z numerami
              wierszy.  Wiersze ukazane z  *  zostały  zmienione.  Argument  n
              pokazuje  jedynie  ostatnich  n wierszy. Jeśli ustawiono zmienną
              powłoki HISTTIMEFORMAT i nie jest ona pusta, to do  wyświetlania
              pieczątek czasowych związanych z każdym wyświetlanym wpisem his‐
              torii używany jest format łańcucha do strftime(3). Pomiędzy for‐
              matowaną  pieczątką  czasową a wierszem historii nie jest wstaw‐
              iany odstęp. Jeżeli podano plik, to używany jest on  jako  nazwa
              pliku  historii;  jeśli  nie,  to używana jest wartość HISTFILE.
              Opcje, jeżeli je podano, mają następujące znaczenie:
              -c     Czyści listę historii usuwając wszystkie jej pozycje.
              -d przesunięcie
                     Usuwa wpis historii z pozycji przesunięcie.
              -a     Dodaje ,,nowe” wiersze (wprowadzone od początku  bieżącej
                     sesji bash)  do pliku historii.
              -n     Wczytuje  do  bieżącej listy wiersze jeszcze nie przeczy‐
                     tane z pliku historii. Są to wiersze dołączone  do  pliku
                     historii od chwili rozpoczęcia bieżącej sesji pracy bash.
              -r     Czyta  zawartość  pliku historii i posługuje się nią jako
                     bieżącą listą historii.
              -w     Zapisuje bieżącą listę do pliku historii, nadpisując jego
                     zawartość.
              -p     Na  zadanych  argumentach  wykonuje podstawianie historii
                     (history substitution). Wyświetla wyniki na  standardowym
                     wyjściu.  Nie zachowuje wyników na liście.  Każdy z argu‐
                     mentów musi być cytowany, by wyłączyć normalną  interpre‐
                     tację historii.
              -s     Zachowuje  argumenty  na  liście historii jako pojedynczą
                     pozycję. Przed dodaniem argumentów z listy  usuwane  jest
                     ostatnie polecenie.

              Jeśli  ustawiona  jest  zmienna HISTTIMEFORMAT, to do pliku his‐
              torii zapisywana jest informacja o  czasie  związanym  z  każdym
              wpisem historii, oznaczona znakiem komentarza historii. Gdy plik
              historii  jest  odczytywany,  wiersze  zaczynające  się  znakiem
              komentarza  historii, po którym występuje bezpośrednio cyfra, są
              interpretowane  jako  czasy   poprzedniego   wiersza   historii.
              Wartością  zwracaną  jest  0,  chyba  że napotkano nieprawidłową
              opcję lub podczas odczytu czy zapisu pliku historii pojawił  się
              błąd,  podano  niepoprawny  argument  offset  opcji  -d, lub nie
              powiodła się interpretacja historii podanej jako argument -p.

       jobs [-lnprs] [ zadanie ... ]
       jobs -x polecenie [ argumenty ... ]
              Pierwsza postać podaje aktywne zadania. Opcje  mają  następujące
              znaczenie:
              -l     Oprócz zwykłej informacji podaje identyfikatory procesów.
              -n     Wyświetla   wyłącznie   informację   o  zadaniach,  które
                     zmieniły status od chwili, gdy  użytkownik  był  ostatnio
                     powiadamiany o ich statusie.
              -p     Listuje tylko ID procesu lidera grupy procesów zadania.
              -r     Ogranicz wyniki do zadań pracujących.
              -s     Ogranicz wyniki do zadań zatrzymanych.

              Jeżeli podano zadanie, wyniki ograniczane są do informacji o tym
              zadaniu.   Kodem  zwracanym   jest   0,   chyba   że   napotkano
              nieprawidłową opcję lub podano nieprawidłowe zadanie.

              Jeżeli  podano  opcję  -x,  to  jobs  zastępuje wszelkie zadania
              znalezione w poleceniu lub argumentach odpowiednim ID grupy pro‐
              cesów,  wykonuje  polecenie  przesyłając  mu argumenty, i zwraca
              jego kod zakończenia.

       kill [-s sigspec | -n signum | -sigspec] [pid | jobspec] ...
       kill -l [sigspec | exit_status]
              Wysyła sygnały określony przez sigspec  lub  signum  do  procesu
              określonego  przez  pid  lub  jobspec.   sigspec jest albo nazwą
              sygnału, jak np.  SIGKILL  (z  lub  bez  przedrostka  SIG)  albo
              numerem  sygnału;  signum jest numerem sygnału. Jeśli nie podano
              sigspec, to przyjmuje  się  SIGTERM.   Opcja  -l  listuje  nazwy
              sygnałów.   Jeżeli  przy podanym -l użyto jakichś argumentów, to
              listowane są  sygnały  odpowiadające  tym  argumentom,  a  kodem
              zwracanym  jest  0.   Argument  exit_status opcji -l jest liczbą
              określającą numer sygnału lub  kod  zakończenia  procesu  przer‐
              wanego  przez  sygnał.   kill  zwraca prawdę, jeśli przynajmniej
              jeden z sygnałów został pomyślnie przesłany,  lub  fałsz,  jeśli
              pojawił się błąd lub napotkano niepoprawną opcję.

       let arg [arg ...]
              Każdy  argument  jest  wyrażeniem arytmetycznym, jakie ma zostać
              zinterpretowane  (zobacz  OBLICZANIE  WYRAŻEŃ   ARYTMETYCZNYCH).
              Jeżeli  ostatni  z  nich  interpretowany  jest jako zero, to let
              zwraca 1; w przeciwnym wypadku zwracane jest 0.

       local [opcja] [nazwa[=wartość] ...]
              Dla każdego argumentu tworzona jest  zmienna  lokalna  o  nazwie
              nazwa  i  jest jej przypisywana wartość.  Opcją może być każda z
              opcji akceptowanych  przez  declare.   Gdy  local  używane  jest
              wewnątrz   funkcji,   powoduje,   że  zmienna  nazwa  ma  zasięg
              widzialności ograniczony do tej funkcji i jej potomków.  Bez op‐
              erandów,  local  wysyła listę zmiennych lokalnych na standardowe
              wyjście. Błędem jest użycie local poza funkcją.   Zwracany  jest
              kod  0,  chyba  że  local zostanie użyte poza funkcją lub podano
              nieprawidłową nazwę, albo nazwa jest zmienną tylko do odczytu.

       logout Kończy pracę powłoki zgłoszeniowej.

       mapfile [-n liczba] [-O indeks] [-s liczba] [-t] [-u fd] [-C wywoł-zwr]
       [-c wielkość] [tablica]
       readarray  [-n  liczba]  [-O  indeks]  [-s  liczba]  [-t]  [-u  fd] [-C
       wywoł-zwr] [-c wielkość] [tablica]
              Odczytuje wiersze ze standardowego wejścia do indeksowanej  zmi‐
              ennej  tablicowej tablica lub, jeśli podano opcję -u, z deskryp‐
              tora pliku fd. Domyślną  tablicą  jest  zmienna  MAPFILE  Opcje,
              jeśli je podano, mają następujące znaczenie:
              -n     Kopiuje  najwyżej  liczbę  wierszy.  Gdy liczba wynosi 0,
                     kopiowane są wszystkie wiersze.
              -O     Rozpoczyna przypisywanie do tablicy  od  indeksu  indeks.
                     Domyślnym jest 0.
              -s     Pomija pierwsze liczba wierszy.
              -t     Usuwa  końcowe znaki nowego wiersza z każdego odczytanego
                     wiersza.
              -u     Odczytuje wiersze z deskryptora pliku fd zamiast ze stan‐
                     dardowego wejścia.
              -C     Oblicza  wywoł-zwr  po  każdym odczytaniu liczby wielkość
                     wierszy. Opcja -c określa wielkość.
              -c     Określa  liczbę  wierszy  odczytanych   pomiędzy   każdym
                     odwołaniem do wywoł-zwr.

              Jeśli  podano  -C  bez -c, to domyślną wielkością jest 5000. Gdy
              wykonywane jest wywoł-zwr, jako dodatkowe argumenty przekazywane
              są  mu indeks następnego elementu tablicy do przypisania i wier‐
              sza, który ma być przypisy  do  tego  elementu.  Wywoł-zwr  jest
              wykonywane  po  odczytaniu  wiersza, ale przed przypisaniem ele‐
              mentu tablicy.

              Jeśli nie podano indeksu, mapfile wyczyści tablicę przed  przyp‐
              isaniem do niej wartości.

              Polecenie  mapfile  zwraca sukces, chyba że podano nieprawidłową
              opcję lub argument opcji, tablica jest nieprawidłowa, nie da się
              do niej przypisać wartości lub nie jest tablicą indeksowaną.

       popd [-n] [+n] [-n]
              Usuwa  pozycje ze stosu katalogów. Bez argumentów, usuwa katalog
              z wierzchołka stosu i wykonuje cd do nowego katalogu  na  wierz‐
              chołku.  Argumenty, jeśli występują, mają następujące znaczenie:
              -n     Nie  wykonuje  zwykłej  zmiany  katalogu podczas usuwania
                     katalogów ze stosu, tak że zmieniany jest tylko stos.
              +n     Usuwa ntą pozycję, licząc  od  lewej,  listy  pokazywanej
                     przez  dirs,  zaczynając od zera. Na przykład ``popd +0''
                     usuwa pierwszy katalog, a ``popd +1'' drugi.
              -n     Usuwa ntą pozycję, licząc od  prawej,  listy  pokazywanej
                     przez  dirs,  zaczynając od zera. Na przykład ``popd -0''
                     usuwa ostatni katalog, a ``popd -1'' przedostatni.

              Jeżeli polecenie popd powiedzie się, to wykonywane jest  również
              dirs,  a  kodem  zwracanym  jest  0.   popd  zwraca  fałsz jeśli
              napotkano nieprawidłową opcję, stos katalogów jest pusty, podano
              nieistniejącą pozycję stosu lub nie udała się zmiana katalogu.

       printf [-v zmienna] format [argumenty]
              Zapisuje  sformatowane  argumenty  na  standardowe  wyjście przy
              pomocy zadanego formatu. Opcja -v przypisuje wynik  do  zmiennej
              zmienna zamiast wyświetlać je na standardowe wyjściowe.

              format   jest   łańcuchem  znakowym  zawierającym  trzy  rodzaje
              obiektów: zwykłe znaki, które są po prostu kopiowane na standar‐
              dowe wyjście, sekwencje specjalne, które są konwertowane i kopi‐
              owane na standardowe wyjście, i specyfikacje formatu, z  których
              każda powoduje wypisanie następnego kolejnego argumentu.  Oprócz
              standardowych  formatów  printf(1),  interpretuje   on   również
              następujące rozszerzenia:
              %b     powoduje,  że  printf  interpretuje sekwencje specjalne w
                     odpowiednim argumencie, (z wyjątkiem \c,  które  przerywa
                     wypisywanie,  odwrotnych  ukośników  w \', \" i \?, które
                     nie są usuwane i cytowań ósemkowych zaczynających się  od
                     \0, które mogą zawierać do czterech cyfr).
              %q     powoduje,  że  printf wysyła odpowiedni argument w forma‐
                     cie, jaki może być  ponownie  wykorzystany  jako  wejście
                     powłoki.
              %(format-daty)T
                     powoduje,  że  printf  wyświetla  łańcuch daty/czasu jako
                     rezultat użycia formatu-daty  jako  łańcucha  formatu  do
                     strftime(3).  Powiązany  argument  jest  liczba całkowitą
                     odpowiadającą liczbie sekund od początku epoki  [Uniksa].
                     Można  użyć  dwóch  specjalnych  wartości  argumentu:  -1
                     reprezentuje  bieżący  czas,  a  -2   odpowiada   czasowi
                     wywołania powłoki.

              Argumenty  do  specyfikacji  formatu  niebędących  łańcuchami są
              traktowane jako stałe C, z wyjątkiem początkowego znaku plus lub
              minus,  który  jest  dozwolony  oraz przypadku gdy pierwszy znak
              jest pojedynczym lub podwójnym apostrofem,  gdy  wartością  jest
              wartość ASCII następującego po cudzysłowie znaku.

              W  razie  potrzeby  format  wykorzystywany  jest ponownie, aż do
              obsłużenia wszystkich argumentów.  Jeżeli format wymaga większej
              ilości  argumentów niż podano, to dodatkowe specyfikacje formatu
              zachowują się tak,  jakby  dostarczono  im  odpowiednio  wartość
              zerową  lub  łańcuch  pusty.  Zwracana jest wartość zero w przy‐
              padku powodzenia, niezerowa przy porażce.

       pushd [-n] [+n] [-n]
       pushd [-n] [katalog]
              Dodaje katalog na wierzchołek stosu katalogów, albo obraca stos,
              czyniąc  nowy  wierzchołek  stosu  bieżącym katalogiem roboczym.
              Bez argumentów, zamienia miejscami dwa najwyższe katalogi  stosu
              [wierzchołek  i  następny] i zwraca 0, chyba że stos jest pusty.
              Argumenty, jeśli je podano, mają następujące znaczenie:
              -n     Nie wykonuje zwykłej zmiany  katalogu  podczas  dodawania
                     katalogów do stosu, tak że zmieniany jest tylko stos.
              +n     Obraca  stos,  tak  że nty katalog (licząc od lewej listy
                     pokazywanej przez dirs, poczynając od  zera)   staje  się
                     wierzchołkiem.
              -n     Obraca  stos,  tak że nty katalog (licząc od prawej listy
                     pokazywanej przez dirs, poczynając od  zera)   staje  się
                     wierzchołkiem.
              katalog
                     Odkłada  katalog  na  wierzchołek stosu, czyniąc go nowym
                     bieżącym katalogiem roboczym.

              Jeżeli polecenie pushd powiodło się, to wykonywane jest  również
              dirs.   Jeżeli  używana  jest pierwsza postać pushd, to zwracane
              jest 0, chyba że nie udało się  cd  na  katalog.   Przy  drugiej
              postaci,  pushd  zwraca  0,  chyba że stos katalogów jest pusty,
              podano nieistniejący element stosu lub nie powiodła  się  zmiana
              katalogu na zadany nowy katalog bieżący.

       pwd [-LP]
              Wypisuje  bezwzględną  nazwę pliku bieżącego katalogu roboczego.
              Pokazana nazwa nie zawiera żadnych dowiązań symbolicznych  jeśli
              podano opcję -P albo włączona jest opcja -o physical wbudowanego
              polecenia set.  Jeśli użyto opcji -L, wypisana  nazwa  ścieżkowa
              może  zawierać  dowiązania  symboliczne.  Zwracany kod wynosi 0,
              chyba że podczas odczytu nazwy  bieżącego  katalogu  pojawi  się
              błąd lub podano nieprawidłową opcję.

       read  [-ers]  [-a  anazwa]  [-d  znak-odst]  [-i tekst] [-n nznaki] [-N
       nznaki] [-p zachęta] [-t czas-oczek] [-u fd] [nazwa ...]
              Czytany jest pojedynczy wiersz ze standardowego  wejścia  lub  z
              deskryptora  pliku fd podanego jako argument do opcji -u, a jego
              pierwsze słowo jest  przypisywane  do  pierwszej  nazwy,  drugie
              słowo  do  drugiej  nazwy  i  tak  dalej, przy czym pozostałe na
              koniec słowa i rozdzielające je separatory przypisane zostaną do
              ostatniej  nazwy.   Jeżeli  ze standardowego wejścia przeczytano
              mniej słów niż  podanych  zostało  nazw,  to  pozostałym  nazwom
              przypisywane  są  puste  wartości.  Do podziału wiersza na słowa
              wykorzystywane są znaki z IFS.  Znaku  odwrotnego  ukośnika  (\)
              można  użyć  do  usunięcia specjalnego znaczenia następnego czy‐
              tanego znaku oraz do  oznaczenia  kontynuacji  wiersza.   Opcje,
              jeśli je podano, mają następujące znaczenie:
              -a anazwa
                     Słowa  są  przypisywane  do  kolejnych  indeksów zmiennej
                     tablicowej anazwa, poczynając od 0.  anazwa jest kasowana
                     przed przypisaniem nowych wartości.  Inne argumenty nazwa
                     są ignorowane.
              -d sep Pierwszy znak sep służy do zakończenia  wiersza  wejścia,
                     zamiast znaku nowej linii.
              -e     Jeżeli  standardowe  wejście  pochodzi z terminala, to do
                     uzyskania wiersza używane jest readline (zobacz  READLINE
                     powyżej). Readline używa bieżących (lub domyślnych, jeśli
                     edycja wiersza nie była wcześniej aktywna) ustawień  edy‐
                     cyjnych.
              -i tekst
                     Gdy  do odczytu wiersza jest używane readline, tekst jest
                     umieszczany w buforze edycyjnym przed  rozpoczęciem  edy‐
                     cji.
              -n nznaki
                     read  powraca  po  przeczytaniu  nznaki  znaków,  zamiast
                     czekać na cały  wiersz  wejścia,  ale  przestrzega  znaku
                     odstępu  jeśli  odczytano  mniej  niż nznaki znaków przed
                     odstępem.
              -N nznaki
                     Polecenie  read  powraca   pod   przeczytaniu   dokładnie
                     nznaków,  zamiast czekać na cały wiersz wejścia, chyba że
                     wystąpił koniec wiersza lub czas oczekiwania read  minął.
                     Znaki  odstępu  napotkane  w  wejściu nie są traktowane w
                     sposób specjalny i nie powodują powrotu read, dopóki  nie
                     zostanie przeczytanych nznaków.
              -p zachęta
                     Wyświetla   zachętę   (prompt)  na  standardowym  wyjściu
                     błędów, bez kończącego znaku  nowej  linii,  przed  próbą
                     odczytu  wejścia.   Zachęta  wyświetlana jest tylko jeśli
                     wejście pochodzi z terminala.
              -r     Odwrotny ukośnik nie działa jako  znak  specjalny.  Trak‐
                     towany  jest  jako  część  wiersza. W szczególności, para
                     odwrotny ukośnik-znak nowej linii nie może być  wykorzys‐
                     tana jako kontynuacja wiersza.
              -s     Tryb cichy. Jeżeli wejście pochodzi z terminala, to znaki
                     nie są powtarzane (bez echa).
              -t czas-oczek
                     Powoduje, że read zwraca  niepowodzenie,  jeśli  w  ciągu
                     czas-oczek  sekund  nie zostanie przeczytany pełny wiersz
                     wejścia.  Czas-oczek może być liczbą dziesiętną z częścią
                     ułamkową  po  znaku kropce. Opcja działa jedynie gdy read
                     odczytuje wejście z terminala, potoku  lub  innego  pliku
                     specjalnego,  nie  działa  natomiast  podczas czytania ze
                     zwykłych plików. Jeśli czas-oczek ustawiono na 0, to read
                     zwraca  sukces  jeśli wejście jest dostępne na określonym
                     deskryptorze pliku lub zwraca niepowodzenie w  przeciwnym
                     wypadku.  Kod  zakończenia  jest  większy  od  128, jeśli
                     przekroczono czas oczekiwania.
              -u fd  Czyta wejście z deskryptora pliku fd.

              Jeśli nie podano żadnych  nazw,  odczytany  wiersz  przypisywany
              jest  zmiennej REPLY.  Zwracany kod wynosi 0, chyba że napotkano
              koniec pliku lub read przekroczy czas oczekiwania (w takim przy‐
              padku  jest  on  większy  od 128) lub jako argument do -u podano
              nieprawidłowy deskryptor pliku.

       readonly [-aAf] [-p] [nazwa[=słowo] ...]
              Podane nazwy oznaczane są jako readonly; wartości tych nazw  nie
              mogą  być  zmieniane następującymi później przypisaniami.  Jeśli
              podano opcję -f, oznaczane są funkcje o nazwach  odpowiadających
              nazwom.   Opcja  -a ogranicza zmienne do tablic indeksowanych, a
              -A do tablic  asocjacyjnych.  Jeśli  podano  obie  opcje,  pier‐
              wszeństwo  ma  opcja  -A.  Jeśli  nie podano argumentów nazw lub
              jeśli podano opcję -p, wypisywane  jest  zestawienie  wszystkich
              nazw  o  atrybucie  readonly.   Inne  opcje mogą zostać użyte do
              ograniczenia  wyniku  do  podzbioru  nazw  readonly.  Opcja   -p
              powoduje,  że wyniki będą wyświetlane w formacie, który może być
              ponownie wykorzystany jako wejście.  Jeśli  po  nazwie  zmiennej
              występuje  =słowo,  to wartość zmiennej jest ustawiana na słowo.
              Zwracany jest kod równy  0,  chyba  że  napotkano  nieprawidłową
              opcję, jedna z nazw nie jest poprawną nazwą zmiennej powłoki lub
              podano -f z nazwą, która nie jest funkcją.

       return [n]
              Powoduje, że funkcja kończy pracę  zwracając  wartość  określoną
              przez  n.   Jeśli pominięto n, kodem zakończenia jest kod ostat‐
              niego polecenia wykonanego w  ciele  funkcji.   Jeżeli  zostanie
              użyte  poza  funkcją,  ale  podczas  wykonywania  skryptu  przez
              polecenie .  (source),  powoduje  zatrzymanie  wykonywania  tego
              skryptu  przez  powłokę i zwrócenie albo n albo kodu zakończenia
              ostatniego wykonanego w  skrypcie  polecenia.   Jeżeli  zostanie
              użyte  poza  funkcją  i nie podczas wykonywania skryptu przez .,
              zwracany jest fałsz.  Wszystkie  polecenia  związane  z  pułapką
              (trap)  RETURN  są  wykonywane  przez wznowieniem wykonywania po
              powrocie do funkcji lub skryptu.

       set [--abefhkmnptuvxBCEHPT] [-o opcja] [arg ...]
       set [+abefhkmnptuvxBCEHPT] [+o opcja] [arg ...]
              Bez opcji, wyświetlane są nazwa i wartość  każdej  ze  zmiennych
              powłoki,  w  formacie  który może być ponownie wykorzystany jako
              wejście do ustawiania lub ponownego ustawiania aktualnie  ustaw‐
              ionych zmiennych. Zmienne tylko do odczytu nie mogą być ponownie
              ustawiane.  W  trybie  posix,  wypisywane  są  jedynie   zmienne
              powłoki.  Wyniki  są  sortowane zgodnie z bieżącymi ustawieniami
              locale.  Gdy podane są opcje, ustawiają one lub kasują  atrybuty
              powłoki.   Argumenty pozostałe po przetworzeniu opcji traktowane
              są jako wartości parametrów pozycyjnych i przypisywane, kolejno,
              do  $1,  $2,  ...  $n.  Opcje, jeśli je podano, mają następujące
              znaczenie:
              -a      Automatycznie zaznacza zmienione lub utworzone zmienne i
                      funkcje  do  wyeksportowania ich do środowiska kolejnych
                      poleceń.
              -b      Natychmiast  podaje  status  zakończonych  zadań  drugo‐
                      planowych,  zamiast  czynić to przed następną podstawową
                      zachętą.  Działa  tylko  jeśli  włączona  jest  kontrola
                      zadań.
              -e      Zakończ natychmiast, jeśli potok (który może składać się
                      z pojedynczego polecenia powłoki), polecenie  podpowłoki
                      ujęte  w  nawiasy  lub jedno z poleceń wykonywanych jako
                      część listy poleceń ujętych w nawiasy  klamrowe  (zobacz
                      GRAMATYKA  POWŁOKI  powyżej) kończy pracę z kodem nieze‐
                      rowym. Powłoka nie kończy pracy jeśli  polecenie,  które
                      się  nie powiodło znajduje się zaraz za słowem kluczowym
                      while lub until, jest częścią  tekstu  po  słowach  zas‐
                      trzeżonych  if  lub  elif, jest częścią listy && lub ⎪⎪,
                      jest częścią każdego poza  ostatnim  poleceniem  potoku,
                      lub  wartość  zwrócona przez polecenie została odwrócona
                      przez !.  Przed zakończeniem  pracy  powłoki  wykonywana
                      jest  pułapka  na  sygnał  ERR, jeśli była ustawiona. Ta
                      opcja stosuje się do środowiska powłoki i oddzielnie  do
                      każdej  podpowłoki środowiska (zobacz ŚRODOWISKO WYKONY‐
                      WANIA POLECEŃ powyżej)  i  może  spowodować  zakończenie
                      podpowłok  przed  wykonaniem  wszystkich  poleceń w pod‐
                      powłoce.
              -f      Wyłącza rozwijanie nazw plików.
              -h      Zapamiętuje położenie poleceń przy wyszukiwania  ich  do
                      wykonania.  Domyślnie włączone.
              -k      Wszystkie  argumenty  występujące  w  postaci instrukcji
                      przypisania umieszczane są w środowisku  polecenia,  nie
                      zaś tylko te, które poprzedzają nazwę polecenia.
              -m      Tryb  monitorowania. Włączona jest kontrola zadań. Opcja
                      ta jest domyślnie włączona dla powłok interaktywnych  na
                      systemach  ją obsługujących (zobacz STEROWANIE ZADANIAMI
                      powyżej).  Procesy  drugoplanowe  działają  w   odrębnej
                      grupie  procesów  a  po  ich zakończeniu wypisywany jest
                      wiersz zawierający ich kod zakończenia.
              -n      Odczytuje polecenia, ale nie ich nie wykonuje. Może  być
                      wykorzystane  do  sprawdzenia  błędów składni w skrypcie
                      powłoki. Ignorowane przez powłoki interaktywne.
              -o nazwa-opcji
                      Nazwą-opcji może być jedna z poniższych:
                      allexport
                              To samo, co -a.
                      braceexpand
                              To samo, co -B.
                      emacs   Użyj interfejsu edycji wiersza poleceń  w  stylu
                              emacsa.  Włączone  domyślnie, jeśli powłoka jest
                              interaktywna, chyba  że  została  uruchomiona  z
                              opcją  --noediting.  Wpływa to również na inter‐
                              fejs edycyjny używany przez read -e.
                      errexit To samo, co -e.
                      errtrace
                              To samo, co -E.
                      functrace
                              To samo, co -T.
                      hashall To samo, co -h.
                      histexpand
                              To samo, co -H.
                      history Włącza historię poleceń, jak opisano  powyżej  w
                              sekcji   HISTORII.    Opcja  ta  jest  domyślnie
                              włączona w powłokach interaktywnych.
                      ignoreeof
                              Efekt jest taki, jakby zostało wykonane  polece‐
                              nie  powłoki  ``IGNOREEOF=10''  (zobacz  powyżej
                              Zmienne powłoki).
                      keyword To samo, co -k.
                      monitor To samo, co -m.
                      noclobber
                              To samo, co -C.
                      noexec  To samo, co -n.
                      noglob  To samo, co -f.
                      nolog   Obecnie ignorowane.
                      notify  To samo, co -b.
                      nounset To samo, co -u.
                      onecmd  To samo, co -t.
                      physical
                              To samo, co -P.
                      pipefail
                              Gdy  ustawione,  zwracana  wartość  potoku  jest
                              wartością   ostatniego  (po  prawej)  polecenia,
                              które zakończyło  się  z  kodem  niezerowym  lub
                              zero,   gdy   wszystkie   polecenia   w   potoku
                              zakończyły się sukcesem.  Opcja  jest  domyślnie
                              wyłączona.
                      posix   Zmienia  zachowanie  bash  tam,  gdzie  domyślne
                              działanie różni się od standardu POSIX,  tak  by
                              spełniać standard (tryb posix).
                      privileged
                              To samo, co -p.
                      verbose To samo, co -v.
                      vi      Używa  interfejsu edycji wiersza poleceń w stylu
                              vi. Wpływa  to  również  na  interfejs  edycyjny
                              używany przez read -e.
                      xtrace  To samo, co -x.
                      Jeżeli  podano  -o  bez  nazwy-opcji,  to  wypisywane są
                      wartości  bieżących  opcji.   Jeżeli   podano   +o   bez
                      nazwy-opcji,  na  standardowym  wyjściu wyświetlana jest
                      seria poleceń set potrzebnych do odtworzenia  aktualnych
                      ustawień opcji.
              -p      Włącza  tryb  uprzywilejowany (privileged). W tym trybie
                      pliki $ENV i  $BASH_ENV  nie  są  przetwarzane,  funkcje
                      powłoki  nie  są  dziedziczone  ze środowiska, a zmienne
                      SHELLOPTS,  BASHOPTS,   CDPATH   i   GLOBIGNORE,   jeśli
                      występują  w  środowisku,  są ignorowane.  Jeśli powłoka
                      została uruchomiona z efektywnym id użytkownika  (grupy)
                      różnym  od  id  rzeczywistego  a nie podano opcji -p, to
                      podejmowane  są  opisane  wyżej  akcje  a  efektywny  id
                      użytkownika jest ustawiany na identyfikator rzeczywisty.
                      Jeżeli przy uruchamianiu podano opcję -p,  to  efektywny
                      identyfikator użytkownika nie jest resetowany.  Wyłącze‐
                      nie tej  opcji  powoduje,  że  identyfikatory  efektywne
                      użytkownika  i grupy zostaną ustawione na identyfikatory
                      rzeczywiste.
              -t      Kończy pracę po przeczytaniu i wykonaniu jednego polece‐
                      nia.
              -u      Podczas  interpretacji  parametrów traktuje nieustawione
                      zmienne i parametry (poza parametrami specjalnymi "@"  i
                      "*")  jako błąd.  Jeżeli wykonywana jest próba interpre‐
                      tacji nieustawionej zmiennej, to powłoka wypisuje  komu‐
                      nikat  o  błędzie i, jeśli nie jest interaktywna, kończy
                      pracę z niezerowym kodem.
              -v      Wypisuje wiersze wejściowe powłoki przy  ich  odczytywa‐
                      niu.
              -x      Po  interpretacji  każdego  polecenia  prostego, poleceń
                      for, case i  select  lub  polecenia  arytmetycznego  for
                      wyświetla   zinterpretowaną   wartość   PS4,  po  której
                      następuje polecenie i jego zinterpretowane argumenty lub
                      powiązana lista słów.
              -B      Powłoka  wykonuje  interpretacją nawiasów (zobacz Inter‐
                      pretacja nawiasów powyżej). Domyślnie włączone.
              -C      Jeśli włączone, bash nie  nadpisuje  istniejącego  pliku
                      przy użyciu operatorów przekierowania >, >& i <>.  Można
                      to ominąć tworząc pliki wyjściowe przy użyciu  operatora
                      przekierowania >| zamiast >.
              -E      Gdy  ustawiona,  pułapka  ERR  jest  dziedziczona  przez
                      funkcje  powłoki,  uzupełnienia  poleceń   i   polecenia
                      wykonywane  w środowisku podpowłoki. Pułapka ERR normal‐
                      nie nie jest dziedziczona w takich przypadkach.
              -H      Włącza zastępowanie historii w stylu !.  Opcja  ta  jest
                      domyślnie włączona dla powłoki interaktywnej.
              -P      Jeżeli   jest   ustawiona,  to  powłoka  nie  podąża  za
                      dowiązaniami symbolicznymi podczas  wykonywania  poleceń
                      zmieniających  bieżący  katalog  roboczy, jak cd.  Używa
                      zamiast tego fizycznej struktury  katalogów.  Domyślnie,
                      bash  podąża  za  logicznym  łańcuchem katalogów podczas
                      wykonywania  poleceń   zmieniających   bieżący   katalog
                      roboczy.
              -T      Gdy  ustawiona,  pułapki  DEBUG i RETURN są dziedziczone
                      przez funkcje powłoki, uzupełnienia poleceń i  polecenia
                      wykonywane  w  środowisku  podpowłoki.  Pułapki  DEBUG i
                      RETURN nie są normalnie dziedziczone w  takich  przypad‐
                      kach.
              --      Jeżeli  po  tej  opcji nie występują żadne argumenty, to
                      parametry pozycyjne są  kasowane.  W  przeciwnym  razie,
                      parametry  pozycyjne  ustawiane  są  na argumenty, nawet
                      jeśli niektóre z nich zaczynają się od znaku -.
              -       Sygnalizuje koniec opcji, powodując przypisanie  wszyst‐
                      kich  pozostałych  argumentów do parametrów pozycyjnych.
                      Opcje -x i -v są wyłączane.  Jeżeli nie  ma  argumentów,
                      to parametry pozycyjne pozostają bez zmian.

              Opcje są domyślnie wyłączone, chyba że wskazano inaczej.  Użycie
              + zamiast - spowoduje, że opcje  te  zostaną  wyłączone.   Opcje
              mogą  także  zostać  określone jako argumenty wywołania powłoki.
              Bieżący zestaw opcji można znaleźć w $-.  Zwracanym  kodem  jest
              zawsze prawda, chyba że napotkano nieprawidłową opcję.

       shift [n]
              Parametrom  pozycyjnym  od  n+1  ...  zmienia  nazwy na $1 .....
              Parametry reprezentowane przez liczby $#  w  dół  do  $#-n+1  są
              usuwane.   n  musi  być  liczbą nieujemną mniejszą lub równą $#.
              Jeżeli n wynosi 0,  parametry  nie  są  zmieniane.   Jeżeli  nie
              podano  n,  zakłada  się, że wynosi 1.  Jeżeli n jest większe od
              $#, parametry pozycyjne nie są zmieniane.  Kod zakończenia  jest
              większy  od  zera  jeżeli  n  jest większe od $# lub mniejsze od
              zera; w przeciwnym wypadku 0.

       shopt [-pqsu] [-o] [nazwa_opcji ...]
              Przełącza wartości zmiennych sterujących opcjonalnym zachowaniem
              powłoki.   Bez  żadnych opcji, albo z opcją -p, wyświetlana jest
              lista wszystkich dających się ustawić opcji, ze  wskazaniem  dla
              każdej  czy  jest  ona ustawiona czy nie.  Opcja -p powoduje, że
              wyniki będą wyświetlane w postaci  dającej  się  ponownie  wyko‐
              rzystać  jako wejście.  Pozostałe opcje mają następujące znacze‐
              nie:
              -s     Włącz (ustaw) każdą nazwę_opcji.
              -u     Wyłącz (usuń) każdą nazwę_opcji.
              -q     Zaniechaj zwykłego wyświetlania  (tryb  cichy);  zwracany
                     kod wskazuje na to czy nazwa_opcji jest ustawiona czy nie
                     ustawiona.   Jeżeli  z   -q   podano   wiele   argumentów
                     nazw_opcji,  to  zwracanym kodem jest zero, gdy wszystkie
                     nazwy_opcji są włączone;  w  przeciwnym  razie  kod  jest
                     niezerowy.
              -o     Ogranicza wartości nazwy_opcji do wartości zdefiniowanych
                     dla opcji -o wbudowanego polecenia set.

              Jeżeli użyto albo -s albo -u bez argumentów nazw_opcji, wyświet‐
              lanie ogranicza się do tych opcji, które, odpowiednio, są ustaw‐
              ione bądź nieustawione.   Jeżeli  nie  wskazano  inaczej,  opcje
              shopt są domyślnie wyłączone (nie ustawione).

              Przy  listowaniu  opcji zwracany jest kod zerowy jeśli wszystkie
              nazwy_opcji są włączone, niezerowy w  przeciwnym  wypadku.  Przy
              ustawianiu  lub  kasowaniu opcji zwracany jest zerowy kod, chyba
              że nazwa_opcji nie jest poprawną opcją powłoki.

              Lista opcji shopt obejmuje:

              autocd  Jeśli jest ustawiona, nazwa polecenia będąca nazwą kata‐
                      logu  jest  wykonywana identycznie, jak gdyby była argu‐
                      mentem polecenia cd.  Opcja  ta  jest  używana  tylko  w
                      powłokach interaktywnych.
              cdable_vars
                      Jeśli  jest ustawiona, to nie będący katalogiem argument
                      wbudowanego polecenia cd uważany jest za nazwę zmiennej;
                      wartością   tej  zmiennej  jest  katalog,  na  który  ma
                      nastąpić zmiana.
              cdspell Jeśli jest ustawiona,  to  pomniejsze  błędy  w  pisowni
                      składowej  katalogu  w  poleceniu  cd  będą  poprawiane.
                      Sprawdzenie  takich  błędów  obejmuje  znaki  zamienione
                      miejscami,  znaki  pominięte  i pojedyncze zbędne znaki.
                      Jeżeli znaleziono  poprawkę,  wypisywana  jest  poprawna
                      nazwa  pliku a polecenie kontynuuje działanie.  Opcja ta
                      jest wykorzystywana tylko przez powłoki interaktywne.
              checkhash
                      Jeśli jest ustawiona, bash sprawdza przed próbą  wykona‐
                      nia  polecenia  znalezionego  w tablicy mieszającej, czy
                      polecenie to  istnieje.  Jeżeli  już  nie  istnieje,  to
                      wykonywane jest zwykłe przeszukiwanie ścieżki.
              checkjobs
                      Jeśli  jest  ustawiona,  bash  wypisuje  status  każdego
                      zatrzymanego i działającego zadania,  przed  wyjściem  z
                      powłoki  interaktywnej.  Jeśli  jakieś  zadanie  działa,
                      powoduje to odroczenia wyjścia do momentu, gdy  zostanie
                      przeprowadzona  druga  próba  wyjścia,  bez uruchamiania
                      dodatkowych poleceń  pomiędzy  próbami  (patrz  KONTROLA
                      ZADAŃ  powyżej).  Powłoka zawsze wstrzymuje wychodzenie,
                      gdy jakiekolwiek zadanie jest zatrzymane.
              checkwinsize
                      Jeżeli jest ustawione, bash  sprawdza  rozmiar  okna  po
                      każdym poleceniu i, jeśli zachodzi potrzeba, aktualizuje
                      wartość LINES i COLUMNS.
              cmdhist Jeżeli jest ustawione, bash  usiłuje  zapisać  wszystkie
                      wiersze  polecenia  wielowierszowego w tej samej pozycji
                      historii. Pozwala to na  łatwą  ponowną  edycję  poleceń
                      obejmujących wiele wierszy.
              compat31
                      Jeżeli  jest  ustawiona,  bash  używa swego zachowania z
                      wersji 3.1, z uwzględnianiem  cytowanych  argumentów  do
                      operatora =~ polecenia warunkowego [[.
              compat32
                      Gdy jest ustawiona, bash używa swego zachowania z wersji
                      3.2, respektując porównywanie łańcuchów z uwzględnieniem
                      locale, gdy używane są operatory < i > polecenia warunk‐
                      owego [[. Wersje do bash-4.1 używają kolejności ASCII  i
                      strcmp(3);  wersje  od  bash-4.1  używają bieżącej kole‐
                      jności locale i strcoll(3).
              compat40
                      Gdy jest ustawiona, bash używa swego zachowania z wersji
                      4.0, respektując porównywanie łańcuchów z uwzględnieniem
                      locale, gdy używane są operatory < i > polecenia warunk‐
                      owego  [[ (patrz poprzedni wpis powyżej) oraz efekt prz‐
                      erywania listy poleceń.
              compat41
                      Gdy ustawiona, bash, gdy jest w trybie  posix,  traktuje
                      pojedyncze  cudzysłowy w interpretacji ujętej w podwójne
                      cudzysłowy, jako znak  specjalny.  Pojedynczy  cudzysłów
                      musi  pasować  (musi  występować ich parzysta liczba), a
                      znaki pomiędzy pojedynczymi cudzysłowami  są  traktowane
                      jako  cytowane.  Jest to zachowanie trybu posix w wersji
                      4.1. Domyślne zachowania basha pozostaje takie samo, jak
                      w poprzednich wersjach.
              direxpand
                      Gdy  ustawiona,  bash zastępuje nazwy katalogów wynikami
                      rozwijania słów przy przeprowadzaniu  uzupełnienia  nazw
                      plików.  W  ten  sposób  zmieniana jest zawartość bufora
                      edycji readline. Jeśli nie jest  ustawiona,  bash  stara
                      się zachować treść wpisaną przez użytkownika.
              dirspell
                      Jeżeli jest ustawiona, bash stara się poprawić pomyłki w
                      nazwach katalogów podczas uzupełniania słów, jeśli nazwa
                      katalogu wprowadzonego pierwotnie, nie istnieje.
              dotglob Jeżeli  jest  ustawione,  to bash do wyników rozwinięcia
                      nazw plików włącza także nazwy plików rozpoczynające się
                      kropką `.'.
              execfail
                      Jeżeli  jest  ustawione, to powłoka nie-interaktywna nie
                      zakończy pracy nie mogąc wykonać pliku określonego  jako
                      argument wbudowanego polecenia exec.  Powłoka interakty‐
                      wna nie kończy pracy, jeśli exec zawiedzie.
              expand_aliases
                      Jeżeli jest  ustawiona,  aliasy  są  interpretowane  jak
                      opisano  powyżej  w  ALIASY.   Opcja  ta  jest  włączona
                      domyślnie dla powłok interaktywnych.
              extdebug
                      Gdy jest ustawiona, włączone jest  zachowanie  przeznac‐
                      zone do użycia przez debuggery:
                      1.     Opcja  -F wbudowanego polecenia declare wyświetla
                             nazwę   pliku   źródłowego   i   numer    wiersza
                             odpowiadający  każdej nazwie funkcji podanej jako
                             argument.
                      2.     Jeśli polecenie uruchomione przez  pułapkę  DEBUG
                             zwraca  wartość niezerową, kolejne polecenie jest
                             pomijane i nie jest wykonywane.
                      3.     Jeśli polecenie uruchamiane przez  pułapkę  DEBUG
                             zwróci  wartość 2, a powłoka wykonywana w podpro‐
                             gramie  (funkcja  powłoki  lub   skrypt   powłoki
                             wykonywany  wbudowanymi  .  lub source), to symu‐
                             lowane jest wywołanie do return.
                      4.     BASH_ARGC i BASH_ARGV są aktualizowane zgodnie  z
                             opisem w opisie tych zmiennych powyżej.
                      5.     Włączone  jest  śledzenie  funkcji:  podstawianie
                             poleceń, funkcje powłoki i podpowłoki  przywołane
                             za  pomocą ( polecenie ) dziedziczą pułapki DEBUG
                             i RETURN.
                      6.     Włączone  jest  śledzenie  błędów:   podstawianie
                             poleceń,  funkcje powłoki i podpowłoki przywołane
                             za pomocą ( polecenie ) dziedziczą pułapkę ERR.
              extglob Jeśli jest włączona,  włączane  są  rozszerzone  funkcje
                      dopasowywania  wzorców opisane powyżej w Rozwijanie nazw
                      plików.
              extquote
                      Jeżeli   jest   włączona,   cytowania   $'łańcuch'   and
                      $"łańcuch"   są  przeprowadzane  wewnątrz  interpretacji
                      ${parametr} ujętych w podwójne  cudzysłowy.  Opcja  jest
                      domyślnie włączona.
              failglob
                      Jeśli  jest  włączona,  wzorce do których nie dopasowano
                      nazw plików podczas  rozwinięcia  nazw  plików,  dają  w
                      wyniku błąd rozwinięcia (interpretacji).
              force_fignore
                      Jeśli   jest  ustawiona,  przyrostki  określone  zmienną
                      powłoki  FIGNORE  powodują  ignorowanie   słów   podczas
                      przeprowadzania  uzupełniania słów nawet, gdy ignorowane
                      słowa  są  jedynymi  dostępnymi  uzupełnieniami.  Proszę
                      zapoznać  się  z  ZMIENNE POWŁOKI, aby uzyskać opis FIG‐
                      NORE. Opcja jest domyślnie włączona.
              globstar
                      Gdy jest ustawiona,  wzorzec  **  używany  w  kontekście
                      rozwijania  nazw  plików,  dopasowuje  wszystkie pliki i
                      zero lub  więcej  katalogów  i  podkatalogów.  Jeśli  po
                      wzorcu  występuje /, to dopasowywane są jedynie katalogi
                      i podkatalogi.
              gnu_errfmt
                      Jeżeli jest ustawiona, komunikaty błędów powłoki są wyp‐
                      isywane w standardowym formacie błędów GNU.
              histappend
                      Jeżeli  jest  ustawiona,  to do pliku o nazwie wskazanej
                      zmienną HISTFILE podczas kończenia pracy  przez  powłokę
                      dodawana  jest lista historii, zamiast nadpisywania tego
                      pliku listą.
              histreedit
                      Jeżeli jest  ustawione,  a  używane  jest  readline,  to
                      użytkownik  ma możliwość ponownej edycji nieudanego pod‐
                      stawienia historii historii.
              histverify
                      Jeżeli jest  ustawione,  a  używane  jest  readline,  to
                      wyniki   podstawiania   historii   nie   są  natychmiast
                      przesyłane do analizatora powłoki. Zamiast tego,  wiersz
                      wynikowy  ładowany  jest  do bufora edycyjnego readline,
                      pozwalając na dalsze zmiany.
              hostcomplete
                      Jeżeli jest ustawione, a  używane  jest  readline,  bash
                      będzie usiłować wykonać uzupełnianie nazwy hosta podczas
                      uzupełniania słowa zawierającego @ (zobacz  Uzupełnianie
                      w READLINE powyżej).  Domyślnie włączone.
              huponexit
                      Jeżeli  jest  ustawione, to bash wyśle SIGHUP do wszyst‐
                      kich zadań podczas kończenia pracy interaktywnej powłoki
                      zgłoszeniowej.
              interactive_comments
                      Jeśli jest włączone, pozwala by słowo rozpoczynające się
                      od #  powodowało  pominięcie  tego  słowa  i  wszystkich
                      pozostałych   znaków  wiersza  w  powłoce  interaktywnej
                      (zobacz powyżej KOMENTARZE). Opcja domyślnie włączona.
              lastpipe
                      Jeśli jest ustawiona, a kontrola zadań nie jest aktywna,
                      powłoka  uruchamia  ostatnie polecenie potoku, który nie
                      jest wykonywany w tle, w bieżącym środowisku powłoki.
              lithist Jeśli jest ustawione, a włączona jest opcja cmdhist,  to
                      polecenia  wielowierszowe  zachowywane  są  w historii w
                      miarę możliwości z osadzonymi znakami nowej linii  zami‐
                      ast przy użyciu średników jako separatorów.
              login_shell
                      Powłoka ustawia tę opcję jeśli zostanie uruchomiona jako
                      zgłoszeniowa (zobacz WYWOŁANIE powyżej).  Ta wartość nie
                      może być zmieniona.
              mailwarn
                      Jeżeli  jest  ustawione, zaś do pliku, w którym sprawdza
                      pocztę bash sięgano od czasu ostatniego sprawdzania,  to
                      zostanie  wyświetlony komunikat ,,The mail in plikpoczty
                      has been read” (Poczta  w  plikpoczty  została  przeczy‐
                      tana).
              no_empty_cmd_completion
                      Jeśli jest ustawione, i stosowane jest readline, to bash
                      nie będzie usiłował szukać w PATH możliwych  uzupełnień,
                      gdy próba uzupełniania wystąpi w pustym wierszu.
              nocaseglob
                      Jeśli  zostało  ustawione,  to bash przy rozwijaniu nazw
                      plików dopasowuje je nie  zwracając  uwagi  na  wielkość
                      liter (zobacz Rozwijanie nazw plików powyżej).
              nocasematch
                      Gdy  jest  ustawiona,  bash  dopasowuje wzorce ignorując
                      wielkość liter, podczas wykonywania dopasowania, w  cza‐
                      sie wykonywania poleceń warunkowych case lub [[.
              nullglob
                      Jeśli  jest  ustawione,  to,  bash pozwala by wzorce nie
                      dopasowujące  żadnych  plików  (zobacz  Rozwijanie  nazw
                      plików  powyżej)  rozwijały się w łańcuch pusty, zamiast
                      na same siebie.
              progcomp
                      Jeżeli  jest  ustawione,  to  włączone  są  usługi  pro‐
                      gramowalnego  uzupełniania (zobacz powyżej Programowalne
                      uzupełnianie). Domyślnie włączone.
              promptvars
                      Jeżeli jest ustawione,  to  łańcuchy  zachęty  podlegają
                      interpretacji  zmiennych  i  podstawianiu  parametrów po
                      interpretacji zachęty opisanej w ZACHĘTA powyżej.  Opcja
                      ta jest domyślnie włączona.
              restricted_shell
                      Powłoka  ustawia  tę  opcję  jeśli została uruchomiona w
                      trybie  okrojonym  (zobacz  POWŁOKA  OKROJONA  poniżej).
                      Wartość  ta  nie może być zmieniona.  Nie jest ona rese‐
                      towana podczas odczytu plików startowych, pozwalając  im
                      na odkrycie czy powłoka jest okrojona czy nie.
              shift_verbose
                      Jeżeli jest ustawiona, to wbudowane shift wypisuje komu‐
                      nikat o błędzie  gdy  liczba  przesunięć  (przez  shift)
                      przekracza liczbę parametrów pozycyjnych.
              sourcepath
                      Jeśli  jest ustawiona, to polecenie wbudowane source (.)
                      posługuje się wartością  PATH  do  znalezienia  katalogu
                      zawierającego   plik   podany   jako   argument.   Opcja
                      domyślnie włączona.
              xpg_echo
                      Jeżeli jest ustawiona, to dla wbudowanego polecenia echo
                      włączane  jest  domyślne interpretowanie sekwencji spec‐
                      jalnych z odwrotnym ukośnikiem.

       suspend [-f]
              Zawiesza wykonywanie tej powłoki do otrzymania przez nią sygnału
              SIGCONT.   Opcja -f mówi, by nie narzekać, jeśli użyto suspend w
              powłoce  zgłoszeniowej;  po  prostu  zawiesić  mimo  to.   Kodem
              zwracanym  jest  0, chyba że powłoka jest powłoką zgłoszeniową i
              nie podano opcji -f, lub gdy nie jest włączona kontrola zadań.

       test wyraż
       [ wyraż ]
              Zwraca kod 0 lub  1  w  zależności  od  interpretacji  wyrażenia
              warunkowego  wyraż.   każdy operator i operand musi być odrębnym
              argumentem.  Wyrażenia składając  się  ze  składowych  opisanych
              powyżej w WYRAŻENIA WARUNKOWE. test nie akceptuje żadnych opcji,
              ani nie akceptuje i nie ignoruje  argumentu  --  jako  wskaźnika
              końca opcji.

              Wyrażenia  mogą  być  łączone przy użyciu poniższych operatorów,
              podanych w kolejności malejącego priorytetu.  Ich  interpretacja
              zależy  od  liczby argumentów; patrz niżej. Priorytet operatorów
              jest używany gdy występuje pięć argumentów lub więcej.
              ! wyraż
                     Prawda jeśli wyraż jest fałszem.
              ( wyraż )
                     Zwraca wartość wyraż.  Może  być  stosowane  do  obejścia
                     zwykłej kolejności operatorów.
              wyraż1 -a wyraż2
                     Prawda jeśli oba: wyraż1 i wyraż2 są prawdziwe.
              wyraż1 -o wyraż2
                     Prawda jeśli wyraż1 lub wyraż2 jest prawdziwe.

              test   i  [  interpretują  wyrażenia  warunkowe  posługując  się
              zestawem reguł opartych o liczbę argumentów.

              0 argumentów
                     Wyrażenie jest fałszywe.
              1 argument
                     Wyrażenie jest prawdziwe wtedy i tylko wtedy gdy argument
                     nie jest pusty (null).
              2 argumenty
                     Jeśli  pierwszym  argumentem  jest  !,  to wyrażenie jest
                     prawdziwe wtedy i tylko wtedy  gdy  drugi  argument  jest
                     pusty.  Jeśli  pierwszy argument jest jednym z jednoargu‐
                     mentowych  operatorów  warunkowych  podanych  powyżej   w
                     WYRAŻENIA  WARUNKOWE,  to wyrażenie jest prawdziwe jeżeli
                     test jednoargumentowy jest  prawdziwy.   Jeżeli  pierwszy
                     argument  nie jest poprawnym jednoargumentowym operatorem
                     warunkowym, to wyrażenie ma wartość fałsz.
              3 argumenty
                     Następujące warunki są stosowane w wypisanej  kolejności.
                     Jeżeli  drugi  argument  jest  jednym  z dwuargumentowych
                     operatorów  warunkowych  podanych  powyżej  w   WYRAŻENIA
                     WARUNKOWE,  to  wynik wyrażenia jest wynikiem dwuargumen‐
                     towego testu z zastosowaniem pierwszego i trzeciego argu‐
                     mentu  jako  operandów.  Operatory  -a i -o są uważane za
                     dwuargumentowe, jeśli  występują  trzy  argumenty.  Jeśli
                     pierwszym  argumentem  jest !, to wartość stanowi negację
                     testu dwuargumentowego przy użyciu drugiego  i  trzeciego
                     argumentu.  Jeśli pierwszym argumentem jest dokładnie ( a
                     trzecim argumentem dokładnie ), to wynik jest  jednoargu‐
                     mentowym  testem drugiego argumentu.  W pozostałych przy‐
                     padkach wyrażenie jest fałszywe.
              4 argumenty
                     Jeśli pierwszym argumentem jest !, to wynik jest  negacją
                     trójargumentowego wyrażenia złożonego z pozostałych argu‐
                     mentów.  W przeciwnym wypadku, wyrażenie jest  poddawanie
                     analizie  składni i interpretowane zgodnie z priorytetami
                     przy zastosowaniu reguł podanych powyżej.
              5 lub więcej argumentów
                     Wyrażenie jest poddawanie analizie  składni  i  interpre‐
                     towane  zgodnie  z  priorytetami  przy zastosowaniu reguł
                     podanych powyżej.

              Gdy operatory < i > są używane z test lub [, sortują  zgodnie  z
              porządkiem leksykograficznym używając kolejności ASCII.

       times  Wypisuje  sumaryczne  czasy  użytkownika i systemu dla powłoki i
              procesów z niej uruchomionych. Kodem zwracanym jest 0.

       trap [-lp] [argument] [sigspec ...]
              Polecenie argument ma zostać odczytane i wykonane,  gdy  powłoka
              otrzyma  sygnał(y)   sigspec.   Jeśli  nie występuje argument (i
              występuje pojedynczy sigspec) lub jest to -, to wszystkie podane
              sygnały  resetowane  są do swych wartości pierwotnych (wartości,
              jakie miały przy wejściu  do  powłoki).   Jeżeli  argument  jest
              łańcuchem  pustym,  to sygnał określony przez każde sigspec jest
              ignorowany  przez  powłokę  i  polecenia,  jakie  ona  wywołuje.
              Jeżeli nie wystąpił argument a podano -p, wyświetlane są polece‐
              nia  związane  z  przechwyceniem  każdego  z  sygnałów  sigspec.
              Jeżeli  nie podano żadnych argumentów lub jeśli podano tylko -p,
              to trap wypisuje listę poleceń związanych  z  każdym  z  numerów
              sygnałów.   Każde -l powoduje wypisanie przez powłokę listy nazw
              sygnałów i odpowiadających im  nazw.  Każdy  sigspec  jest  albo
              nazwą  sygnału  zdefiniowaną  w <signal.h> albo numerem sygnału.
              Wielkość liter nazw sygnałów nie ma znaczenia, a przedrostek SIG
              jest opcjonalny.

              Jeżeli  sigspec  jest  sygnałem  EXIT (0), to polecenie argument
              wykonywane jest  przy  kończeniu  pracy  przez  powłokę.  Jeżeli
              sigspec  jest równe DEBUG, to polecenie argument wykonywane jest
              po każdym poleceniu prostym, poleceniach  for,  case  i  select,
              każdym  poleceniem  arytmetycznym  for  i przed wykonaniem pier‐
              wszego polecenia w funkcji  powłoki  (zobacz  GRAMATYKA  POWŁOKI
              powyżej).  Proszę  zapoznać  się z opisem opcji extdebug do wbu‐
              dowanego shopt, aby dowiedzieć się więcej na temat jej wpływu na
              pułapkę  DEBUG.  Jeśli  sigspec to RETURN, to polecenie argument
              jest wykonywane zawsze, gdy funkcja powłoki lub  skrypt  wykony‐
              wany wbudowanymi . lub source kończą swe wykonanie.

              Jeśli  sigspec  jest  ERR, wówczas polecenie argument wykonywane
              jest każdorazowo  gdy  polecenie  proste  zwróci  niezerowy  kod
              zakończenia.   Pułapka zastawiona na ERR nie jest wykonywana gdy
              polecenie, które zakończyło się  niepowodzeniem  jest  występuje
              bezpośrednio po słowach kluczowych while lub until, jest częścią
              testu instrukcji if, częścią poleceń wykonywanych w  listach  &&
              lub  ⎪⎪  albo  jeśli  wartość  zwracana  przez to polecenie jest
              wstawiana za pomocą !. Identyczne warunki są przestrzegane przez
              opcję errexit.

              Sygnały  ignorowane przy wejściu do powłoki nie mogą być przech‐
              wycone ani  zresetowane.   W  procesie  potomnym,  podczas  jego
              tworzenia,  sygnały przechwycone resetowane są do swych wartości
              pierwotnych.  Zwracanym kodem jest fałsz  jeśli  którykolwiek  z
              sigspec jest nieprawidłowy; w przeciwnym razie trap zwraca true.

       type [-aftpP] nazwa [nazwa ...]
              Bez opcji wskazuje, jak powinna być interpretowana każda z nazw,
              jeśli zostanie użyta jako nazwa polecenia.  Jeżeli  użyto  opcji
              -t,  to  type  wypisuje  łańcuch będący jednym z alias, keyword,
              function,  builtin  lub  file,  jeśli  nazwa  jest   odpowiednio
              aliasem,  zastrzeżonym  słowem powłoki, funkcją, poleceniem wbu‐
              dowanym lub plikiem dyskowym.  Jeśli nie  znaleziono  nazwy,  to
              nie  jest  wypisywane  nic  i jako kod zakończenia zwracany jest
              fałsz.  Jeśli posłużono się opcją -p to type zwraca  albo  nazwę
              pliku  dyskowego,  który zostałby wykonany jeśli nazwa zostałaby
              podana jako nazwa polecenia, albo nic jeśli ``type -t name'' nie
              zwróciłoby  file.  Opcja -P wymusza na PATH wyszukiwanie każdego
              name, nawet jeśli ``type -t name'' nie  zwróciłoby  file.  Jeśli
              polecenie  zostało  zapamiętane poleceniem hash, to -p i -P wyp‐
              isuje jego wartość,  niekoniecznie  plik  pojawiający  się  jako
              pierwszy  w  PATH. Jeśli użyto opcji -a, to type wypisuje wszys‐
              tkie miejsca zawierające plik wykonywalny o nazwie nazwa. Aliasy
              i  funkcje  są  uwzględniane  wyłącznie jeśli nie podano również
              opcji -p. Tablica  zapamiętanym  poleceń  nie  jest  sprawdzana,
              jeśli użyto -a. Opcja -f przesłania funkcję wyszukiwania powłoki
              jak wbudowanym command. type  zwraca  prawdę  jeśli  odnaleziono
              wszystkie   argumenty   i   fałsz,   gdy  któregoś  z  nich  nie
              odnaleziono.

       ulimit [-HSTabcdefilmnpqrstuvx [limit]]
              Zapewnia kontrolę nad zasobami  dostępnymi  powłoce  i  procesów
              jakie ona uruchamia, na systemach umożliwiających taką kontrolę.
              Opcje -H i -S określają, że dla  danego  zasobu  ustawiane  jest
              twarde  (hard)  lub  miękkie  (soft)  ograniczenie. Ograniczenie
              twarde nie może być zwiększane  przez  zwykłego  użytkownika  po
              ustawieniu;  ograniczenie  miękkie  może  być  zwiększane  aż do
              wartości ograniczenia twardego. Jeśli nie podano ani -H ani  -S,
              to  ustawiane  jest  zarówno  ograniczenie miękkie jak i twarde.
              Ograniczenie limit może być liczbą w jednostkach określonych dla
              zasobu  lub jedną ze specjalnych wartości: hard, soft lub unlim‐
              ited, oznaczających odpowiednio:  bieżące  twarde  ograniczenie,
              bieżące  miękkie  ograniczenie  oraz  brak ograniczenia.  Jeżeli
              pominięto limit, wypisywana jest  bieżąca  wartość  ograniczenia
              miękkiego  danego  zasobu,  chyba że podano opcję -H. Gdy podano
              więcej niż jedno określenie zasobu, przed  wartością  wypisywana
              jest nazwa ograniczenia i jednostka miary.  Inne opcje interpre‐
              towane są następująco:
              -a     Podawane są wszystkie bieżące ograniczenia
              -b     Maksymalny rozmiar bufora gniazda
              -c     Maksymalny rozmiar tworzonych plików core
              -d     Maksymalny rozmiar segmentu danych procesu
              -e     Maksymalny priorytet planisty ("nice")
              -f     Maksymalny rozmiar plików zapisywanych  przez  powłokę  i
                     jej potomków
              -i     Maksymalna liczba oczekujących sygnałów
              -l     Maksymalny   rozmiar,  jaki  może  zostać  zablokowany  w
                     pamięci
              -m     Maksymalny rozmiar części rezydentnej (wiele systemów nie
                     przestrzega tego limitu)
              -n     Maksymalna liczba otwartych deskryptorów pliku (większość
                     systemów nie pozwala na ustawianie tej wartości)
              -p     Rozmiar potoku w  blokach  512-bajtowych  (może  nie  być
                     ustawione)
              -q     Maksymalny rozmiar kolejek komunikatów POSIX, w bajtach
              -r     Maksymalny priorytet rzeczywisty planisty
              -s     Maksymalny rozmiar stosu
              -t     Maksymalny czas CPU w sekundach
              -u     Maksymalna  liczba  procesów  dostępnych dla pojedynczego
                     użytkownika
              -v     Maksymalna  wielkość  pamięci  wirtualnej  dostępna   dla
                     powłoki i, w niektórych systemach, dla jej potomków.
              -x     Maksymalna liczba plików blokad
              -T     Maksymalna liczba wątków

              Jeżeli  podano  limit,  to staje się nową wartością ograniczenia
              zadanego zasobu (opcja -a tylko wyświetla).  Jeżeli  nie  podano
              żadnej  opcji,  to  zakłada  się opcję -f.  Wartości podawane są
              przyrostowo co 1024-bajty, z wyjątkiem -t, podawanego  w  sekun‐
              dach,  -p,  w jednostkach 512-bajtowych bloków, oraz -T, -b, -n,
              and -u, będących wartościami bez miana. Zwracanym kodem jest  0,
              chyba  że  podano  nieprawidłową opcję lub argument albo podczas
              ustawiania nowego ograniczenia wystąpił błąd.

       umask [-p] [-S] [tryb]
              Maska praw  dostępu  dla  plików  tworzonych  przez  użytkownika
              ustawiana  jest  na  tryb.  Jeżeli tryb rozpoczyna się od cyfry,
              jest interpretowany jako liczba  ósemkowa;  w  przeciwnym  razie
              interpretowany  jest  jako maska w trybie symbolicznym, podobnie
              jak akceptowane przez chmod(1).  Jeżeli pominięto  tryb  wypisy‐
              wana  jest  aktualna wartość maski.  Opcja -S powoduje, że maska
              zostanie wypisana w postaci symbolicznej; domyślne wyjście  jest
              w  postaci liczby ósemkowej.  Jeżeli podano opcję -p i pominięto
              tryb, to wyjście ma postać, która może być  powtórnie  wykorzys‐
              tana  jako  wejście.   Kodem  zwracanym  jest  0 jeśli pomyślnie
              zmieniono tryb lub  nie  podano  argumentu  tryb,  zaś  fałsz  w
              pozostałych sytuacjach.

       unalias [-a] [nazwa ...]
              Usuwa każdą z nazw z listy zdefiniowanych aliasów. Jeżeli podano
              -a, to usuwane są definicje wszystkich aliasów. Zwracanym  kodem
              jest  prawda,  chyba  że  podana  nazwa  nie  jest zdefiniowanym
              aliasem.

       unset [-fv] [nazwa ...]
              Dla każdej nazwy, usuwa odpowiadającą jej wartość  lub  funkcję.
              Jeżeli  nie podano żadnych opcji lub podano opcję -v, to każda z
              nazw odnosi się do zmiennej powłoki.  Zmienne read-only nie mogą
              być  kasowane.   Jeżeli  podano  -f, to każda z nazw wskazuje na
              funkcję powłoki, a definicja  funkcji  jest  usuwana.   Każda  z
              usuniętych  zmiennych  lub  funkcji  usuwana  jest ze środowiska
              przesyłanego  następnym  poleceniom.   Jeśli  usunięta  zostanie
              któraś  ze  zmiennych  COMP_WORDBREAKS, RANDOM, SECONDS, LINENO,
              HISTCMD, FUNCNAME, GROUPS, lub DIRSTACK, to traci ona swe  spec‐
              jalne  właściwości,  nawet  jeśli  zostanie  następnie  ponownie
              ustawiona. Kodem zakończenia jest prawda,  chyba  że  nazwa  nie
              istnieje lub jest readonly.

       wait [n ...]
              Czeka  na  każdy podany proces i zwraca jego kod zakończenia.  n
              może być identyfikatorem procesu lub określeniem zadania;  jeśli
              podano  określenie  zadania, to nastąpi oczekiwanie na wszystkie
              procesy w potoku tego zadania.  Jeżeli nie podano  n,  następuje
              oczekiwanie  na  wszystkie  aktualnie  aktywne procesy potomne i
              zwracany jest kod zerowy.  Jeśli n określa nieistniejący  proces
              lub  zadanie,  to zwracany jest kod 127.  W pozostałych przypad‐
              kach zwracany jest kod zakończenia ostatniego procesu lub  zada‐
              nia na jakie czekano.

POWŁOKA OKROJONA
       Jeśli  bash  uruchomiony  jest pod nazwą rbash, lub przy jego wywołaniu
       posłużono się opcją -r, to staje  się  powłoką  okrojoną  (restricted).
       Powłoka  okrojona  służy do ustawienia środowiska lepiej kontrolowanego
       niż powłoka standardowa. Zachowuje  się  ona  identycznie  jak  bash  z
       wyjątkiem tego, że poniższe nie są dozwolone lub nie są wykonywane:

       ·      zmiana katalogów przy pomocy cd

       ·      ustawianie lub kasowanie wartości SHELL, PATH, ENV lub BASH_ENV

       ·      podawanie nazw poleceń zawierających /

       ·      podawanie nazw plików zawierających / jako argumentu wbudowanego
              polecenia . (kropka).

       ·      podawanie nazwy pliku  zawierającej  ukośnik  jako  argument  do
              opcji -p wbudowanego polecenia hash.

       ·      importowanie   definicji  funkcji  ze  środowiska  powłoki  przy
              uruchamianiu

       ·      analiza wartości SHELLOPTS ze środowiska powłoki przy uruchamia‐
              niu

       ·      przekierowywanie  wyjścia  przy pomocy operatorów >, >|, <>, >&,
              &> i >>

       ·      posługiwanie się wbudowanym poleceniem exec w  celu  zastąpienia
              powłoki innym poleceniem

       ·      dodawanie  lub  usuwanie  poleceń przy pomocy opcji -f i -d wbu‐
              dowanego polecenia enable

       ·      używanie wbudowanego polecenia enable do  włączania  wyłączonych
              wbudowanych poleceń powłoki

       ·      podawanie opcji -p wbudowanego polecenia command

       ·      wyłączanie  trybu  okrojonego  za  pomocą  set  +r  lub  set  +o
              restricted.

       Powyższe  ograniczenia  wymuszane  są  po  przeczytaniu   plików   uru‐
       chomieniowych.

       Jeśli  wykonywane  polecenie  okaże się skryptem powłoki (patrz WYKONY‐
       WANIE POLECEŃ  powyżej),  to  rbash  wyłącza  wszelkie  ograniczenia  w
       powłoce zrodzonej do wykonania skryptu.

ZOBACZ TAKŻE
       Bash Features, Brian Fox i Chet Ramey
       The Gnu Readline Library, Brian Fox i Chet Ramey
       The Gnu History Library, Brian Fox i Chet Ramey
       Portable  Operating  System  Interface (POSIX) Part 2: Shell and Utili‐
       ties, IEEE
       sh(1), ksh(1), csh(1)
       emacs(1), vi(1)
       readline(3)

PLIKI
       /bin/bash
              Plik wykonywalny powłoki bash
       /etc/profile
              Ogólnosystemowy   plik   inicjujący,   wykonywany   dla   powłok
              zgłoszeniowych
       /etc/bash.bashrc
              Ogólnosystemowy plik startowy dla powłoki interaktywnej
       /etc/bash.bash.logout
              Ogólnosystemowy  plik  porządkujący  dla  powłoki zgłoszeniowej,
              wykonywany podczas kończenia przez nią pracy
       ~/.bash_profile
              Osobisty plik inicjujący, wykonywany dla powłok zgłoszeniowych
       ~/.bashrc
              Indywidualny plik startowy dla powłoki trybu interaktywnego
       ~/.bash_logout
              Indywidualny  plik  porządkujący  dla   powłoki   zgłoszeniowej,
              wykonywany podczas kończenia przez nią pracy
       ~/.inputrc
              Indywidualny plik inicjujący do readline

AUTORZY
       Brian Fox, Free Software Foundation
       bfox@gnu.org

       Chet Ramey, Case Western Reserve University
       chet.ramey@case.edu

ZGŁOSZENIA BŁĘDÓW
       Jeśli  znajdziesz  w  bash  błąd,  powinieneś  go zgłosić. Ale najpierw
       powinieneś upewnić się, że rzeczywiście jest to błąd i że pojawia się w
       najświeższej  wersji  bash  jaką  masz.  Jest  ona  zawsze dostępna pod
       adresem ftp://ftp.gnu.org/pub/gnu/bash/.

       Po ustaleniu, że błąd faktycznie istnieje, użyj  polecenia  bashbug  do
       wysłania  zgłoszenia  błędu.   Jeśli  masz  poprawkę usuwającą problem,
       zachęcamy  do  przesłania  jej  również!  Sugestie   i   `filozoficzne'
       zgłoszenia   błędów  mogą  być  przesyłane  [w  języku  angielskim]  do
       bug-bash@gnu.org lub wysyłane na grupę dyskusyjną gnu.bash.bug.

       WSZYSTKIE zgłoszenia błędów powinny zawierać:

       Numer wersji bash
       Sprzęt i system operacyjny
       Użyty kompilator
       Opis błędnego zachowania
       Krótki skrypt lub przepis na uzyskanie błędu

       bashbug wstawia pierwsze trzy pozycje automatycznie  do  szablonu  jaki
       udostępnia w celu wypełnienia zgłoszenia błędów.

       Komentarze  i  zgłoszenia błędów dotyczące tej strony podręcznika [ory‐
       ginału] powinny być kierowane na adres chet.ramey@case.edu.

BŁĘDY
       Jest za duży i zbyt wolny.

       Istnieje trochę subtelnych różnic pomiędzy bash a tradycyjnymi wersjami
       sh, głównie z powodu specyfikacji POSIX.

       Aliasy w niektórych zastosowaniach wprawiają w zakłopotanie.

       Poleceń wbudowanych powłoki i funkcji nie można zatrzymywać/wznawiać.

       Polecenia  złożone  i  sekwencje  poleceń  postaci  `a  ; b ; c' nie są
       obsługiwane przychylnie przy próbie  wstrzymania  procesu.  Gdy  proces
       jest  zatrzymany,  powłoka natychmiast wykonuje następne polecenie sek‐
       wencji.  Wystarcza umieszczanie sekwencji poleceń wewnątrz nawiasów  by
       wymusić  wykonanie ich przez podpowłokę, która może być zatrzymana jako
       całość.

       Zmienne tablicowe nie mogą być (na razie) eksportowane.

       Może istnieć tylko jeden aktywny współproces w danym czasie.

TŁUMACZENIE
       Autorami polskiego tłumaczenia niniejszej strony  podręcznika  man  są:
       Wojtek    Kotwica    (PTM)    <wkotwica@post.pl>    i   Michał   Kułach
       <michal.kulach@gmail.com>.

       Polskie tłumaczenie jest częścią projektu  manpages-pl;  uwagi,  pomoc,
       zgłaszanie  błędów na stronie http://sourceforge.net/projects/manpages-
       pl/. Jest zgodne z wersją  4.2 oryginału.



GNU Bash-4.2                    28 grudnia 2010                        BASH(1)
